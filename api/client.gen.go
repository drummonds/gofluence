// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package api

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
)

const (
	BasicAuthScopes        = "basicAuth.Scopes"
	OAuthDefinitionsScopes = "oAuthDefinitions.Scopes"
)

// Defines values for AccountStatus.
const (
	AccountStatusActive   AccountStatus = "active"
	AccountStatusClosed   AccountStatus = "closed"
	AccountStatusInactive AccountStatus = "inactive"
	AccountStatusUnknown  AccountStatus = "unknown"
)

// Defines values for AccountType.
const (
	AccountTypeApp       AccountType = "app"
	AccountTypeAtlassian AccountType = "atlassian"
	AccountTypeCustomer  AccountType = "customer"
	AccountTypeUnknown   AccountType = "unknown"
)

// Defines values for AncestorType.
const (
	AncestorTypeDatabase   AncestorType = "database"
	AncestorTypeEmbed      AncestorType = "embed"
	AncestorTypeFolder     AncestorType = "folder"
	AncestorTypePage       AncestorType = "page"
	AncestorTypeWhiteboard AncestorType = "whiteboard"
)

// Defines values for AttachmentSortOrder.
const (
	AttachmentSortOrderCreatedDate       AttachmentSortOrder = "created-date"
	AttachmentSortOrderMinusCreatedDate  AttachmentSortOrder = "-created-date"
	AttachmentSortOrderMinusModifiedDate AttachmentSortOrder = "-modified-date"
	AttachmentSortOrderModifiedDate      AttachmentSortOrder = "modified-date"
)

// Defines values for BlogPostBodyWriteRepresentation.
const (
	BlogPostBodyWriteRepresentationAtlasDocFormat BlogPostBodyWriteRepresentation = "atlas_doc_format"
	BlogPostBodyWriteRepresentationStorage        BlogPostBodyWriteRepresentation = "storage"
	BlogPostBodyWriteRepresentationWiki           BlogPostBodyWriteRepresentation = "wiki"
)

// Defines values for BlogPostContentStatus.
const (
	BlogPostContentStatusAny        BlogPostContentStatus = "any"
	BlogPostContentStatusCurrent    BlogPostContentStatus = "current"
	BlogPostContentStatusDeleted    BlogPostContentStatus = "deleted"
	BlogPostContentStatusDraft      BlogPostContentStatus = "draft"
	BlogPostContentStatusHistorical BlogPostContentStatus = "historical"
	BlogPostContentStatusTrashed    BlogPostContentStatus = "trashed"
)

// Defines values for BlogPostSortOrder.
const (
	BlogPostSortOrderCreatedDate       BlogPostSortOrder = "created-date"
	BlogPostSortOrderId                BlogPostSortOrder = "id"
	BlogPostSortOrderMinusCreatedDate  BlogPostSortOrder = "-created-date"
	BlogPostSortOrderMinusId           BlogPostSortOrder = "-id"
	BlogPostSortOrderMinusModifiedDate BlogPostSortOrder = "-modified-date"
	BlogPostSortOrderModifiedDate      BlogPostSortOrder = "modified-date"
)

// Defines values for ChildCustomContentSortOrder.
const (
	ChildCustomContentSortOrderCreatedDate       ChildCustomContentSortOrder = "created-date"
	ChildCustomContentSortOrderId                ChildCustomContentSortOrder = "id"
	ChildCustomContentSortOrderMinusCreatedDate  ChildCustomContentSortOrder = "-created-date"
	ChildCustomContentSortOrderMinusId           ChildCustomContentSortOrder = "-id"
	ChildCustomContentSortOrderMinusModifiedDate ChildCustomContentSortOrder = "-modified-date"
	ChildCustomContentSortOrderModifiedDate      ChildCustomContentSortOrder = "modified-date"
)

// Defines values for ChildPageSortOrder.
const (
	ChildPageSortOrderChildPosition      ChildPageSortOrder = "child-position"
	ChildPageSortOrderCreatedDate        ChildPageSortOrder = "created-date"
	ChildPageSortOrderId                 ChildPageSortOrder = "id"
	ChildPageSortOrderMinusChildPosition ChildPageSortOrder = "-child-position"
	ChildPageSortOrderMinusCreatedDate   ChildPageSortOrder = "-created-date"
	ChildPageSortOrderMinusId            ChildPageSortOrder = "-id"
	ChildPageSortOrderMinusModifiedDate  ChildPageSortOrder = "-modified-date"
	ChildPageSortOrderModifiedDate       ChildPageSortOrder = "modified-date"
)

// Defines values for ClassificationLevelColor.
const (
	BLUE    ClassificationLevelColor = "BLUE"
	GREEN   ClassificationLevelColor = "GREEN"
	GREY    ClassificationLevelColor = "GREY"
	LIME    ClassificationLevelColor = "LIME"
	NAVY    ClassificationLevelColor = "NAVY"
	ORANGE  ClassificationLevelColor = "ORANGE"
	PURPLE  ClassificationLevelColor = "PURPLE"
	RED     ClassificationLevelColor = "RED"
	REDBOLD ClassificationLevelColor = "RED_BOLD"
	TEAL    ClassificationLevelColor = "TEAL"
	YELLOW  ClassificationLevelColor = "YELLOW"
)

// Defines values for ClassificationLevelStatus.
const (
	ARCHIVED  ClassificationLevelStatus = "ARCHIVED"
	DRAFT     ClassificationLevelStatus = "DRAFT"
	PUBLISHED ClassificationLevelStatus = "PUBLISHED"
)

// Defines values for CommentBodyWriteRepresentation.
const (
	CommentBodyWriteRepresentationAtlasDocFormat CommentBodyWriteRepresentation = "atlas_doc_format"
	CommentBodyWriteRepresentationStorage        CommentBodyWriteRepresentation = "storage"
	CommentBodyWriteRepresentationWiki           CommentBodyWriteRepresentation = "wiki"
)

// Defines values for CommentSortOrder.
const (
	CommentSortOrderCreatedDate       CommentSortOrder = "created-date"
	CommentSortOrderMinusCreatedDate  CommentSortOrder = "-created-date"
	CommentSortOrderMinusModifiedDate CommentSortOrder = "-modified-date"
	CommentSortOrderModifiedDate      CommentSortOrder = "modified-date"
)

// Defines values for ContentIdToContentTypeResponseResults0.
const (
	ContentIdToContentTypeResponseResults0Attachment    ContentIdToContentTypeResponseResults0 = "attachment"
	ContentIdToContentTypeResponseResults0Blogpost      ContentIdToContentTypeResponseResults0 = "blogpost"
	ContentIdToContentTypeResponseResults0FooterComment ContentIdToContentTypeResponseResults0 = "footer-comment"
	ContentIdToContentTypeResponseResults0InlineComment ContentIdToContentTypeResponseResults0 = "inline-comment"
	ContentIdToContentTypeResponseResults0Page          ContentIdToContentTypeResponseResults0 = "page"
)

// Defines values for ContentPropertySortOrder.
const (
	ContentPropertySortOrderKey      ContentPropertySortOrder = "key"
	ContentPropertySortOrderMinusKey ContentPropertySortOrder = "-key"
)

// Defines values for ContentStatus.
const (
	ContentStatusAny        ContentStatus = "any"
	ContentStatusArchived   ContentStatus = "archived"
	ContentStatusCurrent    ContentStatus = "current"
	ContentStatusDeleted    ContentStatus = "deleted"
	ContentStatusDraft      ContentStatus = "draft"
	ContentStatusHistorical ContentStatus = "historical"
	ContentStatusTrashed    ContentStatus = "trashed"
)

// Defines values for CustomContentBodyRepresentation.
const (
	CustomContentBodyRepresentationAtlasDocFormat CustomContentBodyRepresentation = "atlas_doc_format"
	CustomContentBodyRepresentationRaw            CustomContentBodyRepresentation = "raw"
	CustomContentBodyRepresentationStorage        CustomContentBodyRepresentation = "storage"
)

// Defines values for CustomContentBodyRepresentationSingle.
const (
	CustomContentBodyRepresentationSingleAnonymousExportView CustomContentBodyRepresentationSingle = "anonymous_export_view"
	CustomContentBodyRepresentationSingleAtlasDocFormat      CustomContentBodyRepresentationSingle = "atlas_doc_format"
	CustomContentBodyRepresentationSingleExportView          CustomContentBodyRepresentationSingle = "export_view"
	CustomContentBodyRepresentationSingleRaw                 CustomContentBodyRepresentationSingle = "raw"
	CustomContentBodyRepresentationSingleStorage             CustomContentBodyRepresentationSingle = "storage"
	CustomContentBodyRepresentationSingleView                CustomContentBodyRepresentationSingle = "view"
)

// Defines values for CustomContentBodyWriteRepresentation.
const (
	CustomContentBodyWriteRepresentationAtlasDocFormat CustomContentBodyWriteRepresentation = "atlas_doc_format"
	CustomContentBodyWriteRepresentationRaw            CustomContentBodyWriteRepresentation = "raw"
	CustomContentBodyWriteRepresentationStorage        CustomContentBodyWriteRepresentation = "storage"
)

// Defines values for CustomContentSortOrder.
const (
	CustomContentSortOrderCreatedDate       CustomContentSortOrder = "created-date"
	CustomContentSortOrderId                CustomContentSortOrder = "id"
	CustomContentSortOrderMinusCreatedDate  CustomContentSortOrder = "-created-date"
	CustomContentSortOrderMinusId           CustomContentSortOrder = "-id"
	CustomContentSortOrderMinusModifiedDate CustomContentSortOrder = "-modified-date"
	CustomContentSortOrderMinusTitle        CustomContentSortOrder = "-title"
	CustomContentSortOrderModifiedDate      CustomContentSortOrder = "modified-date"
	CustomContentSortOrderTitle             CustomContentSortOrder = "title"
)

// Defines values for InlineCommentResolutionStatus.
const (
	InlineCommentResolutionStatusDangling InlineCommentResolutionStatus = "dangling"
	InlineCommentResolutionStatusOpen     InlineCommentResolutionStatus = "open"
	InlineCommentResolutionStatusReopened InlineCommentResolutionStatus = "reopened"
	InlineCommentResolutionStatusResolved InlineCommentResolutionStatus = "resolved"
)

// Defines values for LabelSortOrder.
const (
	LabelSortOrderCreatedDate      LabelSortOrder = "created-date"
	LabelSortOrderId               LabelSortOrder = "id"
	LabelSortOrderMinusCreatedDate LabelSortOrder = "-created-date"
	LabelSortOrderMinusId          LabelSortOrder = "-id"
	LabelSortOrderMinusName        LabelSortOrder = "-name"
	LabelSortOrderName             LabelSortOrder = "name"
)

// Defines values for OnlyArchivedAndCurrentContentStatus.
const (
	OnlyArchivedAndCurrentContentStatusArchived OnlyArchivedAndCurrentContentStatus = "archived"
	OnlyArchivedAndCurrentContentStatusCurrent  OnlyArchivedAndCurrentContentStatus = "current"
)

// Defines values for PageBodyWriteRepresentation.
const (
	PageBodyWriteRepresentationAtlasDocFormat PageBodyWriteRepresentation = "atlas_doc_format"
	PageBodyWriteRepresentationStorage        PageBodyWriteRepresentation = "storage"
	PageBodyWriteRepresentationWiki           PageBodyWriteRepresentation = "wiki"
)

// Defines values for PageSortOrder.
const (
	PageSortOrderCreatedDate       PageSortOrder = "created-date"
	PageSortOrderId                PageSortOrder = "id"
	PageSortOrderMinusCreatedDate  PageSortOrder = "-created-date"
	PageSortOrderMinusId           PageSortOrder = "-id"
	PageSortOrderMinusModifiedDate PageSortOrder = "-modified-date"
	PageSortOrderMinusTitle        PageSortOrder = "-title"
	PageSortOrderModifiedDate      PageSortOrder = "modified-date"
	PageSortOrderTitle             PageSortOrder = "title"
)

// Defines values for ParentContentType.
const (
	ParentContentTypeDatabase   ParentContentType = "database"
	ParentContentTypeEmbed      ParentContentType = "embed"
	ParentContentTypeFolder     ParentContentType = "folder"
	ParentContentTypePage       ParentContentType = "page"
	ParentContentTypeWhiteboard ParentContentType = "whiteboard"
)

// Defines values for PrimaryBodyRepresentation.
const (
	PrimaryBodyRepresentationAtlasDocFormat PrimaryBodyRepresentation = "atlas_doc_format"
	PrimaryBodyRepresentationStorage        PrimaryBodyRepresentation = "storage"
)

// Defines values for PrimaryBodyRepresentationSingle.
const (
	PrimaryBodyRepresentationSingleAnonymousExportView PrimaryBodyRepresentationSingle = "anonymous_export_view"
	PrimaryBodyRepresentationSingleAtlasDocFormat      PrimaryBodyRepresentationSingle = "atlas_doc_format"
	PrimaryBodyRepresentationSingleEditor              PrimaryBodyRepresentationSingle = "editor"
	PrimaryBodyRepresentationSingleExportView          PrimaryBodyRepresentationSingle = "export_view"
	PrimaryBodyRepresentationSingleStorage             PrimaryBodyRepresentationSingle = "storage"
	PrimaryBodyRepresentationSingleStyledView          PrimaryBodyRepresentationSingle = "styled_view"
	PrimaryBodyRepresentationSingleView                PrimaryBodyRepresentationSingle = "view"
)

// Defines values for SpaceDescriptionBodyRepresentation.
const (
	Plain SpaceDescriptionBodyRepresentation = "plain"
	View  SpaceDescriptionBodyRepresentation = "view"
)

// Defines values for SpacePermissionOperationKey.
const (
	Administer      SpacePermissionOperationKey = "administer"
	Archive         SpacePermissionOperationKey = "archive"
	Copy            SpacePermissionOperationKey = "copy"
	Create          SpacePermissionOperationKey = "create"
	CreateSpace     SpacePermissionOperationKey = "create_space"
	Delete          SpacePermissionOperationKey = "delete"
	Export          SpacePermissionOperationKey = "export"
	Move            SpacePermissionOperationKey = "move"
	Purge           SpacePermissionOperationKey = "purge"
	PurgeVersion    SpacePermissionOperationKey = "purge_version"
	Read            SpacePermissionOperationKey = "read"
	Restore         SpacePermissionOperationKey = "restore"
	RestrictContent SpacePermissionOperationKey = "restrict_content"
	Update          SpacePermissionOperationKey = "update"
	Use             SpacePermissionOperationKey = "use"
)

// Defines values for SpacePermissionOperationTargetType.
const (
	SpacePermissionOperationTargetTypeApplication SpacePermissionOperationTargetType = "application"
	SpacePermissionOperationTargetTypeAttachment  SpacePermissionOperationTargetType = "attachment"
	SpacePermissionOperationTargetTypeBlogpost    SpacePermissionOperationTargetType = "blogpost"
	SpacePermissionOperationTargetTypeComment     SpacePermissionOperationTargetType = "comment"
	SpacePermissionOperationTargetTypeDatabase    SpacePermissionOperationTargetType = "database"
	SpacePermissionOperationTargetTypeEmbed       SpacePermissionOperationTargetType = "embed"
	SpacePermissionOperationTargetTypeFolder      SpacePermissionOperationTargetType = "folder"
	SpacePermissionOperationTargetTypePage        SpacePermissionOperationTargetType = "page"
	SpacePermissionOperationTargetTypeSpace       SpacePermissionOperationTargetType = "space"
	SpacePermissionOperationTargetTypeUserProfile SpacePermissionOperationTargetType = "userProfile"
	SpacePermissionOperationTargetTypeWhiteboard  SpacePermissionOperationTargetType = "whiteboard"
)

// Defines values for SpacePermissionPrincipalType.
const (
	SpacePermissionPrincipalTypeGroup SpacePermissionPrincipalType = "group"
	SpacePermissionPrincipalTypeRole  SpacePermissionPrincipalType = "role"
	SpacePermissionPrincipalTypeUser  SpacePermissionPrincipalType = "user"
)

// Defines values for SpaceSortOrder.
const (
	SpaceSortOrderId        SpaceSortOrder = "id"
	SpaceSortOrderKey       SpaceSortOrder = "key"
	SpaceSortOrderMinusId   SpaceSortOrder = "-id"
	SpaceSortOrderMinusKey  SpaceSortOrder = "-key"
	SpaceSortOrderMinusName SpaceSortOrder = "-name"
	SpaceSortOrderName      SpaceSortOrder = "name"
)

// Defines values for SpaceStatus.
const (
	SpaceStatusArchived SpaceStatus = "archived"
	SpaceStatusCurrent  SpaceStatus = "current"
)

// Defines values for SpaceType.
const (
	SpaceTypeCollaboration SpaceType = "collaboration"
	SpaceTypeGlobal        SpaceType = "global"
	SpaceTypeKnowledgeBase SpaceType = "knowledge_base"
	SpaceTypePersonal      SpaceType = "personal"
)

// Defines values for TaskStatus.
const (
	TaskStatusComplete   TaskStatus = "complete"
	TaskStatusIncomplete TaskStatus = "incomplete"
)

// Defines values for VersionSortOrder.
const (
	MinusModifiedDate VersionSortOrder = "-modified-date"
	ModifiedDate      VersionSortOrder = "modified-date"
)

// Defines values for GetAttachmentsParamsStatus.
const (
	GetAttachmentsParamsStatusArchived GetAttachmentsParamsStatus = "archived"
	GetAttachmentsParamsStatusCurrent  GetAttachmentsParamsStatus = "current"
	GetAttachmentsParamsStatusTrashed  GetAttachmentsParamsStatus = "trashed"
)

// Defines values for GetAttachmentLabelsParamsPrefix.
const (
	GetAttachmentLabelsParamsPrefixGlobal GetAttachmentLabelsParamsPrefix = "global"
	GetAttachmentLabelsParamsPrefixMy     GetAttachmentLabelsParamsPrefix = "my"
	GetAttachmentLabelsParamsPrefixSystem GetAttachmentLabelsParamsPrefix = "system"
	GetAttachmentLabelsParamsPrefixTeam   GetAttachmentLabelsParamsPrefix = "team"
)

// Defines values for GetBlogPostsParamsStatus.
const (
	GetBlogPostsParamsStatusCurrent GetBlogPostsParamsStatus = "current"
	GetBlogPostsParamsStatusDeleted GetBlogPostsParamsStatus = "deleted"
	GetBlogPostsParamsStatusTrashed GetBlogPostsParamsStatus = "trashed"
)

// Defines values for GetBlogPostByIdParamsStatus.
const (
	GetBlogPostByIdParamsStatusCurrent    GetBlogPostByIdParamsStatus = "current"
	GetBlogPostByIdParamsStatusDeleted    GetBlogPostByIdParamsStatus = "deleted"
	GetBlogPostByIdParamsStatusDraft      GetBlogPostByIdParamsStatus = "draft"
	GetBlogPostByIdParamsStatusHistorical GetBlogPostByIdParamsStatus = "historical"
	GetBlogPostByIdParamsStatusTrashed    GetBlogPostByIdParamsStatus = "trashed"
)

// Defines values for GetBlogpostAttachmentsParamsStatus.
const (
	GetBlogpostAttachmentsParamsStatusArchived GetBlogpostAttachmentsParamsStatus = "archived"
	GetBlogpostAttachmentsParamsStatusCurrent  GetBlogpostAttachmentsParamsStatus = "current"
	GetBlogpostAttachmentsParamsStatusTrashed  GetBlogpostAttachmentsParamsStatus = "trashed"
)

// Defines values for GetBlogPostClassificationLevelParamsStatus.
const (
	GetBlogPostClassificationLevelParamsStatusArchived GetBlogPostClassificationLevelParamsStatus = "archived"
	GetBlogPostClassificationLevelParamsStatusCurrent  GetBlogPostClassificationLevelParamsStatus = "current"
	GetBlogPostClassificationLevelParamsStatusDraft    GetBlogPostClassificationLevelParamsStatus = "draft"
)

// Defines values for GetBlogPostFooterCommentsParamsStatus.
const (
	GetBlogPostFooterCommentsParamsStatusCurrent    GetBlogPostFooterCommentsParamsStatus = "current"
	GetBlogPostFooterCommentsParamsStatusDeleted    GetBlogPostFooterCommentsParamsStatus = "deleted"
	GetBlogPostFooterCommentsParamsStatusDraft      GetBlogPostFooterCommentsParamsStatus = "draft"
	GetBlogPostFooterCommentsParamsStatusHistorical GetBlogPostFooterCommentsParamsStatus = "historical"
	GetBlogPostFooterCommentsParamsStatusTrashed    GetBlogPostFooterCommentsParamsStatus = "trashed"
)

// Defines values for GetBlogPostInlineCommentsParamsStatus.
const (
	GetBlogPostInlineCommentsParamsStatusCurrent    GetBlogPostInlineCommentsParamsStatus = "current"
	GetBlogPostInlineCommentsParamsStatusDeleted    GetBlogPostInlineCommentsParamsStatus = "deleted"
	GetBlogPostInlineCommentsParamsStatusDraft      GetBlogPostInlineCommentsParamsStatus = "draft"
	GetBlogPostInlineCommentsParamsStatusHistorical GetBlogPostInlineCommentsParamsStatus = "historical"
	GetBlogPostInlineCommentsParamsStatusTrashed    GetBlogPostInlineCommentsParamsStatus = "trashed"
)

// Defines values for GetBlogPostInlineCommentsParamsResolutionStatus.
const (
	GetBlogPostInlineCommentsParamsResolutionStatusDangling GetBlogPostInlineCommentsParamsResolutionStatus = "dangling"
	GetBlogPostInlineCommentsParamsResolutionStatusOpen     GetBlogPostInlineCommentsParamsResolutionStatus = "open"
	GetBlogPostInlineCommentsParamsResolutionStatusReopened GetBlogPostInlineCommentsParamsResolutionStatus = "reopened"
	GetBlogPostInlineCommentsParamsResolutionStatusResolved GetBlogPostInlineCommentsParamsResolutionStatus = "resolved"
)

// Defines values for GetBlogPostLabelsParamsPrefix.
const (
	GetBlogPostLabelsParamsPrefixGlobal GetBlogPostLabelsParamsPrefix = "global"
	GetBlogPostLabelsParamsPrefixMy     GetBlogPostLabelsParamsPrefix = "my"
	GetBlogPostLabelsParamsPrefixSystem GetBlogPostLabelsParamsPrefix = "system"
	GetBlogPostLabelsParamsPrefixTeam   GetBlogPostLabelsParamsPrefix = "team"
)

// Defines values for GetCustomContentAttachmentsParamsStatus.
const (
	GetCustomContentAttachmentsParamsStatusArchived GetCustomContentAttachmentsParamsStatus = "archived"
	GetCustomContentAttachmentsParamsStatusCurrent  GetCustomContentAttachmentsParamsStatus = "current"
	GetCustomContentAttachmentsParamsStatusTrashed  GetCustomContentAttachmentsParamsStatus = "trashed"
)

// Defines values for GetCustomContentLabelsParamsPrefix.
const (
	GetCustomContentLabelsParamsPrefixGlobal GetCustomContentLabelsParamsPrefix = "global"
	GetCustomContentLabelsParamsPrefixMy     GetCustomContentLabelsParamsPrefix = "my"
	GetCustomContentLabelsParamsPrefixSystem GetCustomContentLabelsParamsPrefix = "system"
	GetCustomContentLabelsParamsPrefixTeam   GetCustomContentLabelsParamsPrefix = "team"
)

// Defines values for GetPagesParamsStatus.
const (
	GetPagesParamsStatusArchived GetPagesParamsStatus = "archived"
	GetPagesParamsStatusCurrent  GetPagesParamsStatus = "current"
	GetPagesParamsStatusDeleted  GetPagesParamsStatus = "deleted"
	GetPagesParamsStatusTrashed  GetPagesParamsStatus = "trashed"
)

// Defines values for GetPageByIdParamsStatus.
const (
	GetPageByIdParamsStatusArchived   GetPageByIdParamsStatus = "archived"
	GetPageByIdParamsStatusCurrent    GetPageByIdParamsStatus = "current"
	GetPageByIdParamsStatusDeleted    GetPageByIdParamsStatus = "deleted"
	GetPageByIdParamsStatusDraft      GetPageByIdParamsStatus = "draft"
	GetPageByIdParamsStatusHistorical GetPageByIdParamsStatus = "historical"
	GetPageByIdParamsStatusTrashed    GetPageByIdParamsStatus = "trashed"
)

// Defines values for GetPageAttachmentsParamsStatus.
const (
	GetPageAttachmentsParamsStatusArchived GetPageAttachmentsParamsStatus = "archived"
	GetPageAttachmentsParamsStatusCurrent  GetPageAttachmentsParamsStatus = "current"
	GetPageAttachmentsParamsStatusTrashed  GetPageAttachmentsParamsStatus = "trashed"
)

// Defines values for GetPageClassificationLevelParamsStatus.
const (
	GetPageClassificationLevelParamsStatusArchived GetPageClassificationLevelParamsStatus = "archived"
	GetPageClassificationLevelParamsStatusCurrent  GetPageClassificationLevelParamsStatus = "current"
	GetPageClassificationLevelParamsStatusDraft    GetPageClassificationLevelParamsStatus = "draft"
)

// Defines values for GetPageFooterCommentsParamsStatus.
const (
	GetPageFooterCommentsParamsStatusArchived   GetPageFooterCommentsParamsStatus = "archived"
	GetPageFooterCommentsParamsStatusCurrent    GetPageFooterCommentsParamsStatus = "current"
	GetPageFooterCommentsParamsStatusDeleted    GetPageFooterCommentsParamsStatus = "deleted"
	GetPageFooterCommentsParamsStatusDraft      GetPageFooterCommentsParamsStatus = "draft"
	GetPageFooterCommentsParamsStatusHistorical GetPageFooterCommentsParamsStatus = "historical"
	GetPageFooterCommentsParamsStatusTrashed    GetPageFooterCommentsParamsStatus = "trashed"
)

// Defines values for GetPageInlineCommentsParamsStatus.
const (
	GetPageInlineCommentsParamsStatusArchived   GetPageInlineCommentsParamsStatus = "archived"
	GetPageInlineCommentsParamsStatusCurrent    GetPageInlineCommentsParamsStatus = "current"
	GetPageInlineCommentsParamsStatusDeleted    GetPageInlineCommentsParamsStatus = "deleted"
	GetPageInlineCommentsParamsStatusDraft      GetPageInlineCommentsParamsStatus = "draft"
	GetPageInlineCommentsParamsStatusHistorical GetPageInlineCommentsParamsStatus = "historical"
	GetPageInlineCommentsParamsStatusTrashed    GetPageInlineCommentsParamsStatus = "trashed"
)

// Defines values for GetPageInlineCommentsParamsResolutionStatus.
const (
	Dangling GetPageInlineCommentsParamsResolutionStatus = "dangling"
	Open     GetPageInlineCommentsParamsResolutionStatus = "open"
	Reopened GetPageInlineCommentsParamsResolutionStatus = "reopened"
	Resolved GetPageInlineCommentsParamsResolutionStatus = "resolved"
)

// Defines values for GetPageLabelsParamsPrefix.
const (
	GetPageLabelsParamsPrefixGlobal GetPageLabelsParamsPrefix = "global"
	GetPageLabelsParamsPrefixMy     GetPageLabelsParamsPrefix = "my"
	GetPageLabelsParamsPrefixSystem GetPageLabelsParamsPrefix = "system"
	GetPageLabelsParamsPrefixTeam   GetPageLabelsParamsPrefix = "team"
)

// Defines values for GetSpacesParamsType.
const (
	GetSpacesParamsTypeCollaboration GetSpacesParamsType = "collaboration"
	GetSpacesParamsTypeGlobal        GetSpacesParamsType = "global"
	GetSpacesParamsTypeKnowledgeBase GetSpacesParamsType = "knowledge_base"
	GetSpacesParamsTypePersonal      GetSpacesParamsType = "personal"
)

// Defines values for GetSpacesParamsStatus.
const (
	GetSpacesParamsStatusArchived GetSpacesParamsStatus = "archived"
	GetSpacesParamsStatusCurrent  GetSpacesParamsStatus = "current"
)

// Defines values for GetBlogPostsInSpaceParamsStatus.
const (
	GetBlogPostsInSpaceParamsStatusCurrent GetBlogPostsInSpaceParamsStatus = "current"
	GetBlogPostsInSpaceParamsStatusDeleted GetBlogPostsInSpaceParamsStatus = "deleted"
	GetBlogPostsInSpaceParamsStatusTrashed GetBlogPostsInSpaceParamsStatus = "trashed"
)

// Defines values for GetSpaceContentLabelsParamsPrefix.
const (
	GetSpaceContentLabelsParamsPrefixMy   GetSpaceContentLabelsParamsPrefix = "my"
	GetSpaceContentLabelsParamsPrefixTeam GetSpaceContentLabelsParamsPrefix = "team"
)

// Defines values for GetSpaceLabelsParamsPrefix.
const (
	GetSpaceLabelsParamsPrefixMy   GetSpaceLabelsParamsPrefix = "my"
	GetSpaceLabelsParamsPrefixTeam GetSpaceLabelsParamsPrefix = "team"
)

// Defines values for GetPagesInSpaceParamsDepth.
const (
	All  GetPagesInSpaceParamsDepth = "all"
	Root GetPagesInSpaceParamsDepth = "root"
)

// Defines values for GetPagesInSpaceParamsStatus.
const (
	Archived GetPagesInSpaceParamsStatus = "archived"
	Current  GetPagesInSpaceParamsStatus = "current"
	Deleted  GetPagesInSpaceParamsStatus = "deleted"
	Trashed  GetPagesInSpaceParamsStatus = "trashed"
)

// Defines values for GetTasksParamsStatus.
const (
	GetTasksParamsStatusComplete   GetTasksParamsStatus = "complete"
	GetTasksParamsStatusIncomplete GetTasksParamsStatus = "incomplete"
)

// AbstractPageLinks defines model for AbstractPageLinks.
type AbstractPageLinks struct {
	// Editui Edit UI link of the content.
	Editui *string `json:"editui,omitempty"`

	// Tinyui Web UI link of the content.
	Tinyui *string `json:"tinyui,omitempty"`

	// Webui Web UI link of the content.
	Webui *string `json:"webui,omitempty"`
}

// AccountStatus The account status of the user.
type AccountStatus string

// AccountType The account type of the user.
type AccountType string

// Ancestor defines model for Ancestor.
type Ancestor struct {
	// Id ID of the ancestor
	Id *string `json:"id,omitempty"`

	// Type The type of ancestor.
	Type *AncestorType `json:"type,omitempty"`
}

// AncestorType The type of ancestor.
type AncestorType string

// AttachmentBulk defines model for AttachmentBulk.
type AttachmentBulk struct {
	Links *AttachmentLinks `json:"_links,omitempty"`

	// BlogPostId ID of the containing blog post.
	//
	// Note: This is only returned if the attachment has a container that is a blog post.
	BlogPostId *string `json:"blogPostId,omitempty"`

	// Comment Comment for the attachment.
	Comment *string `json:"comment,omitempty"`

	// CreatedAt Date and time when the attachment was created. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// CustomContentId ID of the containing custom content.
	//
	// Note: This is only returned if the attachment has a container that is custom content.
	CustomContentId *string `json:"customContentId,omitempty"`

	// DownloadLink Download link of the attachment.
	DownloadLink *string `json:"downloadLink,omitempty"`

	// FileId File ID of the attachment. This is the ID referenced in `atlas_doc_format` bodies and is distinct from the attachment ID.
	FileId *string `json:"fileId,omitempty"`

	// FileSize File size of the attachment.
	FileSize *int64 `json:"fileSize,omitempty"`

	// Id ID of the attachment.
	Id *string `json:"id,omitempty"`

	// MediaType Media Type for the attachment.
	MediaType *string `json:"mediaType,omitempty"`

	// MediaTypeDescription Media Type description for the attachment.
	MediaTypeDescription *string `json:"mediaTypeDescription,omitempty"`

	// PageId ID of the containing page.
	//
	// Note: This is only returned if the attachment has a container that is a page.
	PageId *string `json:"pageId,omitempty"`

	// Status The status of the content.
	Status *ContentStatus `json:"status,omitempty"`

	// Title Title of the comment.
	Title   *string  `json:"title,omitempty"`
	Version *Version `json:"version,omitempty"`

	// WebuiLink WebUI link of the attachment.
	WebuiLink *string `json:"webuiLink,omitempty"`
}

// AttachmentCommentModel defines model for AttachmentCommentModel.
type AttachmentCommentModel struct {
	Links *CommentLinks `json:"_links,omitempty"`

	// AttachmentId ID of the attachment containing the comment.
	AttachmentId *string `json:"attachmentId,omitempty"`

	// Body Contains fields for each representation type requested.
	Body *BodySingle `json:"body,omitempty"`

	// Id ID of the comment.
	Id *string `json:"id,omitempty"`

	// Status The status of the content.
	Status *ContentStatus `json:"status,omitempty"`

	// Title Title of the comment.
	Title   *string  `json:"title,omitempty"`
	Version *Version `json:"version,omitempty"`
}

// AttachmentLinks defines model for AttachmentLinks.
type AttachmentLinks struct {
	// Download Download link of the content.
	Download *string `json:"download,omitempty"`

	// Webui Web UI link of the content.
	Webui *string `json:"webui,omitempty"`
}

// AttachmentSingle defines model for AttachmentSingle.
type AttachmentSingle struct {
	Links *AttachmentLinks `json:"_links,omitempty"`

	// BlogPostId ID of the containing blog post.
	//
	// Note: This is only returned if the attachment has a container that is a blog post.
	BlogPostId *string `json:"blogPostId,omitempty"`

	// Comment Comment for the attachment.
	Comment *string `json:"comment,omitempty"`

	// CreatedAt Date and time when the attachment was created. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// CustomContentId ID of the containing custom content.
	//
	// Note: This is only returned if the attachment has a container that is custom content.
	CustomContentId *string `json:"customContentId,omitempty"`

	// DownloadLink Download link of the attachment.
	DownloadLink *string `json:"downloadLink,omitempty"`

	// FileId File ID of the attachment. This is the ID referenced in `atlas_doc_format` bodies and is distinct from the attachment ID.
	FileId *string `json:"fileId,omitempty"`

	// FileSize File size of the attachment.
	FileSize *int64 `json:"fileSize,omitempty"`

	// Id ID of the attachment.
	Id     *string `json:"id,omitempty"`
	Labels *struct {
		Links   *OptionalFieldLinks `json:"_links,omitempty"`
		Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
		Results *[]Label            `json:"results,omitempty"`
	} `json:"labels,omitempty"`

	// MediaType Media Type for the attachment.
	MediaType *string `json:"mediaType,omitempty"`

	// MediaTypeDescription Media Type description for the attachment.
	MediaTypeDescription *string `json:"mediaTypeDescription,omitempty"`
	Operations           *struct {
		Links   *OptionalFieldLinks `json:"_links,omitempty"`
		Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
		Results *[]Operation        `json:"results,omitempty"`
	} `json:"operations,omitempty"`

	// PageId ID of the containing page.
	//
	// Note: This is only returned if the attachment has a container that is a page.
	PageId     *string `json:"pageId,omitempty"`
	Properties *struct {
		Links   *OptionalFieldLinks `json:"_links,omitempty"`
		Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
		Results *[]ContentProperty  `json:"results,omitempty"`
	} `json:"properties,omitempty"`

	// Status The status of the content.
	Status *ContentStatus `json:"status,omitempty"`

	// Title Title of the comment.
	Title    *string  `json:"title,omitempty"`
	Version  *Version `json:"version,omitempty"`
	Versions *struct {
		Links   *OptionalFieldLinks `json:"_links,omitempty"`
		Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
		Results *[]Version          `json:"results,omitempty"`
	} `json:"versions,omitempty"`

	// WebuiLink WebUI link of the attachment.
	WebuiLink *string `json:"webuiLink,omitempty"`
}

// AttachmentSortOrder The sort fields for attachments. The default sort direction is ascending. To sort in descending order, append a `-` character before the sort field. For example, `fieldName` or `-fieldName`.
type AttachmentSortOrder string

// AttachmentVersion defines model for AttachmentVersion.
type AttachmentVersion struct {
	Attachment *VersionedEntity `json:"attachment,omitempty"`

	// AuthorId The account ID of the user who created this version.
	AuthorId *string `json:"authorId,omitempty"`

	// CreatedAt Date and time when the version was created. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Message Message associated with the current version.
	Message *string `json:"message,omitempty"`

	// MinorEdit Describes if this version is a minor version. Email notifications and activity stream updates are not created for minor versions.
	MinorEdit *bool `json:"minorEdit,omitempty"`

	// Number The version number.
	Number *int32 `json:"number,omitempty"`
}

// BlogPostBodyWrite defines model for BlogPostBodyWrite.
type BlogPostBodyWrite struct {
	// Representation Type of content representation used for the value field.
	Representation *BlogPostBodyWriteRepresentation `json:"representation,omitempty"`

	// Value Body of the blog post, in the format found in the representation field.
	Value *string `json:"value,omitempty"`
}

// BlogPostBodyWriteRepresentation Type of content representation used for the value field.
type BlogPostBodyWriteRepresentation string

// BlogPostBulk defines model for BlogPostBulk.
type BlogPostBulk struct {
	Links *AbstractPageLinks `json:"_links,omitempty"`

	// AuthorId The account ID of the user who created this blog post originally.
	AuthorId *string `json:"authorId,omitempty"`

	// Body Contains fields for each representation type requested.
	Body *BodyBulk `json:"body,omitempty"`

	// CreatedAt Date and time when the blog post was created. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Id ID of the blog post.
	Id *string `json:"id,omitempty"`

	// SpaceId ID of the space the blog post is in.
	SpaceId *string `json:"spaceId,omitempty"`

	// Status The status of the content.
	Status *BlogPostContentStatus `json:"status,omitempty"`

	// Title Title of the blog post.
	Title   *string  `json:"title,omitempty"`
	Version *Version `json:"version,omitempty"`
}

// BlogPostCommentModel defines model for BlogPostCommentModel.
type BlogPostCommentModel struct {
	Links *CommentLinks `json:"_links,omitempty"`

	// BlogPostId ID of the blog post the comment is in.
	BlogPostId *string `json:"blogPostId,omitempty"`

	// Body Contains fields for each representation type requested.
	Body *BodyBulk `json:"body,omitempty"`

	// Id ID of the comment.
	Id *string `json:"id,omitempty"`

	// Status The status of the content.
	Status *ContentStatus `json:"status,omitempty"`

	// Title Title of the comment.
	Title   *string  `json:"title,omitempty"`
	Version *Version `json:"version,omitempty"`
}

// BlogPostContentStatus The status of the content.
type BlogPostContentStatus string

// BlogPostInlineCommentModel defines model for BlogPostInlineCommentModel.
type BlogPostInlineCommentModel struct {
	Links *CommentLinks `json:"_links,omitempty"`

	// BlogPostId ID of the blog post the comment is in.
	BlogPostId *string `json:"blogPostId,omitempty"`

	// Body Contains fields for each representation type requested.
	Body *BodyBulk `json:"body,omitempty"`

	// Id ID of the comment.
	Id         *string                  `json:"id,omitempty"`
	Properties *InlineCommentProperties `json:"properties,omitempty"`

	// ResolutionStatus Inline comment resolution status
	ResolutionStatus *InlineCommentResolutionStatus `json:"resolutionStatus,omitempty"`

	// Status The status of the content.
	Status *ContentStatus `json:"status,omitempty"`

	// Title Title of the comment.
	Title   *string  `json:"title,omitempty"`
	Version *Version `json:"version,omitempty"`
}

// BlogPostNestedBodyWrite Body of the blog post. Only one body format should be specified as the property
// for this object, e.g. `storage`.
type BlogPostNestedBodyWrite struct {
	AtlasDocFormat *BlogPostBodyWrite `json:"atlas_doc_format,omitempty"`
	Storage        *BlogPostBodyWrite `json:"storage,omitempty"`
	Wiki           *BlogPostBodyWrite `json:"wiki,omitempty"`
}

// BlogPostSingle defines model for BlogPostSingle.
type BlogPostSingle struct {
	Links *AbstractPageLinks `json:"_links,omitempty"`

	// AuthorId The account ID of the user who created this blog post originally.
	AuthorId *string `json:"authorId,omitempty"`

	// Body Contains fields for each representation type requested.
	Body *BodySingle `json:"body,omitempty"`

	// CreatedAt Date and time when the blog post was created. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Id ID of the blog post.
	Id *string `json:"id,omitempty"`

	// IsFavoritedByCurrentUser Whether the blog post has been favorited by the current user.
	IsFavoritedByCurrentUser *bool `json:"isFavoritedByCurrentUser,omitempty"`
	Labels                   *struct {
		Links   *OptionalFieldLinks `json:"_links,omitempty"`
		Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
		Results *[]Label            `json:"results,omitempty"`
	} `json:"labels,omitempty"`
	Likes *struct {
		Links   *OptionalFieldLinks `json:"_links,omitempty"`
		Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
		Results *[]Like             `json:"results,omitempty"`
	} `json:"likes,omitempty"`
	Operations *struct {
		Links   *OptionalFieldLinks `json:"_links,omitempty"`
		Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
		Results *[]Operation        `json:"results,omitempty"`
	} `json:"operations,omitempty"`
	Properties *struct {
		Links   *OptionalFieldLinks `json:"_links,omitempty"`
		Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
		Results *[]ContentProperty  `json:"results,omitempty"`
	} `json:"properties,omitempty"`

	// SpaceId ID of the space the blog post is in.
	SpaceId *string `json:"spaceId,omitempty"`

	// Status The status of the content.
	Status *BlogPostContentStatus `json:"status,omitempty"`

	// Title Title of the blog post.
	Title    *string  `json:"title,omitempty"`
	Version  *Version `json:"version,omitempty"`
	Versions *struct {
		Links   *OptionalFieldLinks `json:"_links,omitempty"`
		Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
		Results *[]Version          `json:"results,omitempty"`
	} `json:"versions,omitempty"`
}

// BlogPostSortOrder The sort fields for blog posts. The default sort direction is ascending. To sort in descending order, append a `-` character before the sort field. For example, `fieldName` or `-fieldName`.
type BlogPostSortOrder string

// BlogPostVersion defines model for BlogPostVersion.
type BlogPostVersion struct {
	// AuthorId The account ID of the user who created this version.
	AuthorId *string          `json:"authorId,omitempty"`
	Blogpost *VersionedEntity `json:"blogpost,omitempty"`

	// CreatedAt Date and time when the version was created. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Message Message associated with the current version.
	Message *string `json:"message,omitempty"`

	// MinorEdit Describes if this version is a minor version. Email notifications and activity stream updates are not created for minor versions.
	MinorEdit *bool `json:"minorEdit,omitempty"`

	// Number The version number.
	Number *int32 `json:"number,omitempty"`
}

// BodyBulk Contains fields for each representation type requested.
type BodyBulk struct {
	AtlasDocFormat *BodyType `json:"atlas_doc_format,omitempty"`
	Storage        *BodyType `json:"storage,omitempty"`
}

// BodySingle Contains fields for each representation type requested.
type BodySingle struct {
	AtlasDocFormat *BodyType `json:"atlas_doc_format,omitempty"`
	Storage        *BodyType `json:"storage,omitempty"`
	View           *BodyType `json:"view,omitempty"`
}

// BodyType defines model for BodyType.
type BodyType struct {
	// Representation Type of content representation used for the value field.
	Representation *string `json:"representation,omitempty"`

	// Value Body of the content, in the format found in the representation field.
	Value *string `json:"value,omitempty"`
}

// ChildCustomContent defines model for ChildCustomContent.
type ChildCustomContent struct {
	// Id ID of the child custom content.
	Id *string `json:"id,omitempty"`

	// SpaceId ID of the space the custom content is in.
	SpaceId *string `json:"spaceId,omitempty"`

	// Status The status of the content.
	Status *OnlyArchivedAndCurrentContentStatus `json:"status,omitempty"`

	// Title Title of the custom content.
	Title *string `json:"title,omitempty"`

	// Type Custom content type.
	Type *string `json:"type,omitempty"`
}

// ChildCustomContentSortOrder The sort fields for child custom content. The default sort direction is ascending by id. To sort in descending order, append a `-` character before the sort field. For example, `fieldName` or `-fieldName`.
type ChildCustomContentSortOrder string

// ChildPage defines model for ChildPage.
type ChildPage struct {
	// ChildPosition Position of child page within the given parent page tree.
	ChildPosition *int32 `json:"childPosition"`

	// Id ID of the page.
	Id *string `json:"id,omitempty"`

	// SpaceId ID of the space the page is in.
	SpaceId *string `json:"spaceId,omitempty"`

	// Status The status of the content.
	Status *OnlyArchivedAndCurrentContentStatus `json:"status,omitempty"`

	// Title Title of the page.
	Title *string `json:"title,omitempty"`
}

// ChildPageSortOrder The sort fields for child pages. The default sort direction is ascending by child-position. To sort in descending order, append a `-` character before the sort field. For example, `fieldName` or `-fieldName`.
type ChildPageSortOrder string

// ChildrenCommentModel defines model for ChildrenCommentModel.
type ChildrenCommentModel struct {
	Links *CommentLinks `json:"_links,omitempty"`

	// Body Contains fields for each representation type requested.
	Body *BodyBulk `json:"body,omitempty"`

	// Id ID of the comment.
	Id *string `json:"id,omitempty"`

	// ParentCommentId ID of the parent comment the child comment is in.
	ParentCommentId *string `json:"parentCommentId,omitempty"`

	// Status The status of the content.
	Status *ContentStatus `json:"status,omitempty"`

	// Title Title of the comment.
	Title   *string  `json:"title,omitempty"`
	Version *Version `json:"version,omitempty"`
}

// ClassificationLevel A unit of [data classification](https://support.atlassian.com/security-and-access-policies/docs/what-is-data-classification/) defined by an organiation.
// A classification level may be associated with specific storage and handling requirements or expectations.
type ClassificationLevel struct {
	Color *ClassificationLevelColor `json:"color,omitempty"`

	// Description The description of the classification level object.
	Description *string `json:"description,omitempty"`

	// Guideline The guideline of the classification level object.
	Guideline *string `json:"guideline,omitempty"`

	// Id The ID of the classification level.
	Id *string `json:"id,omitempty"`

	// Name The name of the classification level object.
	Name *string `json:"name,omitempty"`

	// Order The order of the classification level object.
	Order  *float32                   `json:"order,omitempty"`
	Status *ClassificationLevelStatus `json:"status,omitempty"`
}

// ClassificationLevelColor defines model for ClassificationLevelColor.
type ClassificationLevelColor string

// ClassificationLevelStatus defines model for ClassificationLevelStatus.
type ClassificationLevelStatus string

// CommentBodyWrite defines model for CommentBodyWrite.
type CommentBodyWrite struct {
	// Representation Type of content representation used for the value field.
	Representation *CommentBodyWriteRepresentation `json:"representation,omitempty"`

	// Value Body of the comment, in the format found in the representation field.
	Value *string `json:"value,omitempty"`
}

// CommentBodyWriteRepresentation Type of content representation used for the value field.
type CommentBodyWriteRepresentation string

// CommentLinks defines model for CommentLinks.
type CommentLinks struct {
	// Webui Web UI link of the content.
	Webui *string `json:"webui,omitempty"`
}

// CommentNestedBodyWrite Body of the comment. Only one body format should be specified as the property
// for this object, e.g. `storage`.
type CommentNestedBodyWrite struct {
	AtlasDocFormat *CommentBodyWrite `json:"atlas_doc_format,omitempty"`
	Storage        *CommentBodyWrite `json:"storage,omitempty"`
	Wiki           *CommentBodyWrite `json:"wiki,omitempty"`
}

// CommentSortOrder The sort fields for comments. The default sort direction is ascending. To sort in descending order, append a `-` character before the sort field. For example, `fieldName` or `-fieldName`.
type CommentSortOrder string

// CommentVersion defines model for CommentVersion.
type CommentVersion struct {
	// AuthorId The account ID of the user who created this version.
	AuthorId *string          `json:"authorId,omitempty"`
	Comment  *VersionedEntity `json:"comment,omitempty"`

	// CreatedAt Date and time when the version was created. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Message Message associated with the current version.
	Message *string `json:"message,omitempty"`

	// MinorEdit Describes if this version is a minor version. Email notifications and activity stream updates are not created for minor versions.
	MinorEdit *bool `json:"minorEdit,omitempty"`

	// Number The version number.
	Number *int32 `json:"number,omitempty"`
}

// ContentIdToContentTypeResponse defines model for ContentIdToContentTypeResponse.
type ContentIdToContentTypeResponse struct {
	// Results JSON object containing all requested content ids as keys and their associated content types as the values.
	// Duplicate content ids in the request will be returned under a single key in the response. For built-in content
	// types, the enumerations are as specified. Custom content ids will be mapped to their associated type.
	Results *map[string]ContentIdToContentTypeResponse_Results_AdditionalProperties `json:"results,omitempty"`
}

// ContentIdToContentTypeResponseResults0 Built in content types
type ContentIdToContentTypeResponseResults0 string

// ContentIdToContentTypeResponseResults1 Custom content types
type ContentIdToContentTypeResponseResults1 = string

// ContentIdToContentTypeResponse_Results_AdditionalProperties defines model for ContentIdToContentTypeResponse.results.AdditionalProperties.
type ContentIdToContentTypeResponse_Results_AdditionalProperties struct {
	union json.RawMessage
}

// ContentProperty defines model for ContentProperty.
type ContentProperty struct {
	// Id ID of the property
	Id *string `json:"id,omitempty"`

	// Key Key of the property
	Key *string `json:"key,omitempty"`

	// Value Value of the property. Must be a valid JSON value.
	Value   *interface{} `json:"value,omitempty"`
	Version *Version     `json:"version,omitempty"`
}

// ContentPropertyCreateRequest defines model for ContentPropertyCreateRequest.
type ContentPropertyCreateRequest struct {
	// Key Key of the content property
	Key *string `json:"key,omitempty"`

	// Value Value of the content property.
	Value *interface{} `json:"value,omitempty"`
}

// ContentPropertySortOrder The sort fields for content properties. The default sort direction is ascending. To sort in descending order, append a `-` character before the sort field. For example, `fieldName` or `-fieldName`.
type ContentPropertySortOrder string

// ContentPropertyUpdateRequest defines model for ContentPropertyUpdateRequest.
type ContentPropertyUpdateRequest struct {
	// Key Key of the content property
	Key *string `json:"key,omitempty"`

	// Value Value of the content property.
	Value *interface{} `json:"value,omitempty"`

	// Version New version number and associated message
	Version *struct {
		// Message Message to be associated with the new version.
		Message *string `json:"message,omitempty"`

		// Number Version number of the new version. Should be 1 more than the current version number.
		Number *int32 `json:"number,omitempty"`
	} `json:"version,omitempty"`
}

// ContentStatus The status of the content.
type ContentStatus string

// CreateFooterCommentModel defines model for CreateFooterCommentModel.
type CreateFooterCommentModel struct {
	// AttachmentId ID of the attachment, if intending to create a comment against an attachment.
	AttachmentId *string `json:"attachmentId,omitempty"`

	// BlogPostId ID of the containing blog post, if intending to create a top level footer comment. Do not provide if creating a reply.
	BlogPostId *string           `json:"blogPostId,omitempty"`
	Body       *CommentBodyWrite `json:"body,omitempty"`

	// CustomContentId ID of the custom content, if intending to create a comment against a custom content.
	CustomContentId *string `json:"customContentId,omitempty"`

	// PageId ID of the containing page, if intending to create a top level footer comment. Do not provide if creating a reply.
	PageId *string `json:"pageId,omitempty"`

	// ParentCommentId ID of the parent comment, if intending to create a reply. Do not provide if creating a top level comment.
	ParentCommentId *string `json:"parentCommentId,omitempty"`
}

// CreateInlineCommentModel defines model for CreateInlineCommentModel.
type CreateInlineCommentModel struct {
	// BlogPostId ID of the containing blog post, if intending to create a top level footer comment. Do not provide if creating a reply.
	BlogPostId *string           `json:"blogPostId,omitempty"`
	Body       *CommentBodyWrite `json:"body,omitempty"`

	// InlineCommentProperties Object describing the text to highlight on the page/blog post. Only applicable for top level inline comments (not replies) and required in that case.
	InlineCommentProperties *struct {
		// TextSelection The text to highlight
		TextSelection *string `json:"textSelection,omitempty"`

		// TextSelectionMatchCount The number of matches for the selected text on the page (should be strictly greater than textSelectionMatchIndex)
		TextSelectionMatchCount *int `json:"textSelectionMatchCount,omitempty"`

		// TextSelectionMatchIndex The match index to highlight. This is zero-based. E.g. if you have 3 occurrences of "hello world" on a page
		// and you want to highlight the second occurrence, you should pass 1 for textSelectionMatchIndex and 3 for textSelectionMatchCount.
		TextSelectionMatchIndex *int `json:"textSelectionMatchIndex,omitempty"`
	} `json:"inlineCommentProperties,omitempty"`

	// PageId ID of the containing page, if intending to create a top level footer comment. Do not provide if creating a reply.
	PageId *string `json:"pageId,omitempty"`

	// ParentCommentId ID of the parent comment, if intending to create a reply. Do not provide if creating a top level comment.
	ParentCommentId *string `json:"parentCommentId,omitempty"`
}

// CustomContentBodyBulk Contains fields for each representation type requested.
type CustomContentBodyBulk struct {
	AtlasDocFormat *BodyType `json:"atlas_doc_format,omitempty"`
	Raw            *BodyType `json:"raw,omitempty"`
	Storage        *BodyType `json:"storage,omitempty"`
}

// CustomContentBodyRepresentation The formats a custom content body can be represented as. A subset of BodyRepresentation.
type CustomContentBodyRepresentation string

// CustomContentBodyRepresentationSingle The formats a custom content body can be represented as. A subset of BodyRepresentation.
type CustomContentBodyRepresentationSingle string

// CustomContentBodySingle Contains fields for each representation type requested.
type CustomContentBodySingle struct {
	AtlasDocFormat *BodyType `json:"atlas_doc_format,omitempty"`
	Raw            *BodyType `json:"raw,omitempty"`
	Storage        *BodyType `json:"storage,omitempty"`
	View           *BodyType `json:"view,omitempty"`
}

// CustomContentBodyWrite defines model for CustomContentBodyWrite.
type CustomContentBodyWrite struct {
	// Representation Type of content representation used for the value field.
	Representation *CustomContentBodyWriteRepresentation `json:"representation,omitempty"`

	// Value Body of the custom content, in the format found in the representation field.
	Value *string `json:"value,omitempty"`
}

// CustomContentBodyWriteRepresentation Type of content representation used for the value field.
type CustomContentBodyWriteRepresentation string

// CustomContentBulk defines model for CustomContentBulk.
type CustomContentBulk struct {
	Links *CustomContentLinks `json:"_links,omitempty"`

	// AuthorId The account ID of the user who created this custom content originally.
	AuthorId *string `json:"authorId,omitempty"`

	// BlogPostId ID of the containing blog post.
	//
	// Note: This is only returned if the custom content has a container that is a blog post.
	BlogPostId *string `json:"blogPostId,omitempty"`

	// Body Contains fields for each representation type requested.
	Body *CustomContentBodyBulk `json:"body,omitempty"`

	// CreatedAt Date and time when the custom content was created. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// CustomContentId ID of the containing custom content.
	//
	// Note: This is only returned if the custom content has a container that is custom content.
	CustomContentId *string `json:"customContentId,omitempty"`

	// Id ID of the custom content.
	Id *string `json:"id,omitempty"`

	// PageId ID of the containing page.
	//
	// Note: This is only returned if the custom content has a container that is a page.
	PageId *string `json:"pageId,omitempty"`

	// SpaceId ID of the space the custom content is in.
	//
	// Note: This is always returned, regardless of if the custom content has a container that is a space.
	SpaceId *string `json:"spaceId,omitempty"`

	// Status The status of the content.
	Status *ContentStatus `json:"status,omitempty"`

	// Title Title of the custom content.
	Title *string `json:"title,omitempty"`

	// Type The type of custom content.
	Type    *string  `json:"type,omitempty"`
	Version *Version `json:"version,omitempty"`
}

// CustomContentCommentModel defines model for CustomContentCommentModel.
type CustomContentCommentModel struct {
	Links *CommentLinks `json:"_links,omitempty"`

	// Body Contains fields for each representation type requested.
	Body *BodySingle `json:"body,omitempty"`

	// CustomContentId ID of the custom content containing the comment.
	CustomContentId *string `json:"customContentId,omitempty"`

	// Id ID of the comment.
	Id *string `json:"id,omitempty"`

	// Status The status of the content.
	Status *ContentStatus `json:"status,omitempty"`

	// Title Title of the comment.
	Title   *string  `json:"title,omitempty"`
	Version *Version `json:"version,omitempty"`
}

// CustomContentLinks defines model for CustomContentLinks.
type CustomContentLinks struct {
	// Webui Web UI link of the content.
	Webui *string `json:"webui,omitempty"`
}

// CustomContentNestedBodyWrite Body of the custom content. Only one body format should be specified as the property
// for this object, e.g. `storage`.
type CustomContentNestedBodyWrite struct {
	AtlasDocFormat *CustomContentBodyWrite `json:"atlas_doc_format,omitempty"`
	Raw            *CustomContentBodyWrite `json:"raw,omitempty"`
	Storage        *CustomContentBodyWrite `json:"storage,omitempty"`
}

// CustomContentSingle defines model for CustomContentSingle.
type CustomContentSingle struct {
	Links *CustomContentLinks `json:"_links,omitempty"`

	// AuthorId The account ID of the user who created this custom content originally.
	AuthorId *string `json:"authorId,omitempty"`

	// BlogPostId ID of the containing blog post.
	//
	// Note: This is only returned if the custom content has a container that is a blog post.
	BlogPostId *string `json:"blogPostId,omitempty"`

	// Body Contains fields for each representation type requested.
	Body *CustomContentBodySingle `json:"body,omitempty"`

	// CreatedAt Date and time when the custom content was created. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// CustomContentId ID of the containing custom content.
	//
	// Note: This is only returned if the custom content has a container that is custom content.
	CustomContentId *string `json:"customContentId,omitempty"`

	// Id ID of the custom content.
	Id     *string `json:"id,omitempty"`
	Labels *struct {
		Links   *OptionalFieldLinks `json:"_links,omitempty"`
		Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
		Results *[]Label            `json:"results,omitempty"`
	} `json:"labels,omitempty"`
	Operations *struct {
		Links   *OptionalFieldLinks `json:"_links,omitempty"`
		Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
		Results *[]Operation        `json:"results,omitempty"`
	} `json:"operations,omitempty"`

	// PageId ID of the containing page.
	//
	// Note: This is only returned if the custom content has a container that is a page.
	PageId     *string `json:"pageId,omitempty"`
	Properties *struct {
		Links   *OptionalFieldLinks `json:"_links,omitempty"`
		Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
		Results *[]ContentProperty  `json:"results,omitempty"`
	} `json:"properties,omitempty"`

	// SpaceId ID of the space the custom content is in.
	//
	// Note: This is always returned, regardless of if the custom content has a container that is a space.
	SpaceId *string `json:"spaceId,omitempty"`

	// Status The status of the content.
	Status *ContentStatus `json:"status,omitempty"`

	// Title Title of the custom content.
	Title *string `json:"title,omitempty"`

	// Type The type of custom content.
	Type     *string  `json:"type,omitempty"`
	Version  *Version `json:"version,omitempty"`
	Versions *struct {
		Links   *OptionalFieldLinks `json:"_links,omitempty"`
		Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
		Results *[]Version          `json:"results,omitempty"`
	} `json:"versions,omitempty"`
}

// CustomContentSortOrder The sort fields for custom content. The default sort direction is ascending. To sort in descending order, append a `-` character before the sort field. For example, `fieldName` or `-fieldName`.
type CustomContentSortOrder string

// CustomContentVersion defines model for CustomContentVersion.
type CustomContentVersion struct {
	// AuthorId The account ID of the user who created this version.
	AuthorId *string `json:"authorId,omitempty"`

	// CreatedAt Date and time when the version was created. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
	CreatedAt *time.Time       `json:"createdAt,omitempty"`
	Custom    *VersionedEntity `json:"custom,omitempty"`

	// Message Message associated with the current version.
	Message *string `json:"message,omitempty"`

	// MinorEdit Describes if this version is a minor version. Email notifications and activity stream updates are not created for minor versions.
	MinorEdit *bool `json:"minorEdit,omitempty"`

	// Number The version number.
	Number *int32 `json:"number,omitempty"`
}

// DataPolicyMetadata Details about data policies.
type DataPolicyMetadata struct {
	// AnyContentBlocked Whether the workspace contains any content blocked for (inaccessible to) the requesting client application.
	AnyContentBlocked *bool `json:"anyContentBlocked,omitempty"`
}

// DataPolicySpace defines model for DataPolicySpace.
type DataPolicySpace struct {
	Links      *SpaceLinks `json:"_links,omitempty"`
	DataPolicy *struct {
		// AnyContentBlocked Whether the space contains any content blocked for (inaccessible to) the requesting client application.
		AnyContentBlocked *bool `json:"anyContentBlocked,omitempty"`
	} `json:"dataPolicy,omitempty"`

	// Description Contains fields for each representation type requested.
	Description *SpaceDescription `json:"description,omitempty"`

	// Icon The icon of the space
	Icon *SpaceIcon `json:"icon,omitempty"`

	// Id ID of the space.
	Id *string `json:"id,omitempty"`

	// Key Key of the space.
	Key *string `json:"key,omitempty"`

	// Name Name of the space.
	Name *string `json:"name,omitempty"`
}

// DatabaseLinks defines model for DatabaseLinks.
type DatabaseLinks struct {
	// Webui Web UI link of the content.
	Webui *string `json:"webui,omitempty"`
}

// DatabaseSingle defines model for DatabaseSingle.
type DatabaseSingle struct {
	Links *DatabaseLinks `json:"_links,omitempty"`

	// AuthorId The account ID of the user who created this database originally.
	AuthorId *string `json:"authorId,omitempty"`

	// CreatedAt Date and time when the database was created. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Id ID of the database.
	Id *string `json:"id,omitempty"`

	// OwnerId The account ID of the user who owns this database.
	OwnerId *string `json:"ownerId,omitempty"`

	// ParentId ID of the parent content, or null if there is no parent content.
	ParentId *string `json:"parentId,omitempty"`

	// ParentType Content type of the parent, or null if there is no parent.
	ParentType *ParentContentType `json:"parentType,omitempty"`

	// Position Position of the database within the given parent page tree.
	Position *int32 `json:"position"`

	// Status The status of the content.
	Status *ContentStatus `json:"status,omitempty"`

	// Title Title of the database.
	Title *string `json:"title,omitempty"`

	// Type The content type of the object.
	Type    *string  `json:"type,omitempty"`
	Version *Version `json:"version,omitempty"`
}

// DetailedVersion defines model for DetailedVersion.
type DetailedVersion struct {
	// AuthorId The account ID of the user who created this version.
	AuthorId *string `json:"authorId,omitempty"`

	// Collaborators The account IDs of users that collaborated on this version.
	Collaborators *[]string `json:"collaborators,omitempty"`

	// ContentTypeModified Describes if the content type is modified in this version (e.g. page to blog)
	ContentTypeModified *bool `json:"contentTypeModified,omitempty"`

	// CreatedAt Date and time when the version was created. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Message Message associated with the current version.
	Message *string `json:"message,omitempty"`

	// MinorEdit Describes if this version is a minor version. Email notifications and activity stream updates are not created for minor versions.
	MinorEdit *bool `json:"minorEdit,omitempty"`

	// NextVersion The version number of the version after this current content update.
	NextVersion *int32 `json:"nextVersion,omitempty"`

	// Number The current version number.
	Number *int32 `json:"number,omitempty"`

	// PrevVersion The version number of the version prior to this current content update.
	PrevVersion *int32 `json:"prevVersion,omitempty"`
}

// FolderLinks defines model for FolderLinks.
type FolderLinks struct {
	// Webui Web UI link of the content.
	Webui *string `json:"webui,omitempty"`
}

// FolderSingle defines model for FolderSingle.
type FolderSingle struct {
	Links *FolderLinks `json:"_links,omitempty"`

	// AuthorId The account ID of the user who created this folder.
	AuthorId *string `json:"authorId,omitempty"`

	// CreatedAt Date and time when the folder was created. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Id ID of the folder.
	Id *string `json:"id,omitempty"`

	// OwnerId The account ID of the user who owns this folder.
	OwnerId *string `json:"ownerId,omitempty"`

	// ParentId ID of the parent content, or null if there is no parent content.
	ParentId *string `json:"parentId,omitempty"`

	// ParentType Content type of the parent, or null if there is no parent.
	ParentType *ParentContentType `json:"parentType,omitempty"`

	// Position Position of the folder within the given parent page tree.
	Position *int32 `json:"position"`

	// Status The status of the content.
	Status *ContentStatus `json:"status,omitempty"`

	// Title Title of the folder.
	Title *string `json:"title,omitempty"`

	// Type The content type of the object.
	Type    *string  `json:"type,omitempty"`
	Version *Version `json:"version,omitempty"`
}

// FooterCommentModel defines model for FooterCommentModel.
type FooterCommentModel struct {
	Links *CommentLinks `json:"_links,omitempty"`

	// AttachmentId ID of the attachment containing the comment if the comment is on an attachment.
	AttachmentId *string `json:"attachmentId,omitempty"`

	// BlogPostId ID of the blog post containing the comment if the comment is on a blog post.
	BlogPostId *string `json:"blogPostId,omitempty"`

	// Body Contains fields for each representation type requested.
	Body *BodySingle `json:"body,omitempty"`

	// CustomContentId ID of the custom content containing the comment if the comment is on a custom content.
	CustomContentId *string `json:"customContentId,omitempty"`

	// Id ID of the comment.
	Id    *string `json:"id,omitempty"`
	Likes *struct {
		Links   *OptionalFieldLinks `json:"_links,omitempty"`
		Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
		Results *[]Like             `json:"results,omitempty"`
	} `json:"likes,omitempty"`
	Operations *struct {
		Links   *OptionalFieldLinks `json:"_links,omitempty"`
		Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
		Results *[]Operation        `json:"results,omitempty"`
	} `json:"operations,omitempty"`

	// PageId ID of the page containing the comment if the comment is on a page.
	PageId *string `json:"pageId,omitempty"`

	// ParentCommentId ID of the parent comment if the comment is a reply.
	ParentCommentId *string `json:"parentCommentId,omitempty"`
	Properties      *struct {
		Links   *OptionalFieldLinks `json:"_links,omitempty"`
		Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
		Results *[]ContentProperty  `json:"results,omitempty"`
	} `json:"properties,omitempty"`

	// Status The status of the content.
	Status *ContentStatus `json:"status,omitempty"`

	// Title Title of the comment.
	Title    *string  `json:"title,omitempty"`
	Version  *Version `json:"version,omitempty"`
	Versions *struct {
		Links   *OptionalFieldLinks `json:"_links,omitempty"`
		Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
		Results *[]Version          `json:"results,omitempty"`
	} `json:"versions,omitempty"`
}

// Icon This object represents an icon. If used as a profilePicture, this may be returned as null, depending on the user's privacy setting.
type Icon struct {
	IsDefault bool   `json:"isDefault"`
	Path      string `json:"path"`
}

// InlineCommentChildrenModel defines model for InlineCommentChildrenModel.
type InlineCommentChildrenModel struct {
	Links *CommentLinks `json:"_links,omitempty"`

	// Body Contains fields for each representation type requested.
	Body *BodyBulk `json:"body,omitempty"`

	// Id ID of the comment.
	Id *string `json:"id,omitempty"`

	// ParentCommentId ID of the parent comment the child comment is in.
	ParentCommentId *string                  `json:"parentCommentId,omitempty"`
	Properties      *InlineCommentProperties `json:"properties,omitempty"`

	// ResolutionStatus Inline comment resolution status
	ResolutionStatus *InlineCommentResolutionStatus `json:"resolutionStatus,omitempty"`

	// Status The status of the content.
	Status *ContentStatus `json:"status,omitempty"`

	// Title Title of the comment.
	Title   *string  `json:"title,omitempty"`
	Version *Version `json:"version,omitempty"`
}

// InlineCommentModel defines model for InlineCommentModel.
type InlineCommentModel struct {
	Links *CommentLinks `json:"_links,omitempty"`

	// BlogPostId ID of the blog post containing the comment if the comment is on a blog post.
	BlogPostId *string `json:"blogPostId,omitempty"`

	// Body Contains fields for each representation type requested.
	Body *BodySingle `json:"body,omitempty"`

	// Id ID of the comment.
	Id    *string `json:"id,omitempty"`
	Likes *struct {
		Links   *OptionalFieldLinks `json:"_links,omitempty"`
		Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
		Results *[]Like             `json:"results,omitempty"`
	} `json:"likes,omitempty"`
	Operations *struct {
		Links   *OptionalFieldLinks `json:"_links,omitempty"`
		Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
		Results *[]Operation        `json:"results,omitempty"`
	} `json:"operations,omitempty"`

	// PageId ID of the page containing the comment if the comment is on a page.
	PageId *string `json:"pageId,omitempty"`

	// ParentCommentId ID of the parent comment if the comment is a reply.
	ParentCommentId *string `json:"parentCommentId,omitempty"`
	Properties      *struct {
		Links *OptionalFieldLinks `json:"_links,omitempty"`

		// InlineMarkerRef Property value used to reference the highlighted element in DOM.
		InlineMarkerRef *string `json:"inlineMarkerRef,omitempty"`

		// InlineOriginalSelection Text that is highlighted.
		InlineOriginalSelection *string            `json:"inlineOriginalSelection,omitempty"`
		Meta                    *OptionalFieldMeta `json:"meta,omitempty"`
		Results                 *[]ContentProperty `json:"results,omitempty"`
	} `json:"properties,omitempty"`

	// ResolutionLastModifiedAt Timestamp of the last modification to the comment's resolution status. Null until comment is resolved or reopened.
	ResolutionLastModifiedAt *time.Time `json:"resolutionLastModifiedAt,omitempty"`

	// ResolutionLastModifierId Atlassian Account ID of last person who modified the resolve state of the comment. Null until comment is resolved or reopened.
	ResolutionLastModifierId *string `json:"resolutionLastModifierId,omitempty"`

	// ResolutionStatus Inline comment resolution status
	ResolutionStatus *InlineCommentResolutionStatus `json:"resolutionStatus,omitempty"`

	// Status The status of the content.
	Status *ContentStatus `json:"status,omitempty"`

	// Title Title of the comment.
	Title    *string  `json:"title,omitempty"`
	Version  *Version `json:"version,omitempty"`
	Versions *struct {
		Links   *OptionalFieldLinks `json:"_links,omitempty"`
		Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
		Results *[]Version          `json:"results,omitempty"`
	} `json:"versions,omitempty"`
}

// InlineCommentProperties defines model for InlineCommentProperties.
type InlineCommentProperties struct {
	// InlineMarkerRef Property value used to reference the highlighted element in DOM.
	InlineMarkerRef *string `json:"inlineMarkerRef,omitempty"`

	// InlineOriginalSelection Text that is highlighted.
	InlineOriginalSelection *string `json:"inlineOriginalSelection,omitempty"`
}

// InlineCommentResolutionStatus Inline comment resolution status
type InlineCommentResolutionStatus string

// Label defines model for Label.
type Label struct {
	// Id ID of the label.
	Id *string `json:"id,omitempty"`

	// Name Name of the label.
	Name *string `json:"name,omitempty"`

	// Prefix Prefix of the label.
	Prefix *string `json:"prefix,omitempty"`
}

// LabelSortOrder The sort fields for labels. The default sort direction is ascending. To sort in descending order, append a `-` character before the sort field. For example, `fieldName` or `-fieldName`.
type LabelSortOrder string

// Like defines model for Like.
type Like struct {
	// AccountId Account ID.
	AccountId *string `json:"accountId,omitempty"`
}

// MultiEntityLinks defines model for MultiEntityLinks.
type MultiEntityLinks struct {
	// Base Base url of the Confluence site.
	Base *string `json:"base,omitempty"`

	// Next Used for pagination. Contains the relative URL for the next set of results, using a cursor query parameter.
	// This property will not be present if there is no additional data available.
	Next *string `json:"next,omitempty"`
}

// OnlyArchivedAndCurrentContentStatus The status of the content.
type OnlyArchivedAndCurrentContentStatus string

// Operation defines model for Operation.
type Operation struct {
	// Operation The type of operation.
	Operation *string `json:"operation,omitempty"`

	// TargetType The type of entity the operation type targets.
	TargetType *string `json:"targetType,omitempty"`
}

// OptionalFieldLinks defines model for OptionalFieldLinks.
type OptionalFieldLinks struct {
	// Self A relative URL that can be used to fetch results beyond what this include parameter retrieves.
	Self *string `json:"self,omitempty"`
}

// OptionalFieldMeta defines model for OptionalFieldMeta.
type OptionalFieldMeta struct {
	// Cursor A token that can be used in the query parameter of the endpoint returned in the `_links` property to retrieve the next set of results.
	Cursor *string `json:"cursor,omitempty"`

	// HasMore Indicates if there are more available results that can be fetched.
	HasMore *bool `json:"hasMore,omitempty"`
}

// PageBodyWrite defines model for PageBodyWrite.
type PageBodyWrite struct {
	// Representation Type of content representation used for the value field.
	Representation *PageBodyWriteRepresentation `json:"representation,omitempty"`

	// Value Body of the page, in the format found in the representation field.
	Value *string `json:"value,omitempty"`
}

// PageBodyWriteRepresentation Type of content representation used for the value field.
type PageBodyWriteRepresentation string

// PageBulk defines model for PageBulk.
type PageBulk struct {
	Links *AbstractPageLinks `json:"_links,omitempty"`

	// AuthorId The account ID of the user who created this page originally.
	AuthorId *string `json:"authorId,omitempty"`

	// Body Contains fields for each representation type requested.
	Body *BodyBulk `json:"body,omitempty"`

	// CreatedAt Date and time when the page was created. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Id ID of the page.
	Id *string `json:"id,omitempty"`

	// LastOwnerId The account ID of the user who owned this page previously, or null if there is no previous owner.
	LastOwnerId *string `json:"lastOwnerId"`

	// OwnerId The account ID of the user who owns this page.
	OwnerId *string `json:"ownerId"`

	// ParentId ID of the parent page, or null if there is no parent page.
	ParentId *string `json:"parentId,omitempty"`

	// ParentType Content type of the parent, or null if there is no parent.
	ParentType *ParentContentType `json:"parentType,omitempty"`

	// Position Position of child page within the given parent page tree.
	Position *int32 `json:"position"`

	// SpaceId ID of the space the page is in.
	SpaceId *string `json:"spaceId,omitempty"`

	// Status The status of the content.
	Status *ContentStatus `json:"status,omitempty"`

	// Title Title of the page.
	Title   *string  `json:"title,omitempty"`
	Version *Version `json:"version,omitempty"`
}

// PageCommentModel defines model for PageCommentModel.
type PageCommentModel struct {
	Links *CommentLinks `json:"_links,omitempty"`

	// Body Contains fields for each representation type requested.
	Body *BodyBulk `json:"body,omitempty"`

	// Id ID of the comment.
	Id *string `json:"id,omitempty"`

	// PageId ID of the page the comment is in.
	PageId *string `json:"pageId,omitempty"`

	// Status The status of the content.
	Status *ContentStatus `json:"status,omitempty"`

	// Title Title of the comment.
	Title   *string  `json:"title,omitempty"`
	Version *Version `json:"version,omitempty"`
}

// PageInlineCommentModel defines model for PageInlineCommentModel.
type PageInlineCommentModel struct {
	Links *CommentLinks `json:"_links,omitempty"`

	// Body Contains fields for each representation type requested.
	Body *BodyBulk `json:"body,omitempty"`

	// Id ID of the comment.
	Id *string `json:"id,omitempty"`

	// PageId ID of the page the comment is in.
	PageId     *string                  `json:"pageId,omitempty"`
	Properties *InlineCommentProperties `json:"properties,omitempty"`

	// ResolutionStatus Inline comment resolution status
	ResolutionStatus *InlineCommentResolutionStatus `json:"resolutionStatus,omitempty"`

	// Status The status of the content.
	Status *ContentStatus `json:"status,omitempty"`

	// Title Title of the comment.
	Title   *string  `json:"title,omitempty"`
	Version *Version `json:"version,omitempty"`
}

// PageNestedBodyWrite Body of the page. Only one body format should be specified as the property
// for this object, e.g. `storage`.
type PageNestedBodyWrite struct {
	AtlasDocFormat *PageBodyWrite `json:"atlas_doc_format,omitempty"`
	Storage        *PageBodyWrite `json:"storage,omitempty"`
	Wiki           *PageBodyWrite `json:"wiki,omitempty"`
}

// PageSingle defines model for PageSingle.
type PageSingle struct {
	Links *AbstractPageLinks `json:"_links,omitempty"`

	// AuthorId The account ID of the user who created this page originally.
	AuthorId *string `json:"authorId,omitempty"`

	// Body Contains fields for each representation type requested.
	Body *BodySingle `json:"body,omitempty"`

	// CreatedAt Date and time when the page was created. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Id ID of the page.
	Id *string `json:"id,omitempty"`

	// IsFavoritedByCurrentUser Whether the page has been favorited by the current user.
	IsFavoritedByCurrentUser *bool `json:"isFavoritedByCurrentUser,omitempty"`
	Labels                   *struct {
		Links   *OptionalFieldLinks `json:"_links,omitempty"`
		Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
		Results *[]Label            `json:"results,omitempty"`
	} `json:"labels,omitempty"`

	// LastOwnerId The account ID of the user who owned this page previously, or null if there is no previous owner.
	LastOwnerId *string `json:"lastOwnerId"`
	Likes       *struct {
		Links   *OptionalFieldLinks `json:"_links,omitempty"`
		Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
		Results *[]Like             `json:"results,omitempty"`
	} `json:"likes,omitempty"`
	Operations *struct {
		Links   *OptionalFieldLinks `json:"_links,omitempty"`
		Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
		Results *[]Operation        `json:"results,omitempty"`
	} `json:"operations,omitempty"`

	// OwnerId The account ID of the user who owns this page.
	OwnerId *string `json:"ownerId"`

	// ParentId ID of the parent page, or null if there is no parent page.
	ParentId *string `json:"parentId,omitempty"`

	// ParentType Content type of the parent, or null if there is no parent.
	ParentType *ParentContentType `json:"parentType,omitempty"`

	// Position Position of child page within the given parent page tree.
	Position   *int32 `json:"position"`
	Properties *struct {
		Links   *OptionalFieldLinks `json:"_links,omitempty"`
		Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
		Results *[]ContentProperty  `json:"results,omitempty"`
	} `json:"properties,omitempty"`

	// SpaceId ID of the space the page is in.
	SpaceId *string `json:"spaceId,omitempty"`

	// Status The status of the content.
	Status *ContentStatus `json:"status,omitempty"`

	// Title Title of the page.
	Title    *string  `json:"title,omitempty"`
	Version  *Version `json:"version,omitempty"`
	Versions *struct {
		Links   *OptionalFieldLinks `json:"_links,omitempty"`
		Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
		Results *[]Version          `json:"results,omitempty"`
	} `json:"versions,omitempty"`
}

// PageSortOrder The sort fields for pages. The default sort direction is ascending. To sort in descending order, append a `-` character before the sort field. For example, `fieldName` or `-fieldName`.
type PageSortOrder string

// PageVersion defines model for PageVersion.
type PageVersion struct {
	// AuthorId The account ID of the user who created this version.
	AuthorId *string `json:"authorId,omitempty"`

	// CreatedAt Date and time when the version was created. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Message Message associated with the current version.
	Message *string `json:"message,omitempty"`

	// MinorEdit Describes if this version is a minor version. Email notifications and activity stream updates are not created for minor versions.
	MinorEdit *bool `json:"minorEdit,omitempty"`

	// Number The version number.
	Number *int32           `json:"number,omitempty"`
	Page   *VersionedEntity `json:"page,omitempty"`
}

// ParentContentType Content type of the parent, or null if there is no parent.
type ParentContentType string

// PermittedOperationsResponse The list of operations permitted on entity.
type PermittedOperationsResponse struct {
	Operations *[]Operation `json:"operations,omitempty"`
}

// PrimaryBodyRepresentation The primary formats a body can be represented as. A subset of BodyRepresentation. These formats are the only allowed formats in certain use cases.
type PrimaryBodyRepresentation string

// PrimaryBodyRepresentationSingle The primary formats a body can be represented as. A subset of BodyRepresentation. These formats are the only allowed formats in certain use cases.
type PrimaryBodyRepresentationSingle string

// SmartLinkLinks defines model for SmartLinkLinks.
type SmartLinkLinks struct {
	// Webui Web UI link of the content.
	Webui *string `json:"webui,omitempty"`
}

// SmartLinkSingle defines model for SmartLinkSingle.
type SmartLinkSingle struct {
	Links *SmartLinkLinks `json:"_links,omitempty"`

	// AuthorId The account ID of the user who created this Smart Link in the content tree originally.
	AuthorId *string `json:"authorId,omitempty"`

	// CreatedAt Date and time when the Smart Link in the content tree was created. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// EmbedUrl The embedded URL of the Smart Link. If the Smart Link does not have an embedded URL, this property will not be included in the response.
	EmbedUrl *string `json:"embedUrl,omitempty"`

	// Id ID of the Smart Link in the content tree.
	Id *string `json:"id,omitempty"`

	// OwnerId The account ID of the user who owns this Smart Link in the content tree.
	OwnerId *string `json:"ownerId,omitempty"`

	// ParentId ID of the parent content, or null if there is no parent content.
	ParentId *string `json:"parentId,omitempty"`

	// ParentType Content type of the parent, or null if there is no parent.
	ParentType *ParentContentType `json:"parentType,omitempty"`

	// Position Position of the Smart Link within the given parent page tree.
	Position *int32 `json:"position"`

	// Status The status of the content.
	Status *ContentStatus `json:"status,omitempty"`

	// Title Title of the Smart Link in the content tree.
	Title *string `json:"title,omitempty"`

	// Type The content type of the object.
	Type    *string  `json:"type,omitempty"`
	Version *Version `json:"version,omitempty"`
}

// SpaceBulk defines model for SpaceBulk.
type SpaceBulk struct {
	Links *SpaceLinks `json:"_links,omitempty"`

	// AuthorId The account ID of the user who created this space originally.
	AuthorId *string `json:"authorId,omitempty"`

	// CreatedAt Date and time when the space was created. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Description Contains fields for each representation type requested.
	Description *SpaceDescription `json:"description,omitempty"`

	// HomepageId ID of the space's homepage.
	HomepageId *string `json:"homepageId,omitempty"`

	// Icon The icon of the space
	Icon *SpaceIcon `json:"icon,omitempty"`

	// Id ID of the space.
	Id *string `json:"id,omitempty"`

	// Key Key of the space.
	Key *string `json:"key,omitempty"`

	// Name Name of the space.
	Name *string `json:"name,omitempty"`

	// Status The status of the space.
	Status *SpaceStatus `json:"status,omitempty"`

	// Type The type of space.
	Type *SpaceType `json:"type,omitempty"`
}

// SpaceDescription Contains fields for each representation type requested.
type SpaceDescription struct {
	Plain *BodyType `json:"plain,omitempty"`
	View  *BodyType `json:"view,omitempty"`
}

// SpaceDescriptionBodyRepresentation The formats a space description can be represented as. A subset of BodyRepresentation.
type SpaceDescriptionBodyRepresentation string

// SpaceIcon The icon of the space
type SpaceIcon struct {
	// ApiDownloadLink The path (relative to base URL) that can be used to retrieve a link to download the space icon. 3LO apps should use this link instead of the value provided
	// in the `path` property to retrieve the icon.
	//
	// Currently this field is only returned for `global` spaces and not `personal` spaces.
	ApiDownloadLink *string `json:"apiDownloadLink,omitempty"`

	// Path The path (relative to base URL) at which the space's icon can be retrieved. The format should be like `/wiki/download/...` or `/wiki/aa-avatar/...`
	Path *string `json:"path,omitempty"`
}

// SpaceLinks defines model for SpaceLinks.
type SpaceLinks struct {
	// Webui Web UI link of the space.
	Webui *string `json:"webui,omitempty"`
}

// SpacePermission defines model for SpacePermission.
type SpacePermission struct {
	// Id ID of the space permission.
	Id *string `json:"id,omitempty"`

	// Operation The operation the space permission corresponds to.
	Operation *struct {
		// Key The type of operation.
		Key *SpacePermissionOperationKey `json:"key,omitempty"`

		// TargetType The type of entity the operation type targets.
		TargetType *SpacePermissionOperationTargetType `json:"targetType,omitempty"`
	} `json:"operation,omitempty"`

	// Principal The entity the space permissions corresponds to.
	Principal *struct {
		// Id ID of the entity.
		Id   *string                       `json:"id,omitempty"`
		Type *SpacePermissionPrincipalType `json:"type,omitempty"`
	} `json:"principal,omitempty"`
}

// SpacePermissionOperationKey The type of operation.
type SpacePermissionOperationKey string

// SpacePermissionOperationTargetType The type of entity the operation type targets.
type SpacePermissionOperationTargetType string

// SpacePermissionPrincipalType defines model for SpacePermission.Principal.Type.
type SpacePermissionPrincipalType string

// SpaceProperty defines model for SpaceProperty.
type SpaceProperty struct {
	// CreatedAt RFC3339 compliant date time at which the property was created.
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// CreatedBy Atlassian account ID of the user that created the space property.
	CreatedBy *string `json:"createdBy,omitempty"`

	// Id ID of the space property.
	Id *string `json:"id,omitempty"`

	// Key Key of the space property.
	Key *string `json:"key,omitempty"`

	// Value Value of the space property.
	Value   *interface{} `json:"value,omitempty"`
	Version *struct {
		// CreatedAt RFC3339 compliant date time at which the property's current version was created.
		CreatedAt *time.Time `json:"createdAt,omitempty"`

		// CreatedBy Atlassian account ID of the user that created the space property's current version.
		CreatedBy *string `json:"createdBy,omitempty"`

		// Message Message associated with the current version.
		Message *string `json:"message,omitempty"`

		// Number The space property's current version number.
		Number *int32 `json:"number,omitempty"`
	} `json:"version,omitempty"`
}

// SpacePropertyCreateRequest defines model for SpacePropertyCreateRequest.
type SpacePropertyCreateRequest struct {
	// Key Key of the space property
	Key *string `json:"key,omitempty"`

	// Value Value of the space property.
	Value *interface{} `json:"value,omitempty"`
}

// SpacePropertyUpdateRequest defines model for SpacePropertyUpdateRequest.
type SpacePropertyUpdateRequest struct {
	// Key Key of the space property
	Key *string `json:"key,omitempty"`

	// Value Value of the space property.
	Value *interface{} `json:"value,omitempty"`

	// Version New version number and associated message
	Version *struct {
		// Message Message to be associated with the new version.
		Message *string `json:"message,omitempty"`

		// Number Version number of the new version. Should be 1 more than the current version number.
		Number *int32 `json:"number,omitempty"`
	} `json:"version,omitempty"`
}

// SpaceSingle defines model for SpaceSingle.
type SpaceSingle struct {
	Links *SpaceLinks `json:"_links,omitempty"`

	// AuthorId The account ID of the user who created this space originally.
	AuthorId *string `json:"authorId,omitempty"`

	// CreatedAt Date and time when the space was created. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Description Contains fields for each representation type requested.
	Description *SpaceDescription `json:"description,omitempty"`

	// HomepageId ID of the space's homepage.
	HomepageId *string `json:"homepageId,omitempty"`

	// Icon The icon of the space
	Icon *SpaceIcon `json:"icon,omitempty"`

	// Id ID of the space.
	Id *string `json:"id,omitempty"`

	// Key Key of the space.
	Key    *string `json:"key,omitempty"`
	Labels *struct {
		Links   *OptionalFieldLinks `json:"_links,omitempty"`
		Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
		Results *[]Label            `json:"results,omitempty"`
	} `json:"labels,omitempty"`

	// Name Name of the space.
	Name       *string `json:"name,omitempty"`
	Operations *struct {
		Links   *OptionalFieldLinks `json:"_links,omitempty"`
		Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
		Results *[]Operation        `json:"results,omitempty"`
	} `json:"operations,omitempty"`
	Permissions *struct {
		Links   *OptionalFieldLinks `json:"_links,omitempty"`
		Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
		Results *[]SpacePermission  `json:"results,omitempty"`
	} `json:"permissions,omitempty"`
	Properties *struct {
		Links   *OptionalFieldLinks `json:"_links,omitempty"`
		Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
		Results *[]SpaceProperty    `json:"results,omitempty"`
	} `json:"properties,omitempty"`

	// Status The status of the space.
	Status *SpaceStatus `json:"status,omitempty"`

	// Type The type of space.
	Type *SpaceType `json:"type,omitempty"`
}

// SpaceSortOrder The sort fields for spaces. The default sort direction is ascending. To sort in descending order, append a `-` character before the sort field. For example, `fieldName` or `-fieldName`.
type SpaceSortOrder string

// SpaceStatus The status of the space.
type SpaceStatus string

// SpaceType The type of space.
type SpaceType string

// Task defines model for Task.
type Task struct {
	// AssignedTo Account ID of the user to whom this task is assigned.
	AssignedTo *string `json:"assignedTo,omitempty"`

	// BlogPostId ID of the blog post the task is in.
	BlogPostId *string `json:"blogPostId,omitempty"`

	// Body Contains fields for each representation type requested.
	Body *TaskBodySingle `json:"body,omitempty"`

	// CompletedAt Date and time when the task was completed. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
	CompletedAt *time.Time `json:"completedAt,omitempty"`

	// CompletedBy Account ID of the user who completed this task.
	CompletedBy *string `json:"completedBy,omitempty"`

	// CreatedAt Date and time when the task was created. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// CreatedBy Account ID of the user who created this task.
	CreatedBy *string `json:"createdBy,omitempty"`

	// DueAt Date and time when the task is due. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
	DueAt *time.Time `json:"dueAt,omitempty"`

	// Id ID of the task.
	Id *string `json:"id,omitempty"`

	// LocalId Local ID of the task. This ID is local to the corresponding page or blog post.
	LocalId *string `json:"localId,omitempty"`

	// PageId ID of the page the task is in.
	PageId *string `json:"pageId,omitempty"`

	// SpaceId ID of the space the task is in.
	SpaceId *string `json:"spaceId,omitempty"`

	// Status Status of the task.
	Status *TaskStatus `json:"status,omitempty"`

	// UpdatedAt Date and time when the task was updated. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
}

// TaskStatus Status of the task.
type TaskStatus string

// TaskBodySingle Contains fields for each representation type requested.
type TaskBodySingle struct {
	AtlasDocFormat *BodyType `json:"atlas_doc_format,omitempty"`
	Storage        *BodyType `json:"storage,omitempty"`
}

// UpdateFooterCommentModel defines model for UpdateFooterCommentModel.
type UpdateFooterCommentModel struct {
	Body    *CommentBodyWrite `json:"body,omitempty"`
	Version *struct {
		// Message Optional message store for the new version.
		Message *string `json:"message,omitempty"`

		// Number Number of new version. Should be 1 higher than current version of the comment.
		Number *int `json:"number,omitempty"`
	} `json:"version,omitempty"`
}

// UpdateInlineCommentModel defines model for UpdateInlineCommentModel.
type UpdateInlineCommentModel struct {
	Body *CommentBodyWrite `json:"body,omitempty"`

	// Resolved Resolved state of the comment. Set to true to resolve the comment, set to false to reopen it. If
	// matching the existing state (i.e. true -> resolved or false -> open/reopened) , no change will occur. A dangling
	// comment cannot be updated.
	Resolved *bool `json:"resolved,omitempty"`
	Version  *struct {
		// Message Optional message store for the new version.
		Message *string `json:"message,omitempty"`

		// Number Number of new version. Should be 1 higher than current version of the comment.
		Number *int `json:"number,omitempty"`
	} `json:"version,omitempty"`
}

// User defines model for User.
type User struct {
	// AccountId Account ID of the user.
	AccountId *string `json:"accountId,omitempty"`

	// AccountStatus The account status of the user.
	AccountStatus *AccountStatus `json:"accountStatus,omitempty"`

	// AccountType The account type of the user.
	AccountType *AccountType `json:"accountType,omitempty"`

	// DisplayName Display name of the user.
	DisplayName *string `json:"displayName,omitempty"`

	// Email The email address of the user. Depending on the user's privacy setting, this may return an empty string.
	Email *string `json:"email,omitempty"`

	// IsExternalCollaborator Whether the user is an external collaborator.
	IsExternalCollaborator *bool `json:"isExternalCollaborator,omitempty"`

	// PersonalSpaceId Space ID of the user's personal space. Returns null, if no personal space for the user.
	PersonalSpaceId *string `json:"personalSpaceId,omitempty"`

	// ProfilePicture This object represents an icon. If used as a profilePicture, this may be returned as null, depending on the user's privacy setting.
	ProfilePicture *Icon `json:"profilePicture"`

	// PublicName Public name of the user.
	PublicName *string `json:"publicName,omitempty"`

	// TimeZone Time zone of the user. Depending on the user's privacy
	// setting, this may return null.
	TimeZone *string `json:"timeZone,omitempty"`
}

// Version defines model for Version.
type Version struct {
	// AuthorId The account ID of the user who created this version.
	AuthorId *string `json:"authorId,omitempty"`

	// CreatedAt Date and time when the version was created. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Message Message associated with the current version.
	Message *string `json:"message,omitempty"`

	// MinorEdit Describes if this version is a minor version. Email notifications and activity stream updates are not created for minor versions.
	MinorEdit *bool `json:"minorEdit,omitempty"`

	// Number The version number.
	Number *int32 `json:"number,omitempty"`
}

// VersionSortOrder The sort fields for versions. The default sort direction is ascending. To sort in descending order, append a `-` character before the sort field. For example, `fieldName` or `-fieldName`.
type VersionSortOrder string

// VersionedEntity defines model for VersionedEntity.
type VersionedEntity struct {
	// Body Contains fields for each representation type requested.
	Body *BodyBulk `json:"body,omitempty"`

	// Id ID of the entity.
	Id *string `json:"id,omitempty"`

	// Title Title of the entity.
	Title *string `json:"title,omitempty"`
}

// WhiteboardLinks defines model for WhiteboardLinks.
type WhiteboardLinks struct {
	// Editui Edit UI link of the content.
	Editui *string `json:"editui,omitempty"`

	// Webui Web UI link of the content.
	Webui *string `json:"webui,omitempty"`
}

// WhiteboardSingle defines model for WhiteboardSingle.
type WhiteboardSingle struct {
	Links *WhiteboardLinks `json:"_links,omitempty"`

	// AuthorId The account ID of the user who created this whiteboard originally.
	AuthorId *string `json:"authorId,omitempty"`

	// CreatedAt Date and time when the whiteboard was created. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Id ID of the whiteboard.
	Id *string `json:"id,omitempty"`

	// OwnerId The account ID of the user who owns this whiteboard.
	OwnerId *string `json:"ownerId,omitempty"`

	// ParentId ID of the parent content, or null if there is no parent content.
	ParentId *string `json:"parentId,omitempty"`

	// ParentType Content type of the parent, or null if there is no parent.
	ParentType *ParentContentType `json:"parentType,omitempty"`

	// Position Position of the whiteboard within the given parent page tree.
	Position *int32 `json:"position"`

	// Status The status of the content.
	Status *ContentStatus `json:"status,omitempty"`

	// Title Title of the whiteboard.
	Title *string `json:"title,omitempty"`

	// Type The content type of the object.
	Type    *string  `json:"type,omitempty"`
	Version *Version `json:"version,omitempty"`
}

// BlogPostCreateRequest defines model for BlogPostCreateRequest.
type BlogPostCreateRequest struct {
	Body *BlogPostBodyWrite `json:"body,omitempty"`

	// SpaceId ID of the space
	SpaceId string `json:"spaceId"`

	// Status The status of the blog post, specifies if the blog post will be created as a new blog post or a draft
	Status *string `json:"status,omitempty"`

	// Title Title of the blog post, required if creating non-draft.
	Title *string `json:"title,omitempty"`
}

// BlogPostUpdateRequest defines model for BlogPostUpdateRequest.
type BlogPostUpdateRequest struct {
	Body BlogPostBodyWrite `json:"body"`

	// Id Id of the blog post.
	Id string `json:"id"`

	// SpaceId ID of the containing space.
	//
	// This currently **does not support moving the blog post to a different space**.
	SpaceId *string `json:"spaceId,omitempty"`

	// Status The updated status of the blog post.
	//
	// Note, if you change the status of a blog post from 'current' to 'draft' and it has an existing draft, the existing draft will be deleted in favor of the updated draft.
	// Additionally, this endpoint can be used to restore a 'trashed' or 'deleted' blog post to 'current' status. For restoration, blog post contents will not be updated and only the blog post status will be changed.
	Status string `json:"status"`

	// Title Title of the blog post.
	Title   string `json:"title"`
	Version struct {
		// Message An optional message to be stored with the version.
		Message *string `json:"message,omitempty"`

		// Number The new version number of the updated blog post.
		// Set this to the current version number plus one, unless you are updating the status to 'draft' which requires a version number of 1.
		//
		// If you don't know the current version number, use Get blog post by id.
		Number *int32 `json:"number,omitempty"`
	} `json:"version"`
}

// BulkUsersRequest defines model for BulkUsersRequest.
type BulkUsersRequest struct {
	// AccountIds List of accountIds to retrieve user info for.
	AccountIds []string `json:"accountIds"`
}

// CheckAccessOrInviteByEmailRequest defines model for CheckAccessOrInviteByEmailRequest.
type CheckAccessOrInviteByEmailRequest struct {
	// Emails List of emails to check access to site.
	Emails []string `json:"emails"`
}

// ContentClassificationLevelDeleteRequest defines model for ContentClassificationLevelDeleteRequest.
type ContentClassificationLevelDeleteRequest struct {
	// Status Status of the content.
	Status string `json:"status"`
}

// ContentClassificationLevelUpdateRequest defines model for ContentClassificationLevelUpdateRequest.
type ContentClassificationLevelUpdateRequest struct {
	// Id The ID of the classification level.
	Id string `json:"id"`

	// Status Status of the content.
	Status string `json:"status"`
}

// ContentIdToContentTypeRequest defines model for ContentIdToContentTypeRequest.
type ContentIdToContentTypeRequest struct {
	// ContentIds The content ids to convert. They may be provided as strings or numbers.
	ContentIds []string `json:"contentIds"`
}

// CustomContentCreateRequest defines model for CustomContentCreateRequest.
type CustomContentCreateRequest struct {
	// BlogPostId ID of the containing Blog Post.
	BlogPostId *string                `json:"blogPostId,omitempty"`
	Body       CustomContentBodyWrite `json:"body"`

	// CustomContentId ID of the containing custom content.
	CustomContentId *string `json:"customContentId,omitempty"`

	// PageId ID of the containing page.
	PageId *string `json:"pageId,omitempty"`

	// SpaceId ID of the containing space.
	SpaceId *string `json:"spaceId,omitempty"`

	// Status The status of the custom content.
	Status *string `json:"status,omitempty"`

	// Title Title of the custom content.
	Title string `json:"title"`

	// Type Type of custom content.
	Type string `json:"type"`
}

// CustomContentUpdateRequest defines model for CustomContentUpdateRequest.
type CustomContentUpdateRequest struct {
	// BlogPostId ID of the containing Blog Post.
	BlogPostId *string                `json:"blogPostId,omitempty"`
	Body       CustomContentBodyWrite `json:"body"`

	// CustomContentId ID of the containing custom content.
	CustomContentId *string `json:"customContentId,omitempty"`

	// Id Id of custom content.
	Id string `json:"id"`

	// PageId ID of the containing page.
	PageId *string `json:"pageId,omitempty"`

	// SpaceId ID of the containing space.
	SpaceId *string `json:"spaceId,omitempty"`

	// Status The status of the custom content.
	Status string `json:"status"`

	// Title Title of the custom content.
	Title string `json:"title"`

	// Type Type of custom content.
	Type    string `json:"type"`
	Version struct {
		// Message An optional message to be stored with the version.
		Message *string `json:"message,omitempty"`

		// Number The version number, must be incremented by one.
		Number *int32 `json:"number,omitempty"`
	} `json:"version"`
}

// DatabaseCreateRequest defines model for DatabaseCreateRequest.
type DatabaseCreateRequest struct {
	// ParentId The parent content ID of the database.
	ParentId *string `json:"parentId,omitempty"`

	// SpaceId ID of the space.
	SpaceId string `json:"spaceId"`

	// Title Title of the database.
	Title *string `json:"title,omitempty"`
}

// FolderCreateRequest defines model for FolderCreateRequest.
type FolderCreateRequest struct {
	// ParentId The parent content ID of the folder.
	ParentId *string `json:"parentId,omitempty"`

	// SpaceId ID of the space.
	SpaceId string `json:"spaceId"`

	// Title Title of the folder.
	Title *string `json:"title,omitempty"`
}

// LiveEditContentClassificationLevelResetRequest defines model for LiveEditContentClassificationLevelResetRequest.
type LiveEditContentClassificationLevelResetRequest struct {
	// Status Status of the content.
	Status string `json:"status"`
}

// LiveEditContentClassificationLevelUpdateRequest defines model for LiveEditContentClassificationLevelUpdateRequest.
type LiveEditContentClassificationLevelUpdateRequest struct {
	// Id The ID of the classification level.
	Id string `json:"id"`

	// Status Status of the content.
	Status string `json:"status"`
}

// PageCreateRequest defines model for PageCreateRequest.
type PageCreateRequest struct {
	Body *PageBodyWrite `json:"body,omitempty"`

	// ParentId The parent content ID of the page. If the `root-level` query parameter is set to false and a value is
	// not supplied for this parameter, then the space homepage's ID will be used. If the `root-level` query
	// parameter is set to true, then a value may not be supplied for this parameter.
	ParentId *string `json:"parentId,omitempty"`

	// SpaceId ID of the space.
	SpaceId string `json:"spaceId"`

	// Status The status of the page, published or draft.
	Status *string `json:"status,omitempty"`

	// Title Title of the page, required if page status is not draft.
	Title *string `json:"title,omitempty"`
}

// PageUpdateRequest defines model for PageUpdateRequest.
type PageUpdateRequest struct {
	Body PageBodyWrite `json:"body"`

	// Id Id of the page.
	Id string `json:"id"`

	// OwnerId Account ID of the page owner.
	//
	// This allows page ownership to be transferred to another user.
	OwnerId *interface{} `json:"ownerId,omitempty"`

	// ParentId ID of the parent page.
	//
	// This allows the page to be moved under a different parent within the same space.
	ParentId *interface{} `json:"parentId,omitempty"`

	// SpaceId ID of the containing space.
	//
	// This currently **does not support moving the page to a different space**.
	SpaceId *interface{} `json:"spaceId,omitempty"`

	// Status The updated status of the page.
	//
	// Note, if you change the status of a page from 'current' to 'draft' and it has an existing draft, the existing draft will be deleted in favor of the updated draft.
	// Additionally, this endpoint can be used to restore a 'trashed' or 'deleted' page to 'current' status. For restoration, page contents will not be updated and only the page status will be changed.
	Status string `json:"status"`

	// Title Title of the page.
	Title   string `json:"title"`
	Version struct {
		// Message An optional message to be stored with the version.
		Message *string `json:"message,omitempty"`

		// Number The new version of the updated page.
		// Set this to the current version number plus one, unless you are updating the status to 'draft' which requires a version number of 1.
		//
		// If you don't know the current version number, use Get page by id.
		Number *int32 `json:"number,omitempty"`
	} `json:"version"`
}

// SmartLinkCreateRequest defines model for SmartLinkCreateRequest.
type SmartLinkCreateRequest struct {
	// EmbedUrl The URL that the Smart Link in the content tree should be populated with.
	EmbedUrl *string `json:"embedUrl,omitempty"`

	// ParentId The parent content ID of the Smart Link in the content tree.
	ParentId *string `json:"parentId,omitempty"`

	// SpaceId ID of the space.
	SpaceId string `json:"spaceId"`

	// Title Title of the Smart Link in the content tree.
	Title *string `json:"title,omitempty"`
}

// SpaceDefaultClassificationLevelUpdateRequest defines model for SpaceDefaultClassificationLevelUpdateRequest.
type SpaceDefaultClassificationLevelUpdateRequest struct {
	// Id The ID of the classification level.
	Id string `json:"id"`

	// Status Status of the content.
	Status string `json:"status"`
}

// TaskUpdateRequest defines model for TaskUpdateRequest.
type TaskUpdateRequest struct {
	// AssignedTo Account ID of the user to whom this task is assigned.
	AssignedTo *string `json:"assignedTo,omitempty"`

	// BlogPostId ID of the blog post the task is in.
	BlogPostId *string `json:"blogPostId,omitempty"`

	// CompletedAt Date and time when the task was completed. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
	CompletedAt *time.Time `json:"completedAt,omitempty"`

	// CompletedBy Account ID of the user who completed this task.
	CompletedBy *string `json:"completedBy,omitempty"`

	// CreatedAt Date and time when the task was created. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// CreatedBy Account ID of the user who created this task.
	CreatedBy *string `json:"createdBy,omitempty"`

	// DueAt Date and time when the task is due. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
	DueAt *time.Time `json:"dueAt,omitempty"`

	// Id ID of the task.
	Id *string `json:"id,omitempty"`

	// LocalId Local ID of the task. This ID is local to the corresponding page or blog post.
	LocalId *string `json:"localId,omitempty"`

	// PageId ID of the page the task is in.
	PageId *string `json:"pageId,omitempty"`

	// SpaceId ID of the space the task is in.
	SpaceId *string `json:"spaceId,omitempty"`

	// Status Status of the task.
	Status string `json:"status"`

	// UpdatedAt Date and time when the task was updated. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
}

// WhiteboardCreateRequest defines model for WhiteboardCreateRequest.
type WhiteboardCreateRequest struct {
	// ParentId The parent content ID of the whiteboard.
	ParentId *string `json:"parentId,omitempty"`

	// SpaceId ID of the space.
	SpaceId string `json:"spaceId"`

	// Title Title of the whiteboard.
	Title *string `json:"title,omitempty"`
}

// GetAttachmentsParams defines parameters for GetAttachments.
type GetAttachmentsParams struct {
	// Sort Used to sort the result by a particular field.
	Sort *AttachmentSortOrder `form:"sort,omitempty" json:"sort,omitempty"`

	// Cursor Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Status Filter the results to attachments based on their status. By default, `current` and `archived` are used.
	Status *[]GetAttachmentsParamsStatus `form:"status,omitempty" json:"status,omitempty"`

	// MediaType Filters on the mediaType of attachments. Only one may be specified.
	MediaType *string `form:"mediaType,omitempty" json:"mediaType,omitempty"`

	// Filename Filters on the file-name of attachments. Only one may be specified.
	Filename *string `form:"filename,omitempty" json:"filename,omitempty"`

	// Limit Maximum number of attachments per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetAttachmentsParamsStatus defines parameters for GetAttachments.
type GetAttachmentsParamsStatus string

// GetAttachmentContentPropertiesParams defines parameters for GetAttachmentContentProperties.
type GetAttachmentContentPropertiesParams struct {
	// Key Filters the response to return a specific content property with matching key (case sensitive).
	Key *string `form:"key,omitempty" json:"key,omitempty"`

	// Sort Used to sort the result by a particular field.
	Sort *ContentPropertySortOrder `form:"sort,omitempty" json:"sort,omitempty"`

	// Cursor Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit Maximum number of attachments per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// DeleteAttachmentParams defines parameters for DeleteAttachment.
type DeleteAttachmentParams struct {
	// Purge If attempting to purge the attachment.
	Purge *bool `form:"purge,omitempty" json:"purge,omitempty"`
}

// GetAttachmentByIdParams defines parameters for GetAttachmentById.
type GetAttachmentByIdParams struct {
	// Version Allows you to retrieve a previously published version. Specify the previous version's number to retrieve its details.
	Version *int `form:"version,omitempty" json:"version,omitempty"`

	// IncludeLabels Includes labels associated with this attachment in the response.
	// The number of results will be limited to 50 and sorted in the default sort order.
	// A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.
	IncludeLabels *bool `form:"include-labels,omitempty" json:"include-labels,omitempty"`

	// IncludeProperties Includes content properties associated with this attachment in the response.
	// The number of results will be limited to 50 and sorted in the default sort order.
	// A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.
	IncludeProperties *bool `form:"include-properties,omitempty" json:"include-properties,omitempty"`

	// IncludeOperations Includes operations associated with this attachment in the response.
	// The number of results will be limited to 50 and sorted in the default sort order.
	// A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.
	IncludeOperations *bool `form:"include-operations,omitempty" json:"include-operations,omitempty"`

	// IncludeVersions Includes versions associated with this attachment in the response.
	// The number of results will be limited to 50 and sorted in the default sort order.
	// A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.
	IncludeVersions *bool `form:"include-versions,omitempty" json:"include-versions,omitempty"`

	// IncludeVersion Includes the current version associated with this attachment in the response.
	// By default this is included and can be omitted by setting the value to `false`.
	IncludeVersion *bool `form:"include-version,omitempty" json:"include-version,omitempty"`
}

// GetAttachmentCommentsParams defines parameters for GetAttachmentComments.
type GetAttachmentCommentsParams struct {
	// BodyFormat The content format type to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.
	BodyFormat *PrimaryBodyRepresentation `form:"body-format,omitempty" json:"body-format,omitempty"`

	// Cursor Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit Maximum number of comments per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Sort Used to sort the result by a particular field.
	Sort *CommentSortOrder `form:"sort,omitempty" json:"sort,omitempty"`

	// Version Version number of the attachment to retrieve comments for. If no version provided, retrieves comments for the latest version.
	Version *int64 `form:"version,omitempty" json:"version,omitempty"`
}

// GetAttachmentLabelsParams defines parameters for GetAttachmentLabels.
type GetAttachmentLabelsParams struct {
	// Prefix Filter the results to labels based on their prefix.
	Prefix *GetAttachmentLabelsParamsPrefix `form:"prefix,omitempty" json:"prefix,omitempty"`

	// Sort Used to sort the result by a particular field.
	Sort *string `form:"sort,omitempty" json:"sort,omitempty"`

	// Cursor Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit Maximum number of labels per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetAttachmentLabelsParamsPrefix defines parameters for GetAttachmentLabels.
type GetAttachmentLabelsParamsPrefix string

// GetAttachmentVersionsParams defines parameters for GetAttachmentVersions.
type GetAttachmentVersionsParams struct {
	// Cursor Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit Maximum number of versions per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Sort Used to sort the result by a particular field.
	Sort *VersionSortOrder `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetBlogPostsParams defines parameters for GetBlogPosts.
type GetBlogPostsParams struct {
	// Id Filter the results based on blog post ids. Multiple blog post ids can be specified as a comma-separated list.
	Id *[]int64 `form:"id,omitempty" json:"id,omitempty"`

	// SpaceId Filter the results based on space ids. Multiple space ids can be specified as a comma-separated list.
	SpaceId *[]int64 `form:"space-id,omitempty" json:"space-id,omitempty"`

	// Sort Used to sort the result by a particular field.
	Sort *BlogPostSortOrder `form:"sort,omitempty" json:"sort,omitempty"`

	// Status Filter the results to blog posts based on their status. By default, `current` is used.
	Status *[]GetBlogPostsParamsStatus `form:"status,omitempty" json:"status,omitempty"`

	// Title Filter the results to blog posts based on their title.
	Title *string `form:"title,omitempty" json:"title,omitempty"`

	// BodyFormat The content format types to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.
	BodyFormat *PrimaryBodyRepresentation `form:"body-format,omitempty" json:"body-format,omitempty"`

	// Cursor Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit Maximum number of blog posts per result to return. If more results exist, use the `Link` response header to retrieve a relative URL that will return the next set of results.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetBlogPostsParamsStatus defines parameters for GetBlogPosts.
type GetBlogPostsParamsStatus string

// CreateBlogPostJSONBody defines parameters for CreateBlogPost.
type CreateBlogPostJSONBody struct {
	Body *BlogPostBodyWrite `json:"body,omitempty"`

	// SpaceId ID of the space
	SpaceId string `json:"spaceId"`

	// Status The status of the blog post, specifies if the blog post will be created as a new blog post or a draft
	Status *string `json:"status,omitempty"`

	// Title Title of the blog post, required if creating non-draft.
	Title *string `json:"title,omitempty"`
}

// CreateBlogPostParams defines parameters for CreateBlogPost.
type CreateBlogPostParams struct {
	// Private The blog post will be private. Only the user who creates this blog post will have permission to view and edit one.
	Private *bool `form:"private,omitempty" json:"private,omitempty"`
}

// GetBlogpostContentPropertiesParams defines parameters for GetBlogpostContentProperties.
type GetBlogpostContentPropertiesParams struct {
	// Key Filters the response to return a specific content property with matching key (case sensitive).
	Key *string `form:"key,omitempty" json:"key,omitempty"`

	// Sort Used to sort the result by a particular field.
	Sort *ContentPropertySortOrder `form:"sort,omitempty" json:"sort,omitempty"`

	// Cursor Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit Maximum number of attachments per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// DeleteBlogPostParams defines parameters for DeleteBlogPost.
type DeleteBlogPostParams struct {
	// Purge If attempting to purge the blog post.
	Purge *bool `form:"purge,omitempty" json:"purge,omitempty"`

	// Draft If attempting to delete a blog post that is a draft.
	Draft *bool `form:"draft,omitempty" json:"draft,omitempty"`
}

// GetBlogPostByIdParams defines parameters for GetBlogPostById.
type GetBlogPostByIdParams struct {
	// BodyFormat The content format types to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.
	BodyFormat *PrimaryBodyRepresentationSingle `form:"body-format,omitempty" json:"body-format,omitempty"`

	// GetDraft Retrieve the draft version of this blog post.
	GetDraft *bool `form:"get-draft,omitempty" json:"get-draft,omitempty"`

	// Status Filter the blog post being retrieved by its status.
	Status *[]GetBlogPostByIdParamsStatus `form:"status,omitempty" json:"status,omitempty"`

	// Version Allows you to retrieve a previously published version. Specify the previous version's number to retrieve its details.
	Version *int `form:"version,omitempty" json:"version,omitempty"`

	// IncludeLabels Includes labels associated with this blog post in the response.
	// The number of results will be limited to 50 and sorted in the default sort order.
	// A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.
	IncludeLabels *bool `form:"include-labels,omitempty" json:"include-labels,omitempty"`

	// IncludeProperties Includes content properties associated with this blog post in the response.
	// The number of results will be limited to 50 and sorted in the default sort order.
	// A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.
	IncludeProperties *bool `form:"include-properties,omitempty" json:"include-properties,omitempty"`

	// IncludeOperations Includes operations associated with this blog post in the response.
	// The number of results will be limited to 50 and sorted in the default sort order.
	// A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.
	IncludeOperations *bool `form:"include-operations,omitempty" json:"include-operations,omitempty"`

	// IncludeLikes Includes likes associated with this blog post in the response.
	// The number of results will be limited to 50 and sorted in the default sort order.
	// A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.
	IncludeLikes *bool `form:"include-likes,omitempty" json:"include-likes,omitempty"`

	// IncludeVersions Includes versions associated with this blog post in the response.
	// The number of results will be limited to 50 and sorted in the default sort order.
	// A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.
	IncludeVersions *bool `form:"include-versions,omitempty" json:"include-versions,omitempty"`

	// IncludeVersion Includes the current version associated with this blog post in the response.
	// By default this is included and can be omitted by setting the value to `false`.
	IncludeVersion *bool `form:"include-version,omitempty" json:"include-version,omitempty"`

	// IncludeFavoritedByCurrentUserStatus Includes whether this blog post has been favorited by the current user.
	IncludeFavoritedByCurrentUserStatus *bool `form:"include-favorited-by-current-user-status,omitempty" json:"include-favorited-by-current-user-status,omitempty"`
}

// GetBlogPostByIdParamsStatus defines parameters for GetBlogPostById.
type GetBlogPostByIdParamsStatus string

// UpdateBlogPostJSONBody defines parameters for UpdateBlogPost.
type UpdateBlogPostJSONBody struct {
	Body BlogPostBodyWrite `json:"body"`

	// Id Id of the blog post.
	Id string `json:"id"`

	// SpaceId ID of the containing space.
	//
	// This currently **does not support moving the blog post to a different space**.
	SpaceId *string `json:"spaceId,omitempty"`

	// Status The updated status of the blog post.
	//
	// Note, if you change the status of a blog post from 'current' to 'draft' and it has an existing draft, the existing draft will be deleted in favor of the updated draft.
	// Additionally, this endpoint can be used to restore a 'trashed' or 'deleted' blog post to 'current' status. For restoration, blog post contents will not be updated and only the blog post status will be changed.
	Status string `json:"status"`

	// Title Title of the blog post.
	Title   string `json:"title"`
	Version struct {
		// Message An optional message to be stored with the version.
		Message *string `json:"message,omitempty"`

		// Number The new version number of the updated blog post.
		// Set this to the current version number plus one, unless you are updating the status to 'draft' which requires a version number of 1.
		//
		// If you don't know the current version number, use Get blog post by id.
		Number *int32 `json:"number,omitempty"`
	} `json:"version"`
}

// GetBlogpostAttachmentsParams defines parameters for GetBlogpostAttachments.
type GetBlogpostAttachmentsParams struct {
	// Sort Used to sort the result by a particular field.
	Sort *AttachmentSortOrder `form:"sort,omitempty" json:"sort,omitempty"`

	// Cursor Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Status Filter the results to attachments based on their status. By default, `current` and `archived` are used.
	Status *[]GetBlogpostAttachmentsParamsStatus `form:"status,omitempty" json:"status,omitempty"`

	// MediaType Filters on the mediaType of attachments. Only one may be specified.
	MediaType *string `form:"mediaType,omitempty" json:"mediaType,omitempty"`

	// Filename Filters on the file-name of attachments. Only one may be specified.
	Filename *string `form:"filename,omitempty" json:"filename,omitempty"`

	// Limit Maximum number of attachments per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetBlogpostAttachmentsParamsStatus defines parameters for GetBlogpostAttachments.
type GetBlogpostAttachmentsParamsStatus string

// GetBlogPostClassificationLevelParams defines parameters for GetBlogPostClassificationLevel.
type GetBlogPostClassificationLevelParams struct {
	// Status Status of blog post from which classification level will fetched.
	Status *GetBlogPostClassificationLevelParamsStatus `form:"status,omitempty" json:"status,omitempty"`
}

// GetBlogPostClassificationLevelParamsStatus defines parameters for GetBlogPostClassificationLevel.
type GetBlogPostClassificationLevelParamsStatus string

// PutBlogPostClassificationLevelJSONBody defines parameters for PutBlogPostClassificationLevel.
type PutBlogPostClassificationLevelJSONBody struct {
	// Id The ID of the classification level.
	Id string `json:"id"`

	// Status Status of the content.
	Status string `json:"status"`
}

// PostBlogPostClassificationLevelJSONBody defines parameters for PostBlogPostClassificationLevel.
type PostBlogPostClassificationLevelJSONBody struct {
	// Status Status of the content.
	Status string `json:"status"`
}

// GetCustomContentByTypeInBlogPostParams defines parameters for GetCustomContentByTypeInBlogPost.
type GetCustomContentByTypeInBlogPostParams struct {
	// Type The type of custom content being requested. See: https://developer.atlassian.com/cloud/confluence/custom-content/ for additional details on custom content.
	Type string `form:"type" json:"type"`

	// Sort Used to sort the result by a particular field.
	Sort *CustomContentSortOrder `form:"sort,omitempty" json:"sort,omitempty"`

	// Cursor Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit Maximum number of pages per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// BodyFormat The content format types to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.
	//
	// Note: If the custom content body type is `storage`, the `storage` and `atlas_doc_format` body formats are able to be returned. If the custom content body type is `raw`, only the `raw` body format is able to be returned.
	BodyFormat *CustomContentBodyRepresentation `form:"body-format,omitempty" json:"body-format,omitempty"`
}

// GetBlogPostFooterCommentsParams defines parameters for GetBlogPostFooterComments.
type GetBlogPostFooterCommentsParams struct {
	// BodyFormat The content format type to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.
	BodyFormat *PrimaryBodyRepresentation `form:"body-format,omitempty" json:"body-format,omitempty"`

	// Status Filter the footer comment being retrieved by its status.
	Status *[]GetBlogPostFooterCommentsParamsStatus `form:"status,omitempty" json:"status,omitempty"`

	// Sort Used to sort the result by a particular field.
	Sort *CommentSortOrder `form:"sort,omitempty" json:"sort,omitempty"`

	// Cursor Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit Maximum number of footer comments per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetBlogPostFooterCommentsParamsStatus defines parameters for GetBlogPostFooterComments.
type GetBlogPostFooterCommentsParamsStatus string

// GetBlogPostInlineCommentsParams defines parameters for GetBlogPostInlineComments.
type GetBlogPostInlineCommentsParams struct {
	// BodyFormat The content format type to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.
	BodyFormat *PrimaryBodyRepresentation `form:"body-format,omitempty" json:"body-format,omitempty"`

	// Status Filter the inline comment being retrieved by its status.
	Status *[]GetBlogPostInlineCommentsParamsStatus `form:"status,omitempty" json:"status,omitempty"`

	// ResolutionStatus Filter the inline comment being retrieved by its resolution status.
	ResolutionStatus *[]GetBlogPostInlineCommentsParamsResolutionStatus `form:"resolution-status,omitempty" json:"resolution-status,omitempty"`

	// Sort Used to sort the result by a particular field.
	Sort *CommentSortOrder `form:"sort,omitempty" json:"sort,omitempty"`

	// Cursor Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit Maximum number of inline comments per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetBlogPostInlineCommentsParamsStatus defines parameters for GetBlogPostInlineComments.
type GetBlogPostInlineCommentsParamsStatus string

// GetBlogPostInlineCommentsParamsResolutionStatus defines parameters for GetBlogPostInlineComments.
type GetBlogPostInlineCommentsParamsResolutionStatus string

// GetBlogPostLabelsParams defines parameters for GetBlogPostLabels.
type GetBlogPostLabelsParams struct {
	// Prefix Filter the results to labels based on their prefix.
	Prefix *GetBlogPostLabelsParamsPrefix `form:"prefix,omitempty" json:"prefix,omitempty"`

	// Sort Used to sort the result by a particular field.
	Sort *string `form:"sort,omitempty" json:"sort,omitempty"`

	// Cursor Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit Maximum number of labels per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetBlogPostLabelsParamsPrefix defines parameters for GetBlogPostLabels.
type GetBlogPostLabelsParamsPrefix string

// GetBlogPostLikeUsersParams defines parameters for GetBlogPostLikeUsers.
type GetBlogPostLikeUsersParams struct {
	// Cursor Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit Maximum number of account IDs per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetBlogPostVersionsParams defines parameters for GetBlogPostVersions.
type GetBlogPostVersionsParams struct {
	// BodyFormat The content format types to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.
	BodyFormat *PrimaryBodyRepresentation `form:"body-format,omitempty" json:"body-format,omitempty"`

	// Cursor Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit Maximum number of versions per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Sort Used to sort the result by a particular field.
	Sort *VersionSortOrder `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetCommentContentPropertiesParams defines parameters for GetCommentContentProperties.
type GetCommentContentPropertiesParams struct {
	// Key Filters the response to return a specific content property with matching key (case sensitive).
	Key *string `form:"key,omitempty" json:"key,omitempty"`

	// Sort Used to sort the result by a particular field.
	Sort *ContentPropertySortOrder `form:"sort,omitempty" json:"sort,omitempty"`

	// Cursor Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit Maximum number of attachments per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// ConvertContentIdsToContentTypesJSONBody defines parameters for ConvertContentIdsToContentTypes.
type ConvertContentIdsToContentTypesJSONBody struct {
	// ContentIds The content ids to convert. They may be provided as strings or numbers.
	ContentIds []string `json:"contentIds"`
}

// GetCustomContentByTypeParams defines parameters for GetCustomContentByType.
type GetCustomContentByTypeParams struct {
	// Type The type of custom content being requested. See: https://developer.atlassian.com/cloud/confluence/custom-content/ for additional details on custom content.
	Type string `form:"type" json:"type"`

	// Id Filter the results based on custom content ids. Multiple custom content ids can be specified as a comma-separated list.
	Id *[]int64 `form:"id,omitempty" json:"id,omitempty"`

	// SpaceId Filter the results based on space ids. Multiple space ids can be specified as a comma-separated list.
	SpaceId *[]int64 `form:"space-id,omitempty" json:"space-id,omitempty"`

	// Sort Used to sort the result by a particular field.
	Sort *CustomContentSortOrder `form:"sort,omitempty" json:"sort,omitempty"`

	// Cursor Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit Maximum number of pages per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// BodyFormat The content format types to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.
	//
	// Note: If the custom content body type is `storage`, the `storage` and `atlas_doc_format` body formats are able to be returned. If the custom content body type is `raw`, only the `raw` body format is able to be returned.
	BodyFormat *CustomContentBodyRepresentation `form:"body-format,omitempty" json:"body-format,omitempty"`
}

// CreateCustomContentJSONBody defines parameters for CreateCustomContent.
type CreateCustomContentJSONBody struct {
	// BlogPostId ID of the containing Blog Post.
	BlogPostId *string                `json:"blogPostId,omitempty"`
	Body       CustomContentBodyWrite `json:"body"`

	// CustomContentId ID of the containing custom content.
	CustomContentId *string `json:"customContentId,omitempty"`

	// PageId ID of the containing page.
	PageId *string `json:"pageId,omitempty"`

	// SpaceId ID of the containing space.
	SpaceId *string `json:"spaceId,omitempty"`

	// Status The status of the custom content.
	Status *string `json:"status,omitempty"`

	// Title Title of the custom content.
	Title string `json:"title"`

	// Type Type of custom content.
	Type string `json:"type"`
}

// GetCustomContentContentPropertiesParams defines parameters for GetCustomContentContentProperties.
type GetCustomContentContentPropertiesParams struct {
	// Key Filters the response to return a specific content property with matching key (case sensitive).
	Key *string `form:"key,omitempty" json:"key,omitempty"`

	// Sort Used to sort the result by a particular field.
	Sort *ContentPropertySortOrder `form:"sort,omitempty" json:"sort,omitempty"`

	// Cursor Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit Maximum number of attachments per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetCustomContentVersionsParams defines parameters for GetCustomContentVersions.
type GetCustomContentVersionsParams struct {
	// BodyFormat The content format types to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.
	//
	// Note: If the custom content body type is `storage`, the `storage` and `atlas_doc_format` body formats are able to be returned. If the custom content body type is `raw`, only the `raw` body format is able to be returned.
	BodyFormat *CustomContentBodyRepresentation `form:"body-format,omitempty" json:"body-format,omitempty"`

	// Cursor Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit Maximum number of versions per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Sort Used to sort the result by a particular field.
	Sort *VersionSortOrder `form:"sort,omitempty" json:"sort,omitempty"`
}

// DeleteCustomContentParams defines parameters for DeleteCustomContent.
type DeleteCustomContentParams struct {
	// Purge If attempting to purge the custom content.
	Purge *bool `form:"purge,omitempty" json:"purge,omitempty"`
}

// GetCustomContentByIdParams defines parameters for GetCustomContentById.
type GetCustomContentByIdParams struct {
	// BodyFormat The content format types to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.
	//
	// Note: If the custom content body type is `storage`, the `storage` and `atlas_doc_format` body formats are able to be returned. If the custom content body type is `raw`, only the `raw` body format is able to be returned.
	BodyFormat *CustomContentBodyRepresentationSingle `form:"body-format,omitempty" json:"body-format,omitempty"`

	// Version Allows you to retrieve a previously published version. Specify the previous version's number to retrieve its details.
	Version *int `form:"version,omitempty" json:"version,omitempty"`

	// IncludeLabels Includes labels associated with this custom content in the response.
	// The number of results will be limited to 50 and sorted in the default sort order.
	// A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.
	IncludeLabels *bool `form:"include-labels,omitempty" json:"include-labels,omitempty"`

	// IncludeProperties Includes content properties associated with this custom content in the response.
	// The number of results will be limited to 50 and sorted in the default sort order.
	// A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.
	IncludeProperties *bool `form:"include-properties,omitempty" json:"include-properties,omitempty"`

	// IncludeOperations Includes operations associated with this custom content in the response.
	// The number of results will be limited to 50 and sorted in the default sort order.
	// A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.
	IncludeOperations *bool `form:"include-operations,omitempty" json:"include-operations,omitempty"`

	// IncludeVersions Includes versions associated with this custom content in the response.
	// The number of results will be limited to 50 and sorted in the default sort order.
	// A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.
	IncludeVersions *bool `form:"include-versions,omitempty" json:"include-versions,omitempty"`

	// IncludeVersion Includes the current version associated with this custom content in the response.
	// By default this is included and can be omitted by setting the value to `false`.
	IncludeVersion *bool `form:"include-version,omitempty" json:"include-version,omitempty"`
}

// UpdateCustomContentJSONBody defines parameters for UpdateCustomContent.
type UpdateCustomContentJSONBody struct {
	// BlogPostId ID of the containing Blog Post.
	BlogPostId *string                `json:"blogPostId,omitempty"`
	Body       CustomContentBodyWrite `json:"body"`

	// CustomContentId ID of the containing custom content.
	CustomContentId *string `json:"customContentId,omitempty"`

	// Id Id of custom content.
	Id string `json:"id"`

	// PageId ID of the containing page.
	PageId *string `json:"pageId,omitempty"`

	// SpaceId ID of the containing space.
	SpaceId *string `json:"spaceId,omitempty"`

	// Status The status of the custom content.
	Status string `json:"status"`

	// Title Title of the custom content.
	Title string `json:"title"`

	// Type Type of custom content.
	Type    string `json:"type"`
	Version struct {
		// Message An optional message to be stored with the version.
		Message *string `json:"message,omitempty"`

		// Number The version number, must be incremented by one.
		Number *int32 `json:"number,omitempty"`
	} `json:"version"`
}

// GetCustomContentAttachmentsParams defines parameters for GetCustomContentAttachments.
type GetCustomContentAttachmentsParams struct {
	// Sort Used to sort the result by a particular field.
	Sort *AttachmentSortOrder `form:"sort,omitempty" json:"sort,omitempty"`

	// Cursor Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Status Filter the results to attachments based on their status. By default, `current` and `archived` are used.
	Status *[]GetCustomContentAttachmentsParamsStatus `form:"status,omitempty" json:"status,omitempty"`

	// MediaType Filters on the mediaType of attachments. Only one may be specified.
	MediaType *string `form:"mediaType,omitempty" json:"mediaType,omitempty"`

	// Filename Filters on the file-name of attachments. Only one may be specified.
	Filename *string `form:"filename,omitempty" json:"filename,omitempty"`

	// Limit Maximum number of attachments per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetCustomContentAttachmentsParamsStatus defines parameters for GetCustomContentAttachments.
type GetCustomContentAttachmentsParamsStatus string

// GetChildCustomContentParams defines parameters for GetChildCustomContent.
type GetChildCustomContentParams struct {
	// Cursor Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit Maximum number of pages per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Sort Used to sort the result by a particular field.
	Sort *string `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetCustomContentCommentsParams defines parameters for GetCustomContentComments.
type GetCustomContentCommentsParams struct {
	// BodyFormat The content format type to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.
	BodyFormat *PrimaryBodyRepresentation `form:"body-format,omitempty" json:"body-format,omitempty"`

	// Cursor Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit Maximum number of comments per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Sort Used to sort the result by a particular field.
	Sort *CommentSortOrder `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetCustomContentLabelsParams defines parameters for GetCustomContentLabels.
type GetCustomContentLabelsParams struct {
	// Prefix Filter the results to labels based on their prefix.
	Prefix *GetCustomContentLabelsParamsPrefix `form:"prefix,omitempty" json:"prefix,omitempty"`

	// Sort Used to sort the result by a particular field.
	Sort *string `form:"sort,omitempty" json:"sort,omitempty"`

	// Cursor Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit Maximum number of labels per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetCustomContentLabelsParamsPrefix defines parameters for GetCustomContentLabels.
type GetCustomContentLabelsParamsPrefix string

// GetDataPolicySpacesParams defines parameters for GetDataPolicySpaces.
type GetDataPolicySpacesParams struct {
	// Ids Filter the results to spaces based on their IDs. Multiple IDs can be specified as a comma-separated list.
	Ids *[]int64 `form:"ids,omitempty" json:"ids,omitempty"`

	// Keys Filter the results to spaces based on their keys. Multiple keys can be specified as a comma-separated list.
	Keys *[]string `form:"keys,omitempty" json:"keys,omitempty"`

	// Sort Used to sort the result by a particular field.
	Sort *SpaceSortOrder `form:"sort,omitempty" json:"sort,omitempty"`

	// Cursor Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit Maximum number of spaces per result to return. If more results exist, use the `Link` response header to retrieve a relative URL that will return the next set of results.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// CreateDatabaseJSONBody defines parameters for CreateDatabase.
type CreateDatabaseJSONBody struct {
	// ParentId The parent content ID of the database.
	ParentId *string `json:"parentId,omitempty"`

	// SpaceId ID of the space.
	SpaceId string `json:"spaceId"`

	// Title Title of the database.
	Title *string `json:"title,omitempty"`
}

// CreateDatabaseParams defines parameters for CreateDatabase.
type CreateDatabaseParams struct {
	// Private The database will be private. Only the user who creates this database will have permission to view and edit one.
	Private *bool `form:"private,omitempty" json:"private,omitempty"`
}

// GetDatabaseAncestorsParams defines parameters for GetDatabaseAncestors.
type GetDatabaseAncestorsParams struct {
	// Limit Maximum number of items per result to return. If more results exist, call the endpoint with the highest ancestor's ID to fetch the next set of results.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// PutDatabaseClassificationLevelJSONBody defines parameters for PutDatabaseClassificationLevel.
type PutDatabaseClassificationLevelJSONBody struct {
	// Id The ID of the classification level.
	Id string `json:"id"`

	// Status Status of the content.
	Status string `json:"status"`
}

// PostDatabaseClassificationLevelJSONBody defines parameters for PostDatabaseClassificationLevel.
type PostDatabaseClassificationLevelJSONBody struct {
	// Status Status of the content.
	Status string `json:"status"`
}

// GetDatabaseContentPropertiesParams defines parameters for GetDatabaseContentProperties.
type GetDatabaseContentPropertiesParams struct {
	// Key Filters the response to return a specific content property with matching key (case sensitive).
	Key *string `form:"key,omitempty" json:"key,omitempty"`

	// Sort Used to sort the result by a particular field.
	Sort *ContentPropertySortOrder `form:"sort,omitempty" json:"sort,omitempty"`

	// Cursor Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit Maximum number of attachments per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// CreateSmartLinkJSONBody defines parameters for CreateSmartLink.
type CreateSmartLinkJSONBody struct {
	// EmbedUrl The URL that the Smart Link in the content tree should be populated with.
	EmbedUrl *string `json:"embedUrl,omitempty"`

	// ParentId The parent content ID of the Smart Link in the content tree.
	ParentId *string `json:"parentId,omitempty"`

	// SpaceId ID of the space.
	SpaceId string `json:"spaceId"`

	// Title Title of the Smart Link in the content tree.
	Title *string `json:"title,omitempty"`
}

// GetSmartLinkAncestorsParams defines parameters for GetSmartLinkAncestors.
type GetSmartLinkAncestorsParams struct {
	// Limit Maximum number of items per result to return. If more results exist, call the endpoint with the highest ancestor's ID to fetch the next set of results.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetSmartLinkContentPropertiesParams defines parameters for GetSmartLinkContentProperties.
type GetSmartLinkContentPropertiesParams struct {
	// Key Filters the response to return a specific content property with matching key (case sensitive).
	Key *string `form:"key,omitempty" json:"key,omitempty"`

	// Sort Used to sort the result by a particular field.
	Sort *ContentPropertySortOrder `form:"sort,omitempty" json:"sort,omitempty"`

	// Cursor Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit Maximum number of attachments per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// CreateFolderJSONBody defines parameters for CreateFolder.
type CreateFolderJSONBody struct {
	// ParentId The parent content ID of the folder.
	ParentId *string `json:"parentId,omitempty"`

	// SpaceId ID of the space.
	SpaceId string `json:"spaceId"`

	// Title Title of the folder.
	Title *string `json:"title,omitempty"`
}

// GetFolderAncestorsParams defines parameters for GetFolderAncestors.
type GetFolderAncestorsParams struct {
	// Limit Maximum number of items per result to return. If more results exist, call the endpoint with the highest ancestor's ID to fetch the next set of results.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetFolderContentPropertiesParams defines parameters for GetFolderContentProperties.
type GetFolderContentPropertiesParams struct {
	// Key Filters the response to return a specific content property with matching key (case sensitive).
	Key *string `form:"key,omitempty" json:"key,omitempty"`

	// Sort Used to sort the result by a particular field.
	Sort *ContentPropertySortOrder `form:"sort,omitempty" json:"sort,omitempty"`

	// Cursor Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit Maximum number of attachments per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetFooterCommentsParams defines parameters for GetFooterComments.
type GetFooterCommentsParams struct {
	// BodyFormat The content format type to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.
	BodyFormat *PrimaryBodyRepresentation `form:"body-format,omitempty" json:"body-format,omitempty"`

	// Sort Used to sort the result by a particular field.
	Sort *CommentSortOrder `form:"sort,omitempty" json:"sort,omitempty"`

	// Cursor Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit Maximum number of footer comments per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetFooterCommentByIdParams defines parameters for GetFooterCommentById.
type GetFooterCommentByIdParams struct {
	// BodyFormat The content format type to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.
	BodyFormat *PrimaryBodyRepresentationSingle `form:"body-format,omitempty" json:"body-format,omitempty"`

	// Version Allows you to retrieve a previously published version. Specify the previous version's number to retrieve its details.
	Version *int `form:"version,omitempty" json:"version,omitempty"`

	// IncludeProperties Includes content properties associated with this footer comment in the response.
	// The number of results will be limited to 50 and sorted in the default sort order.
	// A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.
	IncludeProperties *bool `form:"include-properties,omitempty" json:"include-properties,omitempty"`

	// IncludeOperations Includes operations associated with this footer comment in the response.
	// The number of results will be limited to 50 and sorted in the default sort order.
	// A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.
	IncludeOperations *bool `form:"include-operations,omitempty" json:"include-operations,omitempty"`

	// IncludeLikes Includes likes associated with this footer comment in the response.
	// The number of results will be limited to 50 and sorted in the default sort order.
	// A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.
	IncludeLikes *bool `form:"include-likes,omitempty" json:"include-likes,omitempty"`

	// IncludeVersions Includes versions associated with this footer comment in the response.
	// The number of results will be limited to 50 and sorted in the default sort order.
	// A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.
	IncludeVersions *bool `form:"include-versions,omitempty" json:"include-versions,omitempty"`

	// IncludeVersion Includes the current version associated with this footer comment in the response.
	// By default this is included and can be omitted by setting the value to `false`.
	IncludeVersion *bool `form:"include-version,omitempty" json:"include-version,omitempty"`
}

// UpdateFooterCommentJSONBody defines parameters for UpdateFooterComment.
type UpdateFooterCommentJSONBody struct {
	Links *struct {
		// Base Base url of the Confluence site.
		Base *string `json:"base,omitempty"`
	} `json:"_links,omitempty"`
	Body    *CommentBodyWrite `json:"body,omitempty"`
	Version *struct {
		// Message Optional message store for the new version.
		Message *string `json:"message,omitempty"`

		// Number Number of new version. Should be 1 higher than current version of the comment.
		Number *int `json:"number,omitempty"`
	} `json:"version,omitempty"`
}

// GetFooterCommentChildrenParams defines parameters for GetFooterCommentChildren.
type GetFooterCommentChildrenParams struct {
	// BodyFormat The content format type to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.
	BodyFormat *PrimaryBodyRepresentation `form:"body-format,omitempty" json:"body-format,omitempty"`

	// Sort Used to sort the result by a particular field.
	Sort *CommentSortOrder `form:"sort,omitempty" json:"sort,omitempty"`

	// Cursor Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit Maximum number of footer comments per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetFooterLikeUsersParams defines parameters for GetFooterLikeUsers.
type GetFooterLikeUsersParams struct {
	// Cursor Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit Maximum number of account IDs per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetFooterCommentVersionsParams defines parameters for GetFooterCommentVersions.
type GetFooterCommentVersionsParams struct {
	// BodyFormat The content format types to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.
	BodyFormat *PrimaryBodyRepresentation `form:"body-format,omitempty" json:"body-format,omitempty"`

	// Cursor Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit Maximum number of versions per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Sort Used to sort the result by a particular field.
	Sort *VersionSortOrder `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetInlineCommentsParams defines parameters for GetInlineComments.
type GetInlineCommentsParams struct {
	// BodyFormat The content format type to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.
	BodyFormat *PrimaryBodyRepresentation `form:"body-format,omitempty" json:"body-format,omitempty"`

	// Sort Used to sort the result by a particular field.
	Sort *CommentSortOrder `form:"sort,omitempty" json:"sort,omitempty"`

	// Cursor Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit Maximum number of footer comments per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetInlineCommentByIdParams defines parameters for GetInlineCommentById.
type GetInlineCommentByIdParams struct {
	// BodyFormat The content format type to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.
	BodyFormat *PrimaryBodyRepresentationSingle `form:"body-format,omitempty" json:"body-format,omitempty"`

	// Version Allows you to retrieve a previously published version. Specify the previous version's number to retrieve its details.
	Version *int `form:"version,omitempty" json:"version,omitempty"`

	// IncludeProperties Includes content properties associated with this inline comment in the response.
	// The number of results will be limited to 50 and sorted in the default sort order.
	// A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.
	IncludeProperties *bool `form:"include-properties,omitempty" json:"include-properties,omitempty"`

	// IncludeOperations Includes operations associated with this inline comment in the response.
	// The number of results will be limited to 50 and sorted in the default sort order.
	// A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.
	IncludeOperations *bool `form:"include-operations,omitempty" json:"include-operations,omitempty"`

	// IncludeLikes Includes likes associated with this inline comment in the response.
	// The number of results will be limited to 50 and sorted in the default sort order.
	// A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.
	IncludeLikes *bool `form:"include-likes,omitempty" json:"include-likes,omitempty"`

	// IncludeVersions Includes versions associated with this inline comment in the response.
	// The number of results will be limited to 50 and sorted in the default sort order.
	// A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.
	IncludeVersions *bool `form:"include-versions,omitempty" json:"include-versions,omitempty"`

	// IncludeVersion Includes the current version associated with this inline comment in the response.
	// By default this is included and can be omitted by setting the value to `false`.
	IncludeVersion *bool `form:"include-version,omitempty" json:"include-version,omitempty"`
}

// GetInlineCommentChildrenParams defines parameters for GetInlineCommentChildren.
type GetInlineCommentChildrenParams struct {
	// BodyFormat The content format type to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.
	BodyFormat *PrimaryBodyRepresentation `form:"body-format,omitempty" json:"body-format,omitempty"`

	// Sort Used to sort the result by a particular field.
	Sort *CommentSortOrder `form:"sort,omitempty" json:"sort,omitempty"`

	// Cursor Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit Maximum number of footer comments per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetInlineLikeUsersParams defines parameters for GetInlineLikeUsers.
type GetInlineLikeUsersParams struct {
	// Cursor Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit Maximum number of account IDs per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetInlineCommentVersionsParams defines parameters for GetInlineCommentVersions.
type GetInlineCommentVersionsParams struct {
	// BodyFormat The content format types to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.
	BodyFormat *PrimaryBodyRepresentation `form:"body-format,omitempty" json:"body-format,omitempty"`

	// Cursor Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit Maximum number of versions per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Sort Used to sort the result by a particular field.
	Sort *VersionSortOrder `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetLabelsParams defines parameters for GetLabels.
type GetLabelsParams struct {
	// LabelId Filters on label ID. Multiple IDs can be specified as a comma-separated list.
	LabelId *[]int64 `form:"label-id,omitempty" json:"label-id,omitempty"`

	// Prefix Filters on label prefix. Multiple IDs can be specified as a comma-separated list.
	Prefix *[]string `form:"prefix,omitempty" json:"prefix,omitempty"`

	// Cursor Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Sort Used to sort the result by a particular field.
	Sort *string `form:"sort,omitempty" json:"sort,omitempty"`

	// Limit Maximum number of labels per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetLabelAttachmentsParams defines parameters for GetLabelAttachments.
type GetLabelAttachmentsParams struct {
	// Sort Used to sort the result by a particular field.
	Sort *AttachmentSortOrder `form:"sort,omitempty" json:"sort,omitempty"`

	// Cursor Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit Maximum number of pages per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetLabelBlogPostsParams defines parameters for GetLabelBlogPosts.
type GetLabelBlogPostsParams struct {
	// SpaceId Filter the results based on space ids. Multiple space ids can be specified as a comma-separated list.
	SpaceId *[]int64 `form:"space-id,omitempty" json:"space-id,omitempty"`

	// BodyFormat The content format types to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.
	BodyFormat *PrimaryBodyRepresentation `form:"body-format,omitempty" json:"body-format,omitempty"`

	// Sort Used to sort the result by a particular field.
	Sort *BlogPostSortOrder `form:"sort,omitempty" json:"sort,omitempty"`

	// Cursor Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit Maximum number of blog posts per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetLabelPagesParams defines parameters for GetLabelPages.
type GetLabelPagesParams struct {
	// SpaceId Filter the results based on space ids. Multiple space ids can be specified as a comma-separated list.
	SpaceId *[]int64 `form:"space-id,omitempty" json:"space-id,omitempty"`

	// BodyFormat The content format types to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.
	BodyFormat *PrimaryBodyRepresentation `form:"body-format,omitempty" json:"body-format,omitempty"`

	// Sort Used to sort the result by a particular field.
	Sort *PageSortOrder `form:"sort,omitempty" json:"sort,omitempty"`

	// Cursor Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit Maximum number of pages per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetPagesParams defines parameters for GetPages.
type GetPagesParams struct {
	// Id Filter the results based on page ids. Multiple page ids can be specified as a comma-separated list.
	Id *[]int64 `form:"id,omitempty" json:"id,omitempty"`

	// SpaceId Filter the results based on space ids. Multiple space ids can be specified as a comma-separated list.
	SpaceId *[]int64 `form:"space-id,omitempty" json:"space-id,omitempty"`

	// Sort Used to sort the result by a particular field.
	Sort *PageSortOrder `form:"sort,omitempty" json:"sort,omitempty"`

	// Status Filter the results to pages based on their status. By default, `current` and `archived` are used.
	Status *[]GetPagesParamsStatus `form:"status,omitempty" json:"status,omitempty"`

	// Title Filter the results to pages based on their title.
	Title *string `form:"title,omitempty" json:"title,omitempty"`

	// BodyFormat The content format types to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.
	BodyFormat *PrimaryBodyRepresentation `form:"body-format,omitempty" json:"body-format,omitempty"`

	// Cursor Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit Maximum number of pages per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetPagesParamsStatus defines parameters for GetPages.
type GetPagesParamsStatus string

// CreatePageJSONBody defines parameters for CreatePage.
type CreatePageJSONBody struct {
	Body *PageBodyWrite `json:"body,omitempty"`

	// ParentId The parent content ID of the page. If the `root-level` query parameter is set to false and a value is
	// not supplied for this parameter, then the space homepage's ID will be used. If the `root-level` query
	// parameter is set to true, then a value may not be supplied for this parameter.
	ParentId *string `json:"parentId,omitempty"`

	// SpaceId ID of the space.
	SpaceId string `json:"spaceId"`

	// Status The status of the page, published or draft.
	Status *string `json:"status,omitempty"`

	// Title Title of the page, required if page status is not draft.
	Title *string `json:"title,omitempty"`
}

// CreatePageParams defines parameters for CreatePage.
type CreatePageParams struct {
	// Embedded Tag the content as embedded and content will be created in NCS.
	Embedded *bool `form:"embedded,omitempty" json:"embedded,omitempty"`

	// Private The page will be private. Only the user who creates this page will have permission to view and edit one.
	Private *bool `form:"private,omitempty" json:"private,omitempty"`

	// RootLevel The page will be created at the root level of the space (outside the space homepage tree). If true, then a
	// value may not be supplied for the `parentId` body parameter.
	RootLevel *bool `form:"root-level,omitempty" json:"root-level,omitempty"`
}

// DeletePageParams defines parameters for DeletePage.
type DeletePageParams struct {
	// Purge If attempting to purge the page.
	Purge *bool `form:"purge,omitempty" json:"purge,omitempty"`

	// Draft If attempting to delete a page that is a draft.
	Draft *bool `form:"draft,omitempty" json:"draft,omitempty"`
}

// GetPageByIdParams defines parameters for GetPageById.
type GetPageByIdParams struct {
	// BodyFormat The content format types to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.
	BodyFormat *PrimaryBodyRepresentationSingle `form:"body-format,omitempty" json:"body-format,omitempty"`

	// GetDraft Retrieve the draft version of this page.
	GetDraft *bool `form:"get-draft,omitempty" json:"get-draft,omitempty"`

	// Status Filter the page being retrieved by its status.
	Status *[]GetPageByIdParamsStatus `form:"status,omitempty" json:"status,omitempty"`

	// Version Allows you to retrieve a previously published version. Specify the previous version's number to retrieve its details.
	Version *int `form:"version,omitempty" json:"version,omitempty"`

	// IncludeLabels Includes labels associated with this page in the response.
	// The number of results will be limited to 50 and sorted in the default sort order.
	// A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.
	IncludeLabels *bool `form:"include-labels,omitempty" json:"include-labels,omitempty"`

	// IncludeProperties Includes content properties associated with this page in the response.
	// The number of results will be limited to 50 and sorted in the default sort order.
	// A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.
	IncludeProperties *bool `form:"include-properties,omitempty" json:"include-properties,omitempty"`

	// IncludeOperations Includes operations associated with this page in the response.
	// The number of results will be limited to 50 and sorted in the default sort order.
	// A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.
	IncludeOperations *bool `form:"include-operations,omitempty" json:"include-operations,omitempty"`

	// IncludeLikes Includes likes associated with this page in the response.
	// The number of results will be limited to 50 and sorted in the default sort order.
	// A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.
	IncludeLikes *bool `form:"include-likes,omitempty" json:"include-likes,omitempty"`

	// IncludeVersions Includes versions associated with this page in the response.
	// The number of results will be limited to 50 and sorted in the default sort order.
	// A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.
	IncludeVersions *bool `form:"include-versions,omitempty" json:"include-versions,omitempty"`

	// IncludeVersion Includes the current version associated with this page in the response.
	// By default this is included and can be omitted by setting the value to `false`.
	IncludeVersion *bool `form:"include-version,omitempty" json:"include-version,omitempty"`

	// IncludeFavoritedByCurrentUserStatus Includes whether this page has been favorited by the current user.
	IncludeFavoritedByCurrentUserStatus *bool `form:"include-favorited-by-current-user-status,omitempty" json:"include-favorited-by-current-user-status,omitempty"`
}

// GetPageByIdParamsStatus defines parameters for GetPageById.
type GetPageByIdParamsStatus string

// UpdatePageJSONBody defines parameters for UpdatePage.
type UpdatePageJSONBody struct {
	Body PageBodyWrite `json:"body"`

	// Id Id of the page.
	Id string `json:"id"`

	// OwnerId Account ID of the page owner.
	//
	// This allows page ownership to be transferred to another user.
	OwnerId *interface{} `json:"ownerId,omitempty"`

	// ParentId ID of the parent page.
	//
	// This allows the page to be moved under a different parent within the same space.
	ParentId *interface{} `json:"parentId,omitempty"`

	// SpaceId ID of the containing space.
	//
	// This currently **does not support moving the page to a different space**.
	SpaceId *interface{} `json:"spaceId,omitempty"`

	// Status The updated status of the page.
	//
	// Note, if you change the status of a page from 'current' to 'draft' and it has an existing draft, the existing draft will be deleted in favor of the updated draft.
	// Additionally, this endpoint can be used to restore a 'trashed' or 'deleted' page to 'current' status. For restoration, page contents will not be updated and only the page status will be changed.
	Status string `json:"status"`

	// Title Title of the page.
	Title   string `json:"title"`
	Version struct {
		// Message An optional message to be stored with the version.
		Message *string `json:"message,omitempty"`

		// Number The new version of the updated page.
		// Set this to the current version number plus one, unless you are updating the status to 'draft' which requires a version number of 1.
		//
		// If you don't know the current version number, use Get page by id.
		Number *int32 `json:"number,omitempty"`
	} `json:"version"`
}

// GetPageAncestorsParams defines parameters for GetPageAncestors.
type GetPageAncestorsParams struct {
	// Limit Maximum number of pages per result to return. If more results exist, call this endpoint with the highest ancestor's ID to fetch the next set of results.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetPageAttachmentsParams defines parameters for GetPageAttachments.
type GetPageAttachmentsParams struct {
	// Sort Used to sort the result by a particular field.
	Sort *AttachmentSortOrder `form:"sort,omitempty" json:"sort,omitempty"`

	// Cursor Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Status Filter the results to attachments based on their status. By default, `current` and `archived` are used.
	Status *[]GetPageAttachmentsParamsStatus `form:"status,omitempty" json:"status,omitempty"`

	// MediaType Filters on the mediaType of attachments. Only one may be specified.
	MediaType *string `form:"mediaType,omitempty" json:"mediaType,omitempty"`

	// Filename Filters on the file-name of attachments. Only one may be specified.
	Filename *string `form:"filename,omitempty" json:"filename,omitempty"`

	// Limit Maximum number of attachments per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetPageAttachmentsParamsStatus defines parameters for GetPageAttachments.
type GetPageAttachmentsParamsStatus string

// GetChildPagesParams defines parameters for GetChildPages.
type GetChildPagesParams struct {
	// Cursor Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit Maximum number of pages per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Sort Used to sort the result by a particular field.
	Sort *string `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetPageClassificationLevelParams defines parameters for GetPageClassificationLevel.
type GetPageClassificationLevelParams struct {
	// Status Status of page from which classification level will fetched.
	Status *GetPageClassificationLevelParamsStatus `form:"status,omitempty" json:"status,omitempty"`
}

// GetPageClassificationLevelParamsStatus defines parameters for GetPageClassificationLevel.
type GetPageClassificationLevelParamsStatus string

// PutPageClassificationLevelJSONBody defines parameters for PutPageClassificationLevel.
type PutPageClassificationLevelJSONBody struct {
	// Id The ID of the classification level.
	Id string `json:"id"`

	// Status Status of the content.
	Status string `json:"status"`
}

// PostPageClassificationLevelJSONBody defines parameters for PostPageClassificationLevel.
type PostPageClassificationLevelJSONBody struct {
	// Status Status of the content.
	Status string `json:"status"`
}

// GetCustomContentByTypeInPageParams defines parameters for GetCustomContentByTypeInPage.
type GetCustomContentByTypeInPageParams struct {
	// Type The type of custom content being requested. See: https://developer.atlassian.com/cloud/confluence/custom-content/ for additional details on custom content.
	Type string `form:"type" json:"type"`

	// Sort Used to sort the result by a particular field.
	Sort *CustomContentSortOrder `form:"sort,omitempty" json:"sort,omitempty"`

	// Cursor Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit Maximum number of pages per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// BodyFormat The content format types to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.
	//
	// Note: If the custom content body type is `storage`, the `storage` and `atlas_doc_format` body formats are able to be returned. If the custom content body type is `raw`, only the `raw` body format is able to be returned.
	BodyFormat *CustomContentBodyRepresentation `form:"body-format,omitempty" json:"body-format,omitempty"`
}

// GetPageFooterCommentsParams defines parameters for GetPageFooterComments.
type GetPageFooterCommentsParams struct {
	// BodyFormat The content format type to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.
	BodyFormat *PrimaryBodyRepresentation `form:"body-format,omitempty" json:"body-format,omitempty"`

	// Status Filter the footer comment being retrieved by its status.
	Status *[]GetPageFooterCommentsParamsStatus `form:"status,omitempty" json:"status,omitempty"`

	// Sort Used to sort the result by a particular field.
	Sort *CommentSortOrder `form:"sort,omitempty" json:"sort,omitempty"`

	// Cursor Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit Maximum number of footer comments per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetPageFooterCommentsParamsStatus defines parameters for GetPageFooterComments.
type GetPageFooterCommentsParamsStatus string

// GetPageInlineCommentsParams defines parameters for GetPageInlineComments.
type GetPageInlineCommentsParams struct {
	// BodyFormat The content format type to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.
	BodyFormat *PrimaryBodyRepresentation `form:"body-format,omitempty" json:"body-format,omitempty"`

	// Status Filter the inline comment being retrieved by its status.
	Status *[]GetPageInlineCommentsParamsStatus `form:"status,omitempty" json:"status,omitempty"`

	// ResolutionStatus Filter the inline comment being retrieved by its resolution status.
	ResolutionStatus *[]GetPageInlineCommentsParamsResolutionStatus `form:"resolution-status,omitempty" json:"resolution-status,omitempty"`

	// Sort Used to sort the result by a particular field.
	Sort *CommentSortOrder `form:"sort,omitempty" json:"sort,omitempty"`

	// Cursor Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit Maximum number of inline comments per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetPageInlineCommentsParamsStatus defines parameters for GetPageInlineComments.
type GetPageInlineCommentsParamsStatus string

// GetPageInlineCommentsParamsResolutionStatus defines parameters for GetPageInlineComments.
type GetPageInlineCommentsParamsResolutionStatus string

// GetPageLabelsParams defines parameters for GetPageLabels.
type GetPageLabelsParams struct {
	// Prefix Filter the results to labels based on their prefix.
	Prefix *GetPageLabelsParamsPrefix `form:"prefix,omitempty" json:"prefix,omitempty"`

	// Sort Used to sort the result by a particular field.
	Sort *string `form:"sort,omitempty" json:"sort,omitempty"`

	// Cursor Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit Maximum number of labels per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetPageLabelsParamsPrefix defines parameters for GetPageLabels.
type GetPageLabelsParamsPrefix string

// GetPageLikeUsersParams defines parameters for GetPageLikeUsers.
type GetPageLikeUsersParams struct {
	// Cursor Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit Maximum number of account IDs per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetPageVersionsParams defines parameters for GetPageVersions.
type GetPageVersionsParams struct {
	// BodyFormat The content format types to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.
	BodyFormat *PrimaryBodyRepresentation `form:"body-format,omitempty" json:"body-format,omitempty"`

	// Cursor Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit Maximum number of versions per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Sort Used to sort the result by a particular field.
	Sort *VersionSortOrder `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetPageContentPropertiesParams defines parameters for GetPageContentProperties.
type GetPageContentPropertiesParams struct {
	// Key Filters the response to return a specific content property with matching key (case sensitive).
	Key *string `form:"key,omitempty" json:"key,omitempty"`

	// Sort Used to sort the result by a particular field.
	Sort *ContentPropertySortOrder `form:"sort,omitempty" json:"sort,omitempty"`

	// Cursor Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit Maximum number of attachments per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetSpacesParams defines parameters for GetSpaces.
type GetSpacesParams struct {
	// Ids Filter the results to spaces based on their IDs. Multiple IDs can be specified as a comma-separated list.
	Ids *[]int64 `form:"ids,omitempty" json:"ids,omitempty"`

	// Keys Filter the results to spaces based on their keys. Multiple keys can be specified as a comma-separated list.
	Keys *[]string `form:"keys,omitempty" json:"keys,omitempty"`

	// Type Filter the results to spaces based on their type.
	Type *GetSpacesParamsType `form:"type,omitempty" json:"type,omitempty"`

	// Status Filter the results to spaces based on their status.
	Status *GetSpacesParamsStatus `form:"status,omitempty" json:"status,omitempty"`

	// Labels Filter the results to spaces based on their labels. Multiple labels can be specified as a comma-separated list.
	Labels *[]string `form:"labels,omitempty" json:"labels,omitempty"`

	// FavoritedBy Filter the results to spaces favorited by the user with the specified account ID.
	FavoritedBy *string `form:"favorited-by,omitempty" json:"favorited-by,omitempty"`

	// NotFavoritedBy Filter the results to spaces NOT favorited by the user with the specified account ID.
	NotFavoritedBy *string `form:"not-favorited-by,omitempty" json:"not-favorited-by,omitempty"`

	// Sort Used to sort the result by a particular field.
	Sort *SpaceSortOrder `form:"sort,omitempty" json:"sort,omitempty"`

	// DescriptionFormat The content format type to be returned in the `description` field of the response. If available, the representation will be available under a response field of the same name under the `description` field.
	DescriptionFormat *SpaceDescriptionBodyRepresentation `form:"description-format,omitempty" json:"description-format,omitempty"`

	// IncludeIcon If the icon for the space should be fetched or not.
	IncludeIcon *bool `form:"include-icon,omitempty" json:"include-icon,omitempty"`

	// Cursor Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit Maximum number of spaces per result to return. If more results exist, use the `Link` response header to retrieve a relative URL that will return the next set of results.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetSpacesParamsType defines parameters for GetSpaces.
type GetSpacesParamsType string

// GetSpacesParamsStatus defines parameters for GetSpaces.
type GetSpacesParamsStatus string

// GetSpaceByIdParams defines parameters for GetSpaceById.
type GetSpaceByIdParams struct {
	// DescriptionFormat The content format type to be returned in the `description` field of the response. If available, the representation will be available under a response field of the same name under the `description` field.
	DescriptionFormat *SpaceDescriptionBodyRepresentation `form:"description-format,omitempty" json:"description-format,omitempty"`

	// IncludeIcon If the icon for the space should be fetched or not.
	IncludeIcon *bool `form:"include-icon,omitempty" json:"include-icon,omitempty"`

	// IncludeOperations Includes operations associated with this space in the response.
	// The number of results will be limited to 50 and sorted in the default sort order.
	// A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.
	IncludeOperations *bool `form:"include-operations,omitempty" json:"include-operations,omitempty"`

	// IncludeProperties Includes space properties associated with this space in the response.
	// The number of results will be limited to 50 and sorted in the default sort order.
	// A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.
	IncludeProperties *bool `form:"include-properties,omitempty" json:"include-properties,omitempty"`

	// IncludePermissions Includes space permissions associated with this space in the response.
	// The number of results will be limited to 50 and sorted in the default sort order.
	// A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.
	IncludePermissions *bool `form:"include-permissions,omitempty" json:"include-permissions,omitempty"`

	// IncludeLabels Includes labels associated with this space in the response.
	// The number of results will be limited to 50 and sorted in the default sort order.
	// A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.
	IncludeLabels *bool `form:"include-labels,omitempty" json:"include-labels,omitempty"`
}

// GetBlogPostsInSpaceParams defines parameters for GetBlogPostsInSpace.
type GetBlogPostsInSpaceParams struct {
	// Sort Used to sort the result by a particular field.
	Sort *BlogPostSortOrder `form:"sort,omitempty" json:"sort,omitempty"`

	// Status Filter the results to blog posts based on their status. By default, `current` is used.
	Status *[]GetBlogPostsInSpaceParamsStatus `form:"status,omitempty" json:"status,omitempty"`

	// Title Filter the results to blog posts based on their title.
	Title *string `form:"title,omitempty" json:"title,omitempty"`

	// BodyFormat The content format types to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.
	BodyFormat *PrimaryBodyRepresentation `form:"body-format,omitempty" json:"body-format,omitempty"`

	// Cursor Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit Maximum number of blog posts per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetBlogPostsInSpaceParamsStatus defines parameters for GetBlogPostsInSpace.
type GetBlogPostsInSpaceParamsStatus string

// PutSpaceDefaultClassificationLevelJSONBody defines parameters for PutSpaceDefaultClassificationLevel.
type PutSpaceDefaultClassificationLevelJSONBody struct {
	// Id The ID of the classification level.
	Id string `json:"id"`

	// Status Status of the content.
	Status string `json:"status"`
}

// GetSpaceContentLabelsParams defines parameters for GetSpaceContentLabels.
type GetSpaceContentLabelsParams struct {
	// Prefix Filter the results to labels based on their prefix.
	Prefix *GetSpaceContentLabelsParamsPrefix `form:"prefix,omitempty" json:"prefix,omitempty"`

	// Sort Used to sort the result by a particular field.
	Sort *string `form:"sort,omitempty" json:"sort,omitempty"`

	// Cursor Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit Maximum number of labels per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetSpaceContentLabelsParamsPrefix defines parameters for GetSpaceContentLabels.
type GetSpaceContentLabelsParamsPrefix string

// GetCustomContentByTypeInSpaceParams defines parameters for GetCustomContentByTypeInSpace.
type GetCustomContentByTypeInSpaceParams struct {
	// Type The type of custom content being requested. See: https://developer.atlassian.com/cloud/confluence/custom-content/ for additional details on custom content.
	Type string `form:"type" json:"type"`

	// Cursor Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit Maximum number of pages per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// BodyFormat The content format types to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.
	//
	// Note: If the custom content body type is `storage`, the `storage` and `atlas_doc_format` body formats are able to be returned. If the custom content body type is `raw`, only the `raw` body format is able to be returned.
	BodyFormat *CustomContentBodyRepresentation `form:"body-format,omitempty" json:"body-format,omitempty"`
}

// GetSpaceLabelsParams defines parameters for GetSpaceLabels.
type GetSpaceLabelsParams struct {
	// Prefix Filter the results to labels based on their prefix.
	Prefix *GetSpaceLabelsParamsPrefix `form:"prefix,omitempty" json:"prefix,omitempty"`

	// Sort Used to sort the result by a particular field.
	Sort *string `form:"sort,omitempty" json:"sort,omitempty"`

	// Cursor Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit Maximum number of labels per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetSpaceLabelsParamsPrefix defines parameters for GetSpaceLabels.
type GetSpaceLabelsParamsPrefix string

// GetPagesInSpaceParams defines parameters for GetPagesInSpace.
type GetPagesInSpaceParams struct {
	// Depth Filter the results to pages at the root level of the space or to all pages in the space.
	Depth *GetPagesInSpaceParamsDepth `form:"depth,omitempty" json:"depth,omitempty"`

	// Sort Used to sort the result by a particular field.
	Sort *PageSortOrder `form:"sort,omitempty" json:"sort,omitempty"`

	// Status Filter the results to pages based on their status. By default, `current` and `archived` are used.
	Status *[]GetPagesInSpaceParamsStatus `form:"status,omitempty" json:"status,omitempty"`

	// Title Filter the results to pages based on their title.
	Title *string `form:"title,omitempty" json:"title,omitempty"`

	// BodyFormat The content format types to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.
	BodyFormat *PrimaryBodyRepresentation `form:"body-format,omitempty" json:"body-format,omitempty"`

	// Cursor Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit Maximum number of pages per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetPagesInSpaceParamsDepth defines parameters for GetPagesInSpace.
type GetPagesInSpaceParamsDepth string

// GetPagesInSpaceParamsStatus defines parameters for GetPagesInSpace.
type GetPagesInSpaceParamsStatus string

// GetSpacePermissionsParams defines parameters for GetSpacePermissions.
type GetSpacePermissionsParams struct {
	// Cursor Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit Maximum number of spaces per result to return. If more results exist, use the `Link` response header to retrieve a relative URL that will return the next set of results.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetSpacePropertiesParams defines parameters for GetSpaceProperties.
type GetSpacePropertiesParams struct {
	// Key The key of the space property to retrieve. This should be used when a user knows the key of their property, but needs to retrieve the id for use in other methods.
	Key *string `form:"key,omitempty" json:"key,omitempty"`

	// Cursor Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit Maximum number of pages per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetTasksParams defines parameters for GetTasks.
type GetTasksParams struct {
	// BodyFormat The content format types to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.
	BodyFormat *PrimaryBodyRepresentation `form:"body-format,omitempty" json:"body-format,omitempty"`

	// IncludeBlankTasks Specifies whether to include blank tasks in the response. Defaults to `true`.
	IncludeBlankTasks *bool `form:"include-blank-tasks,omitempty" json:"include-blank-tasks,omitempty"`

	// Status Filters on the status of the task.
	Status *GetTasksParamsStatus `form:"status,omitempty" json:"status,omitempty"`

	// TaskId Filters on task ID. Multiple IDs can be specified.
	TaskId *[]int64 `form:"task-id,omitempty" json:"task-id,omitempty"`

	// SpaceId Filters on the space ID of the task. Multiple IDs can be specified.
	SpaceId *[]int64 `form:"space-id,omitempty" json:"space-id,omitempty"`

	// PageId Filters on the page ID of the task. Multiple IDs can be specified. Note - page and blog post filters can be used in conjunction.
	PageId *[]int64 `form:"page-id,omitempty" json:"page-id,omitempty"`

	// BlogpostId Filters on the blog post ID of the task. Multiple IDs can be specified. Note - page and blog post filters can be used in conjunction.
	BlogpostId *[]int64 `form:"blogpost-id,omitempty" json:"blogpost-id,omitempty"`

	// CreatedBy Filters on the Account ID of the user who created this task. Multiple IDs can be specified.
	CreatedBy *[]string `form:"created-by,omitempty" json:"created-by,omitempty"`

	// AssignedTo Filters on the Account ID of the user to whom this task is assigned. Multiple IDs can be specified.
	AssignedTo *[]string `form:"assigned-to,omitempty" json:"assigned-to,omitempty"`

	// CompletedBy Filters on the Account ID of the user who completed this task. Multiple IDs can be specified.
	CompletedBy *[]string `form:"completed-by,omitempty" json:"completed-by,omitempty"`

	// CreatedAtFrom Filters on start of date-time range of task based on creation date (inclusive). Input is epoch time in milliseconds.
	CreatedAtFrom *int64 `form:"created-at-from,omitempty" json:"created-at-from,omitempty"`

	// CreatedAtTo Filters on end of date-time range of task based on creation date (inclusive). Input is epoch time in milliseconds.
	CreatedAtTo *int64 `form:"created-at-to,omitempty" json:"created-at-to,omitempty"`

	// DueAtFrom Filters on start of date-time range of task based on due date (inclusive). Input is epoch time in milliseconds.
	DueAtFrom *int64 `form:"due-at-from,omitempty" json:"due-at-from,omitempty"`

	// DueAtTo Filters on end of date-time range of task based on due date (inclusive). Input is epoch time in milliseconds.
	DueAtTo *int64 `form:"due-at-to,omitempty" json:"due-at-to,omitempty"`

	// CompletedAtFrom Filters on start of date-time range of task based on completion date (inclusive). Input is epoch time in milliseconds.
	CompletedAtFrom *int64 `form:"completed-at-from,omitempty" json:"completed-at-from,omitempty"`

	// CompletedAtTo Filters on end of date-time range of task based on completion date (inclusive). Input is epoch time in milliseconds.
	CompletedAtTo *int64 `form:"completed-at-to,omitempty" json:"completed-at-to,omitempty"`

	// Cursor Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit Maximum number of tasks per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetTasksParamsStatus defines parameters for GetTasks.
type GetTasksParamsStatus string

// GetTaskByIdParams defines parameters for GetTaskById.
type GetTaskByIdParams struct {
	// BodyFormat The content format types to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.
	BodyFormat *PrimaryBodyRepresentation `form:"body-format,omitempty" json:"body-format,omitempty"`
}

// UpdateTaskJSONBody defines parameters for UpdateTask.
type UpdateTaskJSONBody struct {
	// AssignedTo Account ID of the user to whom this task is assigned.
	AssignedTo *string `json:"assignedTo,omitempty"`

	// BlogPostId ID of the blog post the task is in.
	BlogPostId *string `json:"blogPostId,omitempty"`

	// CompletedAt Date and time when the task was completed. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
	CompletedAt *time.Time `json:"completedAt,omitempty"`

	// CompletedBy Account ID of the user who completed this task.
	CompletedBy *string `json:"completedBy,omitempty"`

	// CreatedAt Date and time when the task was created. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// CreatedBy Account ID of the user who created this task.
	CreatedBy *string `json:"createdBy,omitempty"`

	// DueAt Date and time when the task is due. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
	DueAt *time.Time `json:"dueAt,omitempty"`

	// Id ID of the task.
	Id *string `json:"id,omitempty"`

	// LocalId Local ID of the task. This ID is local to the corresponding page or blog post.
	LocalId *string `json:"localId,omitempty"`

	// PageId ID of the page the task is in.
	PageId *string `json:"pageId,omitempty"`

	// SpaceId ID of the space the task is in.
	SpaceId *string `json:"spaceId,omitempty"`

	// Status Status of the task.
	Status string `json:"status"`

	// UpdatedAt Date and time when the task was updated. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
}

// UpdateTaskParams defines parameters for UpdateTask.
type UpdateTaskParams struct {
	// BodyFormat The content format types to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.
	BodyFormat *PrimaryBodyRepresentation `form:"body-format,omitempty" json:"body-format,omitempty"`
}

// CheckAccessByEmailJSONBody defines parameters for CheckAccessByEmail.
type CheckAccessByEmailJSONBody struct {
	// Emails List of emails to check access to site.
	Emails []string `json:"emails"`
}

// InviteByEmailJSONBody defines parameters for InviteByEmail.
type InviteByEmailJSONBody struct {
	// Emails List of emails to check access to site.
	Emails []string `json:"emails"`
}

// CreateBulkUserLookupJSONBody defines parameters for CreateBulkUserLookup.
type CreateBulkUserLookupJSONBody struct {
	// AccountIds List of accountIds to retrieve user info for.
	AccountIds []string `json:"accountIds"`
}

// CreateWhiteboardJSONBody defines parameters for CreateWhiteboard.
type CreateWhiteboardJSONBody struct {
	// ParentId The parent content ID of the whiteboard.
	ParentId *string `json:"parentId,omitempty"`

	// SpaceId ID of the space.
	SpaceId string `json:"spaceId"`

	// Title Title of the whiteboard.
	Title *string `json:"title,omitempty"`
}

// CreateWhiteboardParams defines parameters for CreateWhiteboard.
type CreateWhiteboardParams struct {
	// Private The whiteboard will be private. Only the user who creates this whiteboard will have permission to view and edit one.
	Private *bool `form:"private,omitempty" json:"private,omitempty"`
}

// GetWhiteboardAncestorsParams defines parameters for GetWhiteboardAncestors.
type GetWhiteboardAncestorsParams struct {
	// Limit Maximum number of items per result to return. If more results exist, call the endpoint with the highest ancestor's ID to fetch the next set of results.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// PutWhiteboardClassificationLevelJSONBody defines parameters for PutWhiteboardClassificationLevel.
type PutWhiteboardClassificationLevelJSONBody struct {
	// Id The ID of the classification level.
	Id string `json:"id"`

	// Status Status of the content.
	Status string `json:"status"`
}

// PostWhiteboardClassificationLevelJSONBody defines parameters for PostWhiteboardClassificationLevel.
type PostWhiteboardClassificationLevelJSONBody struct {
	// Status Status of the content.
	Status string `json:"status"`
}

// GetWhiteboardContentPropertiesParams defines parameters for GetWhiteboardContentProperties.
type GetWhiteboardContentPropertiesParams struct {
	// Key Filters the response to return a specific content property with matching key (case sensitive).
	Key *string `form:"key,omitempty" json:"key,omitempty"`

	// Sort Used to sort the result by a particular field.
	Sort *ContentPropertySortOrder `form:"sort,omitempty" json:"sort,omitempty"`

	// Cursor Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit Maximum number of attachments per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// CreateAttachmentPropertyJSONRequestBody defines body for CreateAttachmentProperty for application/json ContentType.
type CreateAttachmentPropertyJSONRequestBody = ContentPropertyCreateRequest

// UpdateAttachmentPropertyByIdJSONRequestBody defines body for UpdateAttachmentPropertyById for application/json ContentType.
type UpdateAttachmentPropertyByIdJSONRequestBody = ContentPropertyUpdateRequest

// CreateBlogPostJSONRequestBody defines body for CreateBlogPost for application/json ContentType.
type CreateBlogPostJSONRequestBody CreateBlogPostJSONBody

// CreateBlogpostPropertyJSONRequestBody defines body for CreateBlogpostProperty for application/json ContentType.
type CreateBlogpostPropertyJSONRequestBody = ContentPropertyCreateRequest

// UpdateBlogpostPropertyByIdJSONRequestBody defines body for UpdateBlogpostPropertyById for application/json ContentType.
type UpdateBlogpostPropertyByIdJSONRequestBody = ContentPropertyUpdateRequest

// UpdateBlogPostJSONRequestBody defines body for UpdateBlogPost for application/json ContentType.
type UpdateBlogPostJSONRequestBody UpdateBlogPostJSONBody

// PutBlogPostClassificationLevelJSONRequestBody defines body for PutBlogPostClassificationLevel for application/json ContentType.
type PutBlogPostClassificationLevelJSONRequestBody PutBlogPostClassificationLevelJSONBody

// PostBlogPostClassificationLevelJSONRequestBody defines body for PostBlogPostClassificationLevel for application/json ContentType.
type PostBlogPostClassificationLevelJSONRequestBody PostBlogPostClassificationLevelJSONBody

// CreateCommentPropertyJSONRequestBody defines body for CreateCommentProperty for application/json ContentType.
type CreateCommentPropertyJSONRequestBody = ContentPropertyCreateRequest

// UpdateCommentPropertyByIdJSONRequestBody defines body for UpdateCommentPropertyById for application/json ContentType.
type UpdateCommentPropertyByIdJSONRequestBody = ContentPropertyUpdateRequest

// ConvertContentIdsToContentTypesJSONRequestBody defines body for ConvertContentIdsToContentTypes for application/json ContentType.
type ConvertContentIdsToContentTypesJSONRequestBody ConvertContentIdsToContentTypesJSONBody

// CreateCustomContentJSONRequestBody defines body for CreateCustomContent for application/json ContentType.
type CreateCustomContentJSONRequestBody CreateCustomContentJSONBody

// CreateCustomContentPropertyJSONRequestBody defines body for CreateCustomContentProperty for application/json ContentType.
type CreateCustomContentPropertyJSONRequestBody = ContentPropertyCreateRequest

// UpdateCustomContentPropertyByIdJSONRequestBody defines body for UpdateCustomContentPropertyById for application/json ContentType.
type UpdateCustomContentPropertyByIdJSONRequestBody = ContentPropertyUpdateRequest

// UpdateCustomContentJSONRequestBody defines body for UpdateCustomContent for application/json ContentType.
type UpdateCustomContentJSONRequestBody UpdateCustomContentJSONBody

// CreateDatabaseJSONRequestBody defines body for CreateDatabase for application/json ContentType.
type CreateDatabaseJSONRequestBody CreateDatabaseJSONBody

// UpdateDatabasePropertyByIdJSONRequestBody defines body for UpdateDatabasePropertyById for application/json ContentType.
type UpdateDatabasePropertyByIdJSONRequestBody = ContentPropertyUpdateRequest

// PutDatabaseClassificationLevelJSONRequestBody defines body for PutDatabaseClassificationLevel for application/json ContentType.
type PutDatabaseClassificationLevelJSONRequestBody PutDatabaseClassificationLevelJSONBody

// PostDatabaseClassificationLevelJSONRequestBody defines body for PostDatabaseClassificationLevel for application/json ContentType.
type PostDatabaseClassificationLevelJSONRequestBody PostDatabaseClassificationLevelJSONBody

// CreateDatabasePropertyJSONRequestBody defines body for CreateDatabaseProperty for application/json ContentType.
type CreateDatabasePropertyJSONRequestBody = ContentPropertyCreateRequest

// CreateSmartLinkJSONRequestBody defines body for CreateSmartLink for application/json ContentType.
type CreateSmartLinkJSONRequestBody CreateSmartLinkJSONBody

// UpdateSmartLinkPropertyByIdJSONRequestBody defines body for UpdateSmartLinkPropertyById for application/json ContentType.
type UpdateSmartLinkPropertyByIdJSONRequestBody = ContentPropertyUpdateRequest

// CreateSmartLinkPropertyJSONRequestBody defines body for CreateSmartLinkProperty for application/json ContentType.
type CreateSmartLinkPropertyJSONRequestBody = ContentPropertyCreateRequest

// CreateFolderJSONRequestBody defines body for CreateFolder for application/json ContentType.
type CreateFolderJSONRequestBody CreateFolderJSONBody

// UpdateFolderPropertyByIdJSONRequestBody defines body for UpdateFolderPropertyById for application/json ContentType.
type UpdateFolderPropertyByIdJSONRequestBody = ContentPropertyUpdateRequest

// CreateFolderPropertyJSONRequestBody defines body for CreateFolderProperty for application/json ContentType.
type CreateFolderPropertyJSONRequestBody = ContentPropertyCreateRequest

// CreateFooterCommentJSONRequestBody defines body for CreateFooterComment for application/json ContentType.
type CreateFooterCommentJSONRequestBody = CreateFooterCommentModel

// UpdateFooterCommentJSONRequestBody defines body for UpdateFooterComment for application/json ContentType.
type UpdateFooterCommentJSONRequestBody UpdateFooterCommentJSONBody

// CreateInlineCommentJSONRequestBody defines body for CreateInlineComment for application/json ContentType.
type CreateInlineCommentJSONRequestBody = CreateInlineCommentModel

// UpdateInlineCommentJSONRequestBody defines body for UpdateInlineComment for application/json ContentType.
type UpdateInlineCommentJSONRequestBody = UpdateInlineCommentModel

// CreatePageJSONRequestBody defines body for CreatePage for application/json ContentType.
type CreatePageJSONRequestBody CreatePageJSONBody

// UpdatePageJSONRequestBody defines body for UpdatePage for application/json ContentType.
type UpdatePageJSONRequestBody UpdatePageJSONBody

// PutPageClassificationLevelJSONRequestBody defines body for PutPageClassificationLevel for application/json ContentType.
type PutPageClassificationLevelJSONRequestBody PutPageClassificationLevelJSONBody

// PostPageClassificationLevelJSONRequestBody defines body for PostPageClassificationLevel for application/json ContentType.
type PostPageClassificationLevelJSONRequestBody PostPageClassificationLevelJSONBody

// CreatePagePropertyJSONRequestBody defines body for CreatePageProperty for application/json ContentType.
type CreatePagePropertyJSONRequestBody = ContentPropertyCreateRequest

// UpdatePagePropertyByIdJSONRequestBody defines body for UpdatePagePropertyById for application/json ContentType.
type UpdatePagePropertyByIdJSONRequestBody = ContentPropertyUpdateRequest

// PutSpaceDefaultClassificationLevelJSONRequestBody defines body for PutSpaceDefaultClassificationLevel for application/json ContentType.
type PutSpaceDefaultClassificationLevelJSONRequestBody PutSpaceDefaultClassificationLevelJSONBody

// CreateSpacePropertyJSONRequestBody defines body for CreateSpaceProperty for application/json ContentType.
type CreateSpacePropertyJSONRequestBody = SpacePropertyCreateRequest

// UpdateSpacePropertyByIdJSONRequestBody defines body for UpdateSpacePropertyById for application/json ContentType.
type UpdateSpacePropertyByIdJSONRequestBody = SpacePropertyUpdateRequest

// UpdateTaskJSONRequestBody defines body for UpdateTask for application/json ContentType.
type UpdateTaskJSONRequestBody UpdateTaskJSONBody

// CheckAccessByEmailJSONRequestBody defines body for CheckAccessByEmail for application/json ContentType.
type CheckAccessByEmailJSONRequestBody CheckAccessByEmailJSONBody

// InviteByEmailJSONRequestBody defines body for InviteByEmail for application/json ContentType.
type InviteByEmailJSONRequestBody InviteByEmailJSONBody

// CreateBulkUserLookupJSONRequestBody defines body for CreateBulkUserLookup for application/json ContentType.
type CreateBulkUserLookupJSONRequestBody CreateBulkUserLookupJSONBody

// CreateWhiteboardJSONRequestBody defines body for CreateWhiteboard for application/json ContentType.
type CreateWhiteboardJSONRequestBody CreateWhiteboardJSONBody

// PutWhiteboardClassificationLevelJSONRequestBody defines body for PutWhiteboardClassificationLevel for application/json ContentType.
type PutWhiteboardClassificationLevelJSONRequestBody PutWhiteboardClassificationLevelJSONBody

// PostWhiteboardClassificationLevelJSONRequestBody defines body for PostWhiteboardClassificationLevel for application/json ContentType.
type PostWhiteboardClassificationLevelJSONRequestBody PostWhiteboardClassificationLevelJSONBody

// CreateWhiteboardPropertyJSONRequestBody defines body for CreateWhiteboardProperty for application/json ContentType.
type CreateWhiteboardPropertyJSONRequestBody = ContentPropertyCreateRequest

// UpdateWhiteboardPropertyByIdJSONRequestBody defines body for UpdateWhiteboardPropertyById for application/json ContentType.
type UpdateWhiteboardPropertyByIdJSONRequestBody = ContentPropertyUpdateRequest

// AsContentIdToContentTypeResponseResults0 returns the union data inside the ContentIdToContentTypeResponse_Results_AdditionalProperties as a ContentIdToContentTypeResponseResults0
func (t ContentIdToContentTypeResponse_Results_AdditionalProperties) AsContentIdToContentTypeResponseResults0() (ContentIdToContentTypeResponseResults0, error) {
	var body ContentIdToContentTypeResponseResults0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromContentIdToContentTypeResponseResults0 overwrites any union data inside the ContentIdToContentTypeResponse_Results_AdditionalProperties as the provided ContentIdToContentTypeResponseResults0
func (t *ContentIdToContentTypeResponse_Results_AdditionalProperties) FromContentIdToContentTypeResponseResults0(v ContentIdToContentTypeResponseResults0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeContentIdToContentTypeResponseResults0 performs a merge with any union data inside the ContentIdToContentTypeResponse_Results_AdditionalProperties, using the provided ContentIdToContentTypeResponseResults0
func (t *ContentIdToContentTypeResponse_Results_AdditionalProperties) MergeContentIdToContentTypeResponseResults0(v ContentIdToContentTypeResponseResults0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsContentIdToContentTypeResponseResults1 returns the union data inside the ContentIdToContentTypeResponse_Results_AdditionalProperties as a ContentIdToContentTypeResponseResults1
func (t ContentIdToContentTypeResponse_Results_AdditionalProperties) AsContentIdToContentTypeResponseResults1() (ContentIdToContentTypeResponseResults1, error) {
	var body ContentIdToContentTypeResponseResults1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromContentIdToContentTypeResponseResults1 overwrites any union data inside the ContentIdToContentTypeResponse_Results_AdditionalProperties as the provided ContentIdToContentTypeResponseResults1
func (t *ContentIdToContentTypeResponse_Results_AdditionalProperties) FromContentIdToContentTypeResponseResults1(v ContentIdToContentTypeResponseResults1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeContentIdToContentTypeResponseResults1 performs a merge with any union data inside the ContentIdToContentTypeResponse_Results_AdditionalProperties, using the provided ContentIdToContentTypeResponseResults1
func (t *ContentIdToContentTypeResponse_Results_AdditionalProperties) MergeContentIdToContentTypeResponseResults1(v ContentIdToContentTypeResponseResults1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ContentIdToContentTypeResponse_Results_AdditionalProperties) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ContentIdToContentTypeResponse_Results_AdditionalProperties) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetAttachments request
	GetAttachments(ctx context.Context, params *GetAttachmentsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAttachmentContentProperties request
	GetAttachmentContentProperties(ctx context.Context, attachmentId string, params *GetAttachmentContentPropertiesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAttachmentPropertyWithBody request with any body
	CreateAttachmentPropertyWithBody(ctx context.Context, attachmentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAttachmentProperty(ctx context.Context, attachmentId string, body CreateAttachmentPropertyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAttachmentPropertyById request
	DeleteAttachmentPropertyById(ctx context.Context, attachmentId string, propertyId int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAttachmentContentPropertiesById request
	GetAttachmentContentPropertiesById(ctx context.Context, attachmentId string, propertyId int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAttachmentPropertyByIdWithBody request with any body
	UpdateAttachmentPropertyByIdWithBody(ctx context.Context, attachmentId string, propertyId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateAttachmentPropertyById(ctx context.Context, attachmentId string, propertyId int64, body UpdateAttachmentPropertyByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAttachmentVersionDetails request
	GetAttachmentVersionDetails(ctx context.Context, attachmentId string, versionNumber int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAttachment request
	DeleteAttachment(ctx context.Context, id int64, params *DeleteAttachmentParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAttachmentById request
	GetAttachmentById(ctx context.Context, id string, params *GetAttachmentByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAttachmentComments request
	GetAttachmentComments(ctx context.Context, id string, params *GetAttachmentCommentsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAttachmentLabels request
	GetAttachmentLabels(ctx context.Context, id int64, params *GetAttachmentLabelsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAttachmentOperations request
	GetAttachmentOperations(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAttachmentVersions request
	GetAttachmentVersions(ctx context.Context, id string, params *GetAttachmentVersionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBlogPosts request
	GetBlogPosts(ctx context.Context, params *GetBlogPostsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBlogPostWithBody request with any body
	CreateBlogPostWithBody(ctx context.Context, params *CreateBlogPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateBlogPost(ctx context.Context, params *CreateBlogPostParams, body CreateBlogPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBlogpostContentProperties request
	GetBlogpostContentProperties(ctx context.Context, blogpostId int64, params *GetBlogpostContentPropertiesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBlogpostPropertyWithBody request with any body
	CreateBlogpostPropertyWithBody(ctx context.Context, blogpostId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateBlogpostProperty(ctx context.Context, blogpostId int64, body CreateBlogpostPropertyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteBlogpostPropertyById request
	DeleteBlogpostPropertyById(ctx context.Context, blogpostId int64, propertyId int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBlogpostContentPropertiesById request
	GetBlogpostContentPropertiesById(ctx context.Context, blogpostId int64, propertyId int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateBlogpostPropertyByIdWithBody request with any body
	UpdateBlogpostPropertyByIdWithBody(ctx context.Context, blogpostId int64, propertyId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateBlogpostPropertyById(ctx context.Context, blogpostId int64, propertyId int64, body UpdateBlogpostPropertyByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBlogPostVersionDetails request
	GetBlogPostVersionDetails(ctx context.Context, blogpostId int64, versionNumber int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteBlogPost request
	DeleteBlogPost(ctx context.Context, id int64, params *DeleteBlogPostParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBlogPostById request
	GetBlogPostById(ctx context.Context, id int64, params *GetBlogPostByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateBlogPostWithBody request with any body
	UpdateBlogPostWithBody(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateBlogPost(ctx context.Context, id int64, body UpdateBlogPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBlogpostAttachments request
	GetBlogpostAttachments(ctx context.Context, id int64, params *GetBlogpostAttachmentsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBlogPostClassificationLevel request
	GetBlogPostClassificationLevel(ctx context.Context, id int64, params *GetBlogPostClassificationLevelParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutBlogPostClassificationLevelWithBody request with any body
	PutBlogPostClassificationLevelWithBody(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutBlogPostClassificationLevel(ctx context.Context, id int64, body PutBlogPostClassificationLevelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostBlogPostClassificationLevelWithBody request with any body
	PostBlogPostClassificationLevelWithBody(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostBlogPostClassificationLevel(ctx context.Context, id int64, body PostBlogPostClassificationLevelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCustomContentByTypeInBlogPost request
	GetCustomContentByTypeInBlogPost(ctx context.Context, id int64, params *GetCustomContentByTypeInBlogPostParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBlogPostFooterComments request
	GetBlogPostFooterComments(ctx context.Context, id int64, params *GetBlogPostFooterCommentsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBlogPostInlineComments request
	GetBlogPostInlineComments(ctx context.Context, id int64, params *GetBlogPostInlineCommentsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBlogPostLabels request
	GetBlogPostLabels(ctx context.Context, id int64, params *GetBlogPostLabelsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBlogPostLikeCount request
	GetBlogPostLikeCount(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBlogPostLikeUsers request
	GetBlogPostLikeUsers(ctx context.Context, id int64, params *GetBlogPostLikeUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBlogPostOperations request
	GetBlogPostOperations(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBlogPostVersions request
	GetBlogPostVersions(ctx context.Context, id int64, params *GetBlogPostVersionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetClassificationLevels request
	GetClassificationLevels(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCommentContentProperties request
	GetCommentContentProperties(ctx context.Context, commentId int64, params *GetCommentContentPropertiesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateCommentPropertyWithBody request with any body
	CreateCommentPropertyWithBody(ctx context.Context, commentId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateCommentProperty(ctx context.Context, commentId int64, body CreateCommentPropertyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCommentPropertyById request
	DeleteCommentPropertyById(ctx context.Context, commentId int64, propertyId int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCommentContentPropertiesById request
	GetCommentContentPropertiesById(ctx context.Context, commentId int64, propertyId int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateCommentPropertyByIdWithBody request with any body
	UpdateCommentPropertyByIdWithBody(ctx context.Context, commentId int64, propertyId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateCommentPropertyById(ctx context.Context, commentId int64, propertyId int64, body UpdateCommentPropertyByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ConvertContentIdsToContentTypesWithBody request with any body
	ConvertContentIdsToContentTypesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ConvertContentIdsToContentTypes(ctx context.Context, body ConvertContentIdsToContentTypesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCustomContentByType request
	GetCustomContentByType(ctx context.Context, params *GetCustomContentByTypeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateCustomContentWithBody request with any body
	CreateCustomContentWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateCustomContent(ctx context.Context, body CreateCustomContentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCustomContentContentProperties request
	GetCustomContentContentProperties(ctx context.Context, customContentId int64, params *GetCustomContentContentPropertiesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateCustomContentPropertyWithBody request with any body
	CreateCustomContentPropertyWithBody(ctx context.Context, customContentId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateCustomContentProperty(ctx context.Context, customContentId int64, body CreateCustomContentPropertyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCustomContentPropertyById request
	DeleteCustomContentPropertyById(ctx context.Context, customContentId int64, propertyId int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCustomContentContentPropertiesById request
	GetCustomContentContentPropertiesById(ctx context.Context, customContentId int64, propertyId int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateCustomContentPropertyByIdWithBody request with any body
	UpdateCustomContentPropertyByIdWithBody(ctx context.Context, customContentId int64, propertyId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateCustomContentPropertyById(ctx context.Context, customContentId int64, propertyId int64, body UpdateCustomContentPropertyByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCustomContentVersions request
	GetCustomContentVersions(ctx context.Context, customContentId int64, params *GetCustomContentVersionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCustomContentVersionDetails request
	GetCustomContentVersionDetails(ctx context.Context, customContentId int64, versionNumber int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCustomContent request
	DeleteCustomContent(ctx context.Context, id int64, params *DeleteCustomContentParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCustomContentById request
	GetCustomContentById(ctx context.Context, id int64, params *GetCustomContentByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateCustomContentWithBody request with any body
	UpdateCustomContentWithBody(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateCustomContent(ctx context.Context, id int64, body UpdateCustomContentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCustomContentAttachments request
	GetCustomContentAttachments(ctx context.Context, id int64, params *GetCustomContentAttachmentsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetChildCustomContent request
	GetChildCustomContent(ctx context.Context, id int64, params *GetChildCustomContentParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCustomContentComments request
	GetCustomContentComments(ctx context.Context, id int64, params *GetCustomContentCommentsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCustomContentLabels request
	GetCustomContentLabels(ctx context.Context, id int64, params *GetCustomContentLabelsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCustomContentOperations request
	GetCustomContentOperations(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDataPolicyMetadata request
	GetDataPolicyMetadata(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDataPolicySpaces request
	GetDataPolicySpaces(ctx context.Context, params *GetDataPolicySpacesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateDatabaseWithBody request with any body
	CreateDatabaseWithBody(ctx context.Context, params *CreateDatabaseParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateDatabase(ctx context.Context, params *CreateDatabaseParams, body CreateDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDatabasePropertyById request
	DeleteDatabasePropertyById(ctx context.Context, databaseId int64, propertyId int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDatabaseContentPropertiesById request
	GetDatabaseContentPropertiesById(ctx context.Context, databaseId int64, propertyId int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateDatabasePropertyByIdWithBody request with any body
	UpdateDatabasePropertyByIdWithBody(ctx context.Context, databaseId int64, propertyId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateDatabasePropertyById(ctx context.Context, databaseId int64, propertyId int64, body UpdateDatabasePropertyByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDatabase request
	DeleteDatabase(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDatabaseById request
	GetDatabaseById(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDatabaseAncestors request
	GetDatabaseAncestors(ctx context.Context, id int64, params *GetDatabaseAncestorsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDatabaseClassificationLevel request
	GetDatabaseClassificationLevel(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutDatabaseClassificationLevelWithBody request with any body
	PutDatabaseClassificationLevelWithBody(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutDatabaseClassificationLevel(ctx context.Context, id int64, body PutDatabaseClassificationLevelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostDatabaseClassificationLevelWithBody request with any body
	PostDatabaseClassificationLevelWithBody(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostDatabaseClassificationLevel(ctx context.Context, id int64, body PostDatabaseClassificationLevelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDatabaseOperations request
	GetDatabaseOperations(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDatabaseContentProperties request
	GetDatabaseContentProperties(ctx context.Context, id int64, params *GetDatabaseContentPropertiesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateDatabasePropertyWithBody request with any body
	CreateDatabasePropertyWithBody(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateDatabaseProperty(ctx context.Context, id int64, body CreateDatabasePropertyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSmartLinkWithBody request with any body
	CreateSmartLinkWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSmartLink(ctx context.Context, body CreateSmartLinkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSmartLinkPropertyById request
	DeleteSmartLinkPropertyById(ctx context.Context, embedId int64, propertyId int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSmartLinkContentPropertiesById request
	GetSmartLinkContentPropertiesById(ctx context.Context, embedId int64, propertyId int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateSmartLinkPropertyByIdWithBody request with any body
	UpdateSmartLinkPropertyByIdWithBody(ctx context.Context, embedId int64, propertyId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateSmartLinkPropertyById(ctx context.Context, embedId int64, propertyId int64, body UpdateSmartLinkPropertyByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSmartLink request
	DeleteSmartLink(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSmartLinkById request
	GetSmartLinkById(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSmartLinkAncestors request
	GetSmartLinkAncestors(ctx context.Context, id int64, params *GetSmartLinkAncestorsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSmartLinkOperations request
	GetSmartLinkOperations(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSmartLinkContentProperties request
	GetSmartLinkContentProperties(ctx context.Context, id int64, params *GetSmartLinkContentPropertiesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSmartLinkPropertyWithBody request with any body
	CreateSmartLinkPropertyWithBody(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSmartLinkProperty(ctx context.Context, id int64, body CreateSmartLinkPropertyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateFolderWithBody request with any body
	CreateFolderWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateFolder(ctx context.Context, body CreateFolderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteFolderPropertyById request
	DeleteFolderPropertyById(ctx context.Context, folderId int64, propertyId int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFolderContentPropertiesById request
	GetFolderContentPropertiesById(ctx context.Context, folderId int64, propertyId int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateFolderPropertyByIdWithBody request with any body
	UpdateFolderPropertyByIdWithBody(ctx context.Context, folderId int64, propertyId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateFolderPropertyById(ctx context.Context, folderId int64, propertyId int64, body UpdateFolderPropertyByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteFolder request
	DeleteFolder(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFolderById request
	GetFolderById(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFolderAncestors request
	GetFolderAncestors(ctx context.Context, id int64, params *GetFolderAncestorsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFolderOperations request
	GetFolderOperations(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFolderContentProperties request
	GetFolderContentProperties(ctx context.Context, id int64, params *GetFolderContentPropertiesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateFolderPropertyWithBody request with any body
	CreateFolderPropertyWithBody(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateFolderProperty(ctx context.Context, id int64, body CreateFolderPropertyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFooterComments request
	GetFooterComments(ctx context.Context, params *GetFooterCommentsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateFooterCommentWithBody request with any body
	CreateFooterCommentWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateFooterComment(ctx context.Context, body CreateFooterCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteFooterComment request
	DeleteFooterComment(ctx context.Context, commentId int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFooterCommentById request
	GetFooterCommentById(ctx context.Context, commentId int64, params *GetFooterCommentByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateFooterCommentWithBody request with any body
	UpdateFooterCommentWithBody(ctx context.Context, commentId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateFooterComment(ctx context.Context, commentId int64, body UpdateFooterCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFooterCommentChildren request
	GetFooterCommentChildren(ctx context.Context, id int64, params *GetFooterCommentChildrenParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFooterLikeCount request
	GetFooterLikeCount(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFooterLikeUsers request
	GetFooterLikeUsers(ctx context.Context, id int64, params *GetFooterLikeUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFooterCommentOperations request
	GetFooterCommentOperations(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFooterCommentVersions request
	GetFooterCommentVersions(ctx context.Context, id int64, params *GetFooterCommentVersionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFooterCommentVersionDetails request
	GetFooterCommentVersionDetails(ctx context.Context, id int64, versionNumber int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInlineComments request
	GetInlineComments(ctx context.Context, params *GetInlineCommentsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateInlineCommentWithBody request with any body
	CreateInlineCommentWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateInlineComment(ctx context.Context, body CreateInlineCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteInlineComment request
	DeleteInlineComment(ctx context.Context, commentId int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInlineCommentById request
	GetInlineCommentById(ctx context.Context, commentId int64, params *GetInlineCommentByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateInlineCommentWithBody request with any body
	UpdateInlineCommentWithBody(ctx context.Context, commentId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateInlineComment(ctx context.Context, commentId int64, body UpdateInlineCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInlineCommentChildren request
	GetInlineCommentChildren(ctx context.Context, id int64, params *GetInlineCommentChildrenParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInlineLikeCount request
	GetInlineLikeCount(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInlineLikeUsers request
	GetInlineLikeUsers(ctx context.Context, id int64, params *GetInlineLikeUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInlineCommentOperations request
	GetInlineCommentOperations(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInlineCommentVersions request
	GetInlineCommentVersions(ctx context.Context, id int64, params *GetInlineCommentVersionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInlineCommentVersionDetails request
	GetInlineCommentVersionDetails(ctx context.Context, id int64, versionNumber int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLabels request
	GetLabels(ctx context.Context, params *GetLabelsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLabelAttachments request
	GetLabelAttachments(ctx context.Context, id int64, params *GetLabelAttachmentsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLabelBlogPosts request
	GetLabelBlogPosts(ctx context.Context, id int64, params *GetLabelBlogPostsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLabelPages request
	GetLabelPages(ctx context.Context, id int64, params *GetLabelPagesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPages request
	GetPages(ctx context.Context, params *GetPagesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePageWithBody request with any body
	CreatePageWithBody(ctx context.Context, params *CreatePageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePage(ctx context.Context, params *CreatePageParams, body CreatePageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePage request
	DeletePage(ctx context.Context, id int64, params *DeletePageParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPageById request
	GetPageById(ctx context.Context, id int64, params *GetPageByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdatePageWithBody request with any body
	UpdatePageWithBody(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdatePage(ctx context.Context, id int64, body UpdatePageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPageAncestors request
	GetPageAncestors(ctx context.Context, id int64, params *GetPageAncestorsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPageAttachments request
	GetPageAttachments(ctx context.Context, id int64, params *GetPageAttachmentsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetChildPages request
	GetChildPages(ctx context.Context, id int64, params *GetChildPagesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPageClassificationLevel request
	GetPageClassificationLevel(ctx context.Context, id int64, params *GetPageClassificationLevelParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutPageClassificationLevelWithBody request with any body
	PutPageClassificationLevelWithBody(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutPageClassificationLevel(ctx context.Context, id int64, body PutPageClassificationLevelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostPageClassificationLevelWithBody request with any body
	PostPageClassificationLevelWithBody(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostPageClassificationLevel(ctx context.Context, id int64, body PostPageClassificationLevelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCustomContentByTypeInPage request
	GetCustomContentByTypeInPage(ctx context.Context, id int64, params *GetCustomContentByTypeInPageParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPageFooterComments request
	GetPageFooterComments(ctx context.Context, id int64, params *GetPageFooterCommentsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPageInlineComments request
	GetPageInlineComments(ctx context.Context, id int64, params *GetPageInlineCommentsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPageLabels request
	GetPageLabels(ctx context.Context, id int64, params *GetPageLabelsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPageLikeCount request
	GetPageLikeCount(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPageLikeUsers request
	GetPageLikeUsers(ctx context.Context, id int64, params *GetPageLikeUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPageOperations request
	GetPageOperations(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPageVersions request
	GetPageVersions(ctx context.Context, id int64, params *GetPageVersionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPageContentProperties request
	GetPageContentProperties(ctx context.Context, pageId int64, params *GetPageContentPropertiesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePagePropertyWithBody request with any body
	CreatePagePropertyWithBody(ctx context.Context, pageId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePageProperty(ctx context.Context, pageId int64, body CreatePagePropertyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePagePropertyById request
	DeletePagePropertyById(ctx context.Context, pageId int64, propertyId int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPageContentPropertiesById request
	GetPageContentPropertiesById(ctx context.Context, pageId int64, propertyId int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdatePagePropertyByIdWithBody request with any body
	UpdatePagePropertyByIdWithBody(ctx context.Context, pageId int64, propertyId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdatePagePropertyById(ctx context.Context, pageId int64, propertyId int64, body UpdatePagePropertyByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPageVersionDetails request
	GetPageVersionDetails(ctx context.Context, pageId int64, versionNumber int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSpaces request
	GetSpaces(ctx context.Context, params *GetSpacesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSpaceById request
	GetSpaceById(ctx context.Context, id int64, params *GetSpaceByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBlogPostsInSpace request
	GetBlogPostsInSpace(ctx context.Context, id int64, params *GetBlogPostsInSpaceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSpaceDefaultClassificationLevel request
	DeleteSpaceDefaultClassificationLevel(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSpaceDefaultClassificationLevel request
	GetSpaceDefaultClassificationLevel(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutSpaceDefaultClassificationLevelWithBody request with any body
	PutSpaceDefaultClassificationLevelWithBody(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutSpaceDefaultClassificationLevel(ctx context.Context, id int64, body PutSpaceDefaultClassificationLevelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSpaceContentLabels request
	GetSpaceContentLabels(ctx context.Context, id int64, params *GetSpaceContentLabelsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCustomContentByTypeInSpace request
	GetCustomContentByTypeInSpace(ctx context.Context, id int64, params *GetCustomContentByTypeInSpaceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSpaceLabels request
	GetSpaceLabels(ctx context.Context, id int64, params *GetSpaceLabelsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSpaceOperations request
	GetSpaceOperations(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPagesInSpace request
	GetPagesInSpace(ctx context.Context, id int64, params *GetPagesInSpaceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSpacePermissions request
	GetSpacePermissions(ctx context.Context, id int64, params *GetSpacePermissionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSpaceProperties request
	GetSpaceProperties(ctx context.Context, spaceId int64, params *GetSpacePropertiesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSpacePropertyWithBody request with any body
	CreateSpacePropertyWithBody(ctx context.Context, spaceId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSpaceProperty(ctx context.Context, spaceId int64, body CreateSpacePropertyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSpacePropertyById request
	DeleteSpacePropertyById(ctx context.Context, spaceId int64, propertyId int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSpacePropertyById request
	GetSpacePropertyById(ctx context.Context, spaceId int64, propertyId int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateSpacePropertyByIdWithBody request with any body
	UpdateSpacePropertyByIdWithBody(ctx context.Context, spaceId int64, propertyId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateSpacePropertyById(ctx context.Context, spaceId int64, propertyId int64, body UpdateSpacePropertyByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTasks request
	GetTasks(ctx context.Context, params *GetTasksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTaskById request
	GetTaskById(ctx context.Context, id int64, params *GetTaskByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateTaskWithBody request with any body
	UpdateTaskWithBody(ctx context.Context, id int64, params *UpdateTaskParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateTask(ctx context.Context, id int64, params *UpdateTaskParams, body UpdateTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CheckAccessByEmailWithBody request with any body
	CheckAccessByEmailWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CheckAccessByEmail(ctx context.Context, body CheckAccessByEmailJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InviteByEmailWithBody request with any body
	InviteByEmailWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	InviteByEmail(ctx context.Context, body InviteByEmailJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBulkUserLookupWithBody request with any body
	CreateBulkUserLookupWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateBulkUserLookup(ctx context.Context, body CreateBulkUserLookupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateWhiteboardWithBody request with any body
	CreateWhiteboardWithBody(ctx context.Context, params *CreateWhiteboardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateWhiteboard(ctx context.Context, params *CreateWhiteboardParams, body CreateWhiteboardJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteWhiteboard request
	DeleteWhiteboard(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWhiteboardById request
	GetWhiteboardById(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWhiteboardAncestors request
	GetWhiteboardAncestors(ctx context.Context, id int64, params *GetWhiteboardAncestorsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWhiteboardClassificationLevel request
	GetWhiteboardClassificationLevel(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutWhiteboardClassificationLevelWithBody request with any body
	PutWhiteboardClassificationLevelWithBody(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutWhiteboardClassificationLevel(ctx context.Context, id int64, body PutWhiteboardClassificationLevelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostWhiteboardClassificationLevelWithBody request with any body
	PostWhiteboardClassificationLevelWithBody(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostWhiteboardClassificationLevel(ctx context.Context, id int64, body PostWhiteboardClassificationLevelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWhiteboardOperations request
	GetWhiteboardOperations(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWhiteboardContentProperties request
	GetWhiteboardContentProperties(ctx context.Context, id int64, params *GetWhiteboardContentPropertiesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateWhiteboardPropertyWithBody request with any body
	CreateWhiteboardPropertyWithBody(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateWhiteboardProperty(ctx context.Context, id int64, body CreateWhiteboardPropertyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteWhiteboardPropertyById request
	DeleteWhiteboardPropertyById(ctx context.Context, whiteboardId int64, propertyId int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWhiteboardContentPropertiesById request
	GetWhiteboardContentPropertiesById(ctx context.Context, whiteboardId int64, propertyId int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateWhiteboardPropertyByIdWithBody request with any body
	UpdateWhiteboardPropertyByIdWithBody(ctx context.Context, whiteboardId int64, propertyId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateWhiteboardPropertyById(ctx context.Context, whiteboardId int64, propertyId int64, body UpdateWhiteboardPropertyByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetAttachments(ctx context.Context, params *GetAttachmentsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAttachmentsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAttachmentContentProperties(ctx context.Context, attachmentId string, params *GetAttachmentContentPropertiesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAttachmentContentPropertiesRequest(c.Server, attachmentId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAttachmentPropertyWithBody(ctx context.Context, attachmentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAttachmentPropertyRequestWithBody(c.Server, attachmentId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAttachmentProperty(ctx context.Context, attachmentId string, body CreateAttachmentPropertyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAttachmentPropertyRequest(c.Server, attachmentId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAttachmentPropertyById(ctx context.Context, attachmentId string, propertyId int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAttachmentPropertyByIdRequest(c.Server, attachmentId, propertyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAttachmentContentPropertiesById(ctx context.Context, attachmentId string, propertyId int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAttachmentContentPropertiesByIdRequest(c.Server, attachmentId, propertyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAttachmentPropertyByIdWithBody(ctx context.Context, attachmentId string, propertyId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAttachmentPropertyByIdRequestWithBody(c.Server, attachmentId, propertyId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAttachmentPropertyById(ctx context.Context, attachmentId string, propertyId int64, body UpdateAttachmentPropertyByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAttachmentPropertyByIdRequest(c.Server, attachmentId, propertyId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAttachmentVersionDetails(ctx context.Context, attachmentId string, versionNumber int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAttachmentVersionDetailsRequest(c.Server, attachmentId, versionNumber)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAttachment(ctx context.Context, id int64, params *DeleteAttachmentParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAttachmentRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAttachmentById(ctx context.Context, id string, params *GetAttachmentByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAttachmentByIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAttachmentComments(ctx context.Context, id string, params *GetAttachmentCommentsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAttachmentCommentsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAttachmentLabels(ctx context.Context, id int64, params *GetAttachmentLabelsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAttachmentLabelsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAttachmentOperations(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAttachmentOperationsRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAttachmentVersions(ctx context.Context, id string, params *GetAttachmentVersionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAttachmentVersionsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBlogPosts(ctx context.Context, params *GetBlogPostsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBlogPostsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBlogPostWithBody(ctx context.Context, params *CreateBlogPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBlogPostRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBlogPost(ctx context.Context, params *CreateBlogPostParams, body CreateBlogPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBlogPostRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBlogpostContentProperties(ctx context.Context, blogpostId int64, params *GetBlogpostContentPropertiesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBlogpostContentPropertiesRequest(c.Server, blogpostId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBlogpostPropertyWithBody(ctx context.Context, blogpostId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBlogpostPropertyRequestWithBody(c.Server, blogpostId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBlogpostProperty(ctx context.Context, blogpostId int64, body CreateBlogpostPropertyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBlogpostPropertyRequest(c.Server, blogpostId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteBlogpostPropertyById(ctx context.Context, blogpostId int64, propertyId int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteBlogpostPropertyByIdRequest(c.Server, blogpostId, propertyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBlogpostContentPropertiesById(ctx context.Context, blogpostId int64, propertyId int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBlogpostContentPropertiesByIdRequest(c.Server, blogpostId, propertyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateBlogpostPropertyByIdWithBody(ctx context.Context, blogpostId int64, propertyId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateBlogpostPropertyByIdRequestWithBody(c.Server, blogpostId, propertyId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateBlogpostPropertyById(ctx context.Context, blogpostId int64, propertyId int64, body UpdateBlogpostPropertyByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateBlogpostPropertyByIdRequest(c.Server, blogpostId, propertyId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBlogPostVersionDetails(ctx context.Context, blogpostId int64, versionNumber int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBlogPostVersionDetailsRequest(c.Server, blogpostId, versionNumber)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteBlogPost(ctx context.Context, id int64, params *DeleteBlogPostParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteBlogPostRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBlogPostById(ctx context.Context, id int64, params *GetBlogPostByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBlogPostByIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateBlogPostWithBody(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateBlogPostRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateBlogPost(ctx context.Context, id int64, body UpdateBlogPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateBlogPostRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBlogpostAttachments(ctx context.Context, id int64, params *GetBlogpostAttachmentsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBlogpostAttachmentsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBlogPostClassificationLevel(ctx context.Context, id int64, params *GetBlogPostClassificationLevelParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBlogPostClassificationLevelRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutBlogPostClassificationLevelWithBody(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutBlogPostClassificationLevelRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutBlogPostClassificationLevel(ctx context.Context, id int64, body PutBlogPostClassificationLevelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutBlogPostClassificationLevelRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostBlogPostClassificationLevelWithBody(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostBlogPostClassificationLevelRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostBlogPostClassificationLevel(ctx context.Context, id int64, body PostBlogPostClassificationLevelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostBlogPostClassificationLevelRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCustomContentByTypeInBlogPost(ctx context.Context, id int64, params *GetCustomContentByTypeInBlogPostParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCustomContentByTypeInBlogPostRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBlogPostFooterComments(ctx context.Context, id int64, params *GetBlogPostFooterCommentsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBlogPostFooterCommentsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBlogPostInlineComments(ctx context.Context, id int64, params *GetBlogPostInlineCommentsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBlogPostInlineCommentsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBlogPostLabels(ctx context.Context, id int64, params *GetBlogPostLabelsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBlogPostLabelsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBlogPostLikeCount(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBlogPostLikeCountRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBlogPostLikeUsers(ctx context.Context, id int64, params *GetBlogPostLikeUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBlogPostLikeUsersRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBlogPostOperations(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBlogPostOperationsRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBlogPostVersions(ctx context.Context, id int64, params *GetBlogPostVersionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBlogPostVersionsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetClassificationLevels(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClassificationLevelsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCommentContentProperties(ctx context.Context, commentId int64, params *GetCommentContentPropertiesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCommentContentPropertiesRequest(c.Server, commentId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCommentPropertyWithBody(ctx context.Context, commentId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCommentPropertyRequestWithBody(c.Server, commentId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCommentProperty(ctx context.Context, commentId int64, body CreateCommentPropertyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCommentPropertyRequest(c.Server, commentId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCommentPropertyById(ctx context.Context, commentId int64, propertyId int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCommentPropertyByIdRequest(c.Server, commentId, propertyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCommentContentPropertiesById(ctx context.Context, commentId int64, propertyId int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCommentContentPropertiesByIdRequest(c.Server, commentId, propertyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCommentPropertyByIdWithBody(ctx context.Context, commentId int64, propertyId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCommentPropertyByIdRequestWithBody(c.Server, commentId, propertyId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCommentPropertyById(ctx context.Context, commentId int64, propertyId int64, body UpdateCommentPropertyByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCommentPropertyByIdRequest(c.Server, commentId, propertyId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConvertContentIdsToContentTypesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConvertContentIdsToContentTypesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConvertContentIdsToContentTypes(ctx context.Context, body ConvertContentIdsToContentTypesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConvertContentIdsToContentTypesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCustomContentByType(ctx context.Context, params *GetCustomContentByTypeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCustomContentByTypeRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCustomContentWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCustomContentRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCustomContent(ctx context.Context, body CreateCustomContentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCustomContentRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCustomContentContentProperties(ctx context.Context, customContentId int64, params *GetCustomContentContentPropertiesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCustomContentContentPropertiesRequest(c.Server, customContentId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCustomContentPropertyWithBody(ctx context.Context, customContentId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCustomContentPropertyRequestWithBody(c.Server, customContentId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCustomContentProperty(ctx context.Context, customContentId int64, body CreateCustomContentPropertyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCustomContentPropertyRequest(c.Server, customContentId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCustomContentPropertyById(ctx context.Context, customContentId int64, propertyId int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCustomContentPropertyByIdRequest(c.Server, customContentId, propertyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCustomContentContentPropertiesById(ctx context.Context, customContentId int64, propertyId int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCustomContentContentPropertiesByIdRequest(c.Server, customContentId, propertyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCustomContentPropertyByIdWithBody(ctx context.Context, customContentId int64, propertyId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCustomContentPropertyByIdRequestWithBody(c.Server, customContentId, propertyId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCustomContentPropertyById(ctx context.Context, customContentId int64, propertyId int64, body UpdateCustomContentPropertyByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCustomContentPropertyByIdRequest(c.Server, customContentId, propertyId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCustomContentVersions(ctx context.Context, customContentId int64, params *GetCustomContentVersionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCustomContentVersionsRequest(c.Server, customContentId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCustomContentVersionDetails(ctx context.Context, customContentId int64, versionNumber int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCustomContentVersionDetailsRequest(c.Server, customContentId, versionNumber)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCustomContent(ctx context.Context, id int64, params *DeleteCustomContentParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCustomContentRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCustomContentById(ctx context.Context, id int64, params *GetCustomContentByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCustomContentByIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCustomContentWithBody(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCustomContentRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCustomContent(ctx context.Context, id int64, body UpdateCustomContentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCustomContentRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCustomContentAttachments(ctx context.Context, id int64, params *GetCustomContentAttachmentsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCustomContentAttachmentsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetChildCustomContent(ctx context.Context, id int64, params *GetChildCustomContentParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetChildCustomContentRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCustomContentComments(ctx context.Context, id int64, params *GetCustomContentCommentsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCustomContentCommentsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCustomContentLabels(ctx context.Context, id int64, params *GetCustomContentLabelsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCustomContentLabelsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCustomContentOperations(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCustomContentOperationsRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDataPolicyMetadata(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDataPolicyMetadataRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDataPolicySpaces(ctx context.Context, params *GetDataPolicySpacesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDataPolicySpacesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDatabaseWithBody(ctx context.Context, params *CreateDatabaseParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDatabaseRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDatabase(ctx context.Context, params *CreateDatabaseParams, body CreateDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDatabaseRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDatabasePropertyById(ctx context.Context, databaseId int64, propertyId int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDatabasePropertyByIdRequest(c.Server, databaseId, propertyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDatabaseContentPropertiesById(ctx context.Context, databaseId int64, propertyId int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDatabaseContentPropertiesByIdRequest(c.Server, databaseId, propertyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDatabasePropertyByIdWithBody(ctx context.Context, databaseId int64, propertyId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDatabasePropertyByIdRequestWithBody(c.Server, databaseId, propertyId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDatabasePropertyById(ctx context.Context, databaseId int64, propertyId int64, body UpdateDatabasePropertyByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDatabasePropertyByIdRequest(c.Server, databaseId, propertyId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDatabase(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDatabaseRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDatabaseById(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDatabaseByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDatabaseAncestors(ctx context.Context, id int64, params *GetDatabaseAncestorsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDatabaseAncestorsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDatabaseClassificationLevel(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDatabaseClassificationLevelRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutDatabaseClassificationLevelWithBody(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutDatabaseClassificationLevelRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutDatabaseClassificationLevel(ctx context.Context, id int64, body PutDatabaseClassificationLevelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutDatabaseClassificationLevelRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostDatabaseClassificationLevelWithBody(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostDatabaseClassificationLevelRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostDatabaseClassificationLevel(ctx context.Context, id int64, body PostDatabaseClassificationLevelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostDatabaseClassificationLevelRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDatabaseOperations(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDatabaseOperationsRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDatabaseContentProperties(ctx context.Context, id int64, params *GetDatabaseContentPropertiesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDatabaseContentPropertiesRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDatabasePropertyWithBody(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDatabasePropertyRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDatabaseProperty(ctx context.Context, id int64, body CreateDatabasePropertyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDatabasePropertyRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSmartLinkWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSmartLinkRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSmartLink(ctx context.Context, body CreateSmartLinkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSmartLinkRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSmartLinkPropertyById(ctx context.Context, embedId int64, propertyId int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSmartLinkPropertyByIdRequest(c.Server, embedId, propertyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSmartLinkContentPropertiesById(ctx context.Context, embedId int64, propertyId int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSmartLinkContentPropertiesByIdRequest(c.Server, embedId, propertyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSmartLinkPropertyByIdWithBody(ctx context.Context, embedId int64, propertyId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSmartLinkPropertyByIdRequestWithBody(c.Server, embedId, propertyId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSmartLinkPropertyById(ctx context.Context, embedId int64, propertyId int64, body UpdateSmartLinkPropertyByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSmartLinkPropertyByIdRequest(c.Server, embedId, propertyId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSmartLink(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSmartLinkRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSmartLinkById(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSmartLinkByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSmartLinkAncestors(ctx context.Context, id int64, params *GetSmartLinkAncestorsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSmartLinkAncestorsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSmartLinkOperations(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSmartLinkOperationsRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSmartLinkContentProperties(ctx context.Context, id int64, params *GetSmartLinkContentPropertiesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSmartLinkContentPropertiesRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSmartLinkPropertyWithBody(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSmartLinkPropertyRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSmartLinkProperty(ctx context.Context, id int64, body CreateSmartLinkPropertyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSmartLinkPropertyRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFolderWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFolderRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFolder(ctx context.Context, body CreateFolderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFolderRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteFolderPropertyById(ctx context.Context, folderId int64, propertyId int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteFolderPropertyByIdRequest(c.Server, folderId, propertyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFolderContentPropertiesById(ctx context.Context, folderId int64, propertyId int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFolderContentPropertiesByIdRequest(c.Server, folderId, propertyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateFolderPropertyByIdWithBody(ctx context.Context, folderId int64, propertyId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateFolderPropertyByIdRequestWithBody(c.Server, folderId, propertyId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateFolderPropertyById(ctx context.Context, folderId int64, propertyId int64, body UpdateFolderPropertyByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateFolderPropertyByIdRequest(c.Server, folderId, propertyId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteFolder(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteFolderRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFolderById(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFolderByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFolderAncestors(ctx context.Context, id int64, params *GetFolderAncestorsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFolderAncestorsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFolderOperations(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFolderOperationsRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFolderContentProperties(ctx context.Context, id int64, params *GetFolderContentPropertiesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFolderContentPropertiesRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFolderPropertyWithBody(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFolderPropertyRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFolderProperty(ctx context.Context, id int64, body CreateFolderPropertyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFolderPropertyRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFooterComments(ctx context.Context, params *GetFooterCommentsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFooterCommentsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFooterCommentWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFooterCommentRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFooterComment(ctx context.Context, body CreateFooterCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFooterCommentRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteFooterComment(ctx context.Context, commentId int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteFooterCommentRequest(c.Server, commentId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFooterCommentById(ctx context.Context, commentId int64, params *GetFooterCommentByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFooterCommentByIdRequest(c.Server, commentId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateFooterCommentWithBody(ctx context.Context, commentId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateFooterCommentRequestWithBody(c.Server, commentId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateFooterComment(ctx context.Context, commentId int64, body UpdateFooterCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateFooterCommentRequest(c.Server, commentId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFooterCommentChildren(ctx context.Context, id int64, params *GetFooterCommentChildrenParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFooterCommentChildrenRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFooterLikeCount(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFooterLikeCountRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFooterLikeUsers(ctx context.Context, id int64, params *GetFooterLikeUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFooterLikeUsersRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFooterCommentOperations(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFooterCommentOperationsRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFooterCommentVersions(ctx context.Context, id int64, params *GetFooterCommentVersionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFooterCommentVersionsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFooterCommentVersionDetails(ctx context.Context, id int64, versionNumber int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFooterCommentVersionDetailsRequest(c.Server, id, versionNumber)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInlineComments(ctx context.Context, params *GetInlineCommentsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInlineCommentsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateInlineCommentWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateInlineCommentRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateInlineComment(ctx context.Context, body CreateInlineCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateInlineCommentRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteInlineComment(ctx context.Context, commentId int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteInlineCommentRequest(c.Server, commentId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInlineCommentById(ctx context.Context, commentId int64, params *GetInlineCommentByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInlineCommentByIdRequest(c.Server, commentId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateInlineCommentWithBody(ctx context.Context, commentId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateInlineCommentRequestWithBody(c.Server, commentId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateInlineComment(ctx context.Context, commentId int64, body UpdateInlineCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateInlineCommentRequest(c.Server, commentId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInlineCommentChildren(ctx context.Context, id int64, params *GetInlineCommentChildrenParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInlineCommentChildrenRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInlineLikeCount(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInlineLikeCountRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInlineLikeUsers(ctx context.Context, id int64, params *GetInlineLikeUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInlineLikeUsersRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInlineCommentOperations(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInlineCommentOperationsRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInlineCommentVersions(ctx context.Context, id int64, params *GetInlineCommentVersionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInlineCommentVersionsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInlineCommentVersionDetails(ctx context.Context, id int64, versionNumber int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInlineCommentVersionDetailsRequest(c.Server, id, versionNumber)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLabels(ctx context.Context, params *GetLabelsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLabelsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLabelAttachments(ctx context.Context, id int64, params *GetLabelAttachmentsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLabelAttachmentsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLabelBlogPosts(ctx context.Context, id int64, params *GetLabelBlogPostsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLabelBlogPostsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLabelPages(ctx context.Context, id int64, params *GetLabelPagesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLabelPagesRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPages(ctx context.Context, params *GetPagesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPagesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePageWithBody(ctx context.Context, params *CreatePageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePageRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePage(ctx context.Context, params *CreatePageParams, body CreatePageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePageRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePage(ctx context.Context, id int64, params *DeletePageParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePageRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPageById(ctx context.Context, id int64, params *GetPageByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPageByIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePageWithBody(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePageRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePage(ctx context.Context, id int64, body UpdatePageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePageRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPageAncestors(ctx context.Context, id int64, params *GetPageAncestorsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPageAncestorsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPageAttachments(ctx context.Context, id int64, params *GetPageAttachmentsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPageAttachmentsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetChildPages(ctx context.Context, id int64, params *GetChildPagesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetChildPagesRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPageClassificationLevel(ctx context.Context, id int64, params *GetPageClassificationLevelParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPageClassificationLevelRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutPageClassificationLevelWithBody(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutPageClassificationLevelRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutPageClassificationLevel(ctx context.Context, id int64, body PutPageClassificationLevelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutPageClassificationLevelRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostPageClassificationLevelWithBody(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostPageClassificationLevelRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostPageClassificationLevel(ctx context.Context, id int64, body PostPageClassificationLevelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostPageClassificationLevelRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCustomContentByTypeInPage(ctx context.Context, id int64, params *GetCustomContentByTypeInPageParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCustomContentByTypeInPageRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPageFooterComments(ctx context.Context, id int64, params *GetPageFooterCommentsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPageFooterCommentsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPageInlineComments(ctx context.Context, id int64, params *GetPageInlineCommentsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPageInlineCommentsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPageLabels(ctx context.Context, id int64, params *GetPageLabelsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPageLabelsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPageLikeCount(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPageLikeCountRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPageLikeUsers(ctx context.Context, id int64, params *GetPageLikeUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPageLikeUsersRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPageOperations(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPageOperationsRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPageVersions(ctx context.Context, id int64, params *GetPageVersionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPageVersionsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPageContentProperties(ctx context.Context, pageId int64, params *GetPageContentPropertiesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPageContentPropertiesRequest(c.Server, pageId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePagePropertyWithBody(ctx context.Context, pageId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePagePropertyRequestWithBody(c.Server, pageId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePageProperty(ctx context.Context, pageId int64, body CreatePagePropertyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePagePropertyRequest(c.Server, pageId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePagePropertyById(ctx context.Context, pageId int64, propertyId int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePagePropertyByIdRequest(c.Server, pageId, propertyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPageContentPropertiesById(ctx context.Context, pageId int64, propertyId int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPageContentPropertiesByIdRequest(c.Server, pageId, propertyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePagePropertyByIdWithBody(ctx context.Context, pageId int64, propertyId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePagePropertyByIdRequestWithBody(c.Server, pageId, propertyId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePagePropertyById(ctx context.Context, pageId int64, propertyId int64, body UpdatePagePropertyByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePagePropertyByIdRequest(c.Server, pageId, propertyId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPageVersionDetails(ctx context.Context, pageId int64, versionNumber int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPageVersionDetailsRequest(c.Server, pageId, versionNumber)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSpaces(ctx context.Context, params *GetSpacesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSpacesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSpaceById(ctx context.Context, id int64, params *GetSpaceByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSpaceByIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBlogPostsInSpace(ctx context.Context, id int64, params *GetBlogPostsInSpaceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBlogPostsInSpaceRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSpaceDefaultClassificationLevel(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSpaceDefaultClassificationLevelRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSpaceDefaultClassificationLevel(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSpaceDefaultClassificationLevelRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutSpaceDefaultClassificationLevelWithBody(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutSpaceDefaultClassificationLevelRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutSpaceDefaultClassificationLevel(ctx context.Context, id int64, body PutSpaceDefaultClassificationLevelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutSpaceDefaultClassificationLevelRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSpaceContentLabels(ctx context.Context, id int64, params *GetSpaceContentLabelsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSpaceContentLabelsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCustomContentByTypeInSpace(ctx context.Context, id int64, params *GetCustomContentByTypeInSpaceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCustomContentByTypeInSpaceRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSpaceLabels(ctx context.Context, id int64, params *GetSpaceLabelsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSpaceLabelsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSpaceOperations(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSpaceOperationsRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPagesInSpace(ctx context.Context, id int64, params *GetPagesInSpaceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPagesInSpaceRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSpacePermissions(ctx context.Context, id int64, params *GetSpacePermissionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSpacePermissionsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSpaceProperties(ctx context.Context, spaceId int64, params *GetSpacePropertiesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSpacePropertiesRequest(c.Server, spaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSpacePropertyWithBody(ctx context.Context, spaceId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSpacePropertyRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSpaceProperty(ctx context.Context, spaceId int64, body CreateSpacePropertyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSpacePropertyRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSpacePropertyById(ctx context.Context, spaceId int64, propertyId int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSpacePropertyByIdRequest(c.Server, spaceId, propertyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSpacePropertyById(ctx context.Context, spaceId int64, propertyId int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSpacePropertyByIdRequest(c.Server, spaceId, propertyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSpacePropertyByIdWithBody(ctx context.Context, spaceId int64, propertyId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSpacePropertyByIdRequestWithBody(c.Server, spaceId, propertyId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSpacePropertyById(ctx context.Context, spaceId int64, propertyId int64, body UpdateSpacePropertyByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSpacePropertyByIdRequest(c.Server, spaceId, propertyId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTasks(ctx context.Context, params *GetTasksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTasksRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTaskById(ctx context.Context, id int64, params *GetTaskByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTaskByIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTaskWithBody(ctx context.Context, id int64, params *UpdateTaskParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTaskRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTask(ctx context.Context, id int64, params *UpdateTaskParams, body UpdateTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTaskRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CheckAccessByEmailWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCheckAccessByEmailRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CheckAccessByEmail(ctx context.Context, body CheckAccessByEmailJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCheckAccessByEmailRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InviteByEmailWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInviteByEmailRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InviteByEmail(ctx context.Context, body InviteByEmailJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInviteByEmailRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBulkUserLookupWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBulkUserLookupRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBulkUserLookup(ctx context.Context, body CreateBulkUserLookupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBulkUserLookupRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateWhiteboardWithBody(ctx context.Context, params *CreateWhiteboardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateWhiteboardRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateWhiteboard(ctx context.Context, params *CreateWhiteboardParams, body CreateWhiteboardJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateWhiteboardRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteWhiteboard(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteWhiteboardRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWhiteboardById(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWhiteboardByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWhiteboardAncestors(ctx context.Context, id int64, params *GetWhiteboardAncestorsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWhiteboardAncestorsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWhiteboardClassificationLevel(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWhiteboardClassificationLevelRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutWhiteboardClassificationLevelWithBody(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutWhiteboardClassificationLevelRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutWhiteboardClassificationLevel(ctx context.Context, id int64, body PutWhiteboardClassificationLevelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutWhiteboardClassificationLevelRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostWhiteboardClassificationLevelWithBody(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostWhiteboardClassificationLevelRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostWhiteboardClassificationLevel(ctx context.Context, id int64, body PostWhiteboardClassificationLevelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostWhiteboardClassificationLevelRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWhiteboardOperations(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWhiteboardOperationsRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWhiteboardContentProperties(ctx context.Context, id int64, params *GetWhiteboardContentPropertiesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWhiteboardContentPropertiesRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateWhiteboardPropertyWithBody(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateWhiteboardPropertyRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateWhiteboardProperty(ctx context.Context, id int64, body CreateWhiteboardPropertyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateWhiteboardPropertyRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteWhiteboardPropertyById(ctx context.Context, whiteboardId int64, propertyId int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteWhiteboardPropertyByIdRequest(c.Server, whiteboardId, propertyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWhiteboardContentPropertiesById(ctx context.Context, whiteboardId int64, propertyId int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWhiteboardContentPropertiesByIdRequest(c.Server, whiteboardId, propertyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateWhiteboardPropertyByIdWithBody(ctx context.Context, whiteboardId int64, propertyId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateWhiteboardPropertyByIdRequestWithBody(c.Server, whiteboardId, propertyId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateWhiteboardPropertyById(ctx context.Context, whiteboardId int64, propertyId int64, body UpdateWhiteboardPropertyByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateWhiteboardPropertyByIdRequest(c.Server, whiteboardId, propertyId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetAttachmentsRequest generates requests for GetAttachments
func NewGetAttachmentsRequest(server string, params *GetAttachmentsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/attachments")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MediaType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mediaType", runtime.ParamLocationQuery, *params.MediaType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filename != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filename", runtime.ParamLocationQuery, *params.Filename); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAttachmentContentPropertiesRequest generates requests for GetAttachmentContentProperties
func NewGetAttachmentContentPropertiesRequest(server string, attachmentId string, params *GetAttachmentContentPropertiesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "attachment-id", runtime.ParamLocationPath, attachmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/attachments/%s/properties", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Key != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "key", runtime.ParamLocationQuery, *params.Key); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAttachmentPropertyRequest calls the generic CreateAttachmentProperty builder with application/json body
func NewCreateAttachmentPropertyRequest(server string, attachmentId string, body CreateAttachmentPropertyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAttachmentPropertyRequestWithBody(server, attachmentId, "application/json", bodyReader)
}

// NewCreateAttachmentPropertyRequestWithBody generates requests for CreateAttachmentProperty with any type of body
func NewCreateAttachmentPropertyRequestWithBody(server string, attachmentId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "attachment-id", runtime.ParamLocationPath, attachmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/attachments/%s/properties", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAttachmentPropertyByIdRequest generates requests for DeleteAttachmentPropertyById
func NewDeleteAttachmentPropertyByIdRequest(server string, attachmentId string, propertyId int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "attachment-id", runtime.ParamLocationPath, attachmentId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "property-id", runtime.ParamLocationPath, propertyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/attachments/%s/properties/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAttachmentContentPropertiesByIdRequest generates requests for GetAttachmentContentPropertiesById
func NewGetAttachmentContentPropertiesByIdRequest(server string, attachmentId string, propertyId int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "attachment-id", runtime.ParamLocationPath, attachmentId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "property-id", runtime.ParamLocationPath, propertyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/attachments/%s/properties/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateAttachmentPropertyByIdRequest calls the generic UpdateAttachmentPropertyById builder with application/json body
func NewUpdateAttachmentPropertyByIdRequest(server string, attachmentId string, propertyId int64, body UpdateAttachmentPropertyByIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAttachmentPropertyByIdRequestWithBody(server, attachmentId, propertyId, "application/json", bodyReader)
}

// NewUpdateAttachmentPropertyByIdRequestWithBody generates requests for UpdateAttachmentPropertyById with any type of body
func NewUpdateAttachmentPropertyByIdRequestWithBody(server string, attachmentId string, propertyId int64, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "attachment-id", runtime.ParamLocationPath, attachmentId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "property-id", runtime.ParamLocationPath, propertyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/attachments/%s/properties/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAttachmentVersionDetailsRequest generates requests for GetAttachmentVersionDetails
func NewGetAttachmentVersionDetailsRequest(server string, attachmentId string, versionNumber int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "attachment-id", runtime.ParamLocationPath, attachmentId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "version-number", runtime.ParamLocationPath, versionNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/attachments/%s/versions/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteAttachmentRequest generates requests for DeleteAttachment
func NewDeleteAttachmentRequest(server string, id int64, params *DeleteAttachmentParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/attachments/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Purge != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "purge", runtime.ParamLocationQuery, *params.Purge); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAttachmentByIdRequest generates requests for GetAttachmentById
func NewGetAttachmentByIdRequest(server string, id string, params *GetAttachmentByIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/attachments/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeLabels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include-labels", runtime.ParamLocationQuery, *params.IncludeLabels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeProperties != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include-properties", runtime.ParamLocationQuery, *params.IncludeProperties); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeOperations != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include-operations", runtime.ParamLocationQuery, *params.IncludeOperations); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeVersions != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include-versions", runtime.ParamLocationQuery, *params.IncludeVersions); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeVersion != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include-version", runtime.ParamLocationQuery, *params.IncludeVersion); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAttachmentCommentsRequest generates requests for GetAttachmentComments
func NewGetAttachmentCommentsRequest(server string, id string, params *GetAttachmentCommentsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/attachments/%s/footer-comments", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.BodyFormat != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "body-format", runtime.ParamLocationQuery, *params.BodyFormat); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAttachmentLabelsRequest generates requests for GetAttachmentLabels
func NewGetAttachmentLabelsRequest(server string, id int64, params *GetAttachmentLabelsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/attachments/%s/labels", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Prefix != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefix", runtime.ParamLocationQuery, *params.Prefix); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAttachmentOperationsRequest generates requests for GetAttachmentOperations
func NewGetAttachmentOperationsRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/attachments/%s/operations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAttachmentVersionsRequest generates requests for GetAttachmentVersions
func NewGetAttachmentVersionsRequest(server string, id string, params *GetAttachmentVersionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/attachments/%s/versions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBlogPostsRequest generates requests for GetBlogPosts
func NewGetBlogPostsRequest(server string, params *GetBlogPostsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/blogposts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SpaceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "space-id", runtime.ParamLocationQuery, *params.SpaceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Title != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "title", runtime.ParamLocationQuery, *params.Title); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BodyFormat != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "body-format", runtime.ParamLocationQuery, *params.BodyFormat); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateBlogPostRequest calls the generic CreateBlogPost builder with application/json body
func NewCreateBlogPostRequest(server string, params *CreateBlogPostParams, body CreateBlogPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateBlogPostRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateBlogPostRequestWithBody generates requests for CreateBlogPost with any type of body
func NewCreateBlogPostRequestWithBody(server string, params *CreateBlogPostParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/blogposts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Private != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "private", runtime.ParamLocationQuery, *params.Private); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetBlogpostContentPropertiesRequest generates requests for GetBlogpostContentProperties
func NewGetBlogpostContentPropertiesRequest(server string, blogpostId int64, params *GetBlogpostContentPropertiesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "blogpost-id", runtime.ParamLocationPath, blogpostId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/blogposts/%s/properties", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Key != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "key", runtime.ParamLocationQuery, *params.Key); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateBlogpostPropertyRequest calls the generic CreateBlogpostProperty builder with application/json body
func NewCreateBlogpostPropertyRequest(server string, blogpostId int64, body CreateBlogpostPropertyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateBlogpostPropertyRequestWithBody(server, blogpostId, "application/json", bodyReader)
}

// NewCreateBlogpostPropertyRequestWithBody generates requests for CreateBlogpostProperty with any type of body
func NewCreateBlogpostPropertyRequestWithBody(server string, blogpostId int64, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "blogpost-id", runtime.ParamLocationPath, blogpostId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/blogposts/%s/properties", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteBlogpostPropertyByIdRequest generates requests for DeleteBlogpostPropertyById
func NewDeleteBlogpostPropertyByIdRequest(server string, blogpostId int64, propertyId int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "blogpost-id", runtime.ParamLocationPath, blogpostId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "property-id", runtime.ParamLocationPath, propertyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/blogposts/%s/properties/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBlogpostContentPropertiesByIdRequest generates requests for GetBlogpostContentPropertiesById
func NewGetBlogpostContentPropertiesByIdRequest(server string, blogpostId int64, propertyId int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "blogpost-id", runtime.ParamLocationPath, blogpostId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "property-id", runtime.ParamLocationPath, propertyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/blogposts/%s/properties/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateBlogpostPropertyByIdRequest calls the generic UpdateBlogpostPropertyById builder with application/json body
func NewUpdateBlogpostPropertyByIdRequest(server string, blogpostId int64, propertyId int64, body UpdateBlogpostPropertyByIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateBlogpostPropertyByIdRequestWithBody(server, blogpostId, propertyId, "application/json", bodyReader)
}

// NewUpdateBlogpostPropertyByIdRequestWithBody generates requests for UpdateBlogpostPropertyById with any type of body
func NewUpdateBlogpostPropertyByIdRequestWithBody(server string, blogpostId int64, propertyId int64, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "blogpost-id", runtime.ParamLocationPath, blogpostId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "property-id", runtime.ParamLocationPath, propertyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/blogposts/%s/properties/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetBlogPostVersionDetailsRequest generates requests for GetBlogPostVersionDetails
func NewGetBlogPostVersionDetailsRequest(server string, blogpostId int64, versionNumber int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "blogpost-id", runtime.ParamLocationPath, blogpostId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "version-number", runtime.ParamLocationPath, versionNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/blogposts/%s/versions/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteBlogPostRequest generates requests for DeleteBlogPost
func NewDeleteBlogPostRequest(server string, id int64, params *DeleteBlogPostParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/blogposts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Purge != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "purge", runtime.ParamLocationQuery, *params.Purge); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Draft != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "draft", runtime.ParamLocationQuery, *params.Draft); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBlogPostByIdRequest generates requests for GetBlogPostById
func NewGetBlogPostByIdRequest(server string, id int64, params *GetBlogPostByIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/blogposts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.BodyFormat != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "body-format", runtime.ParamLocationQuery, *params.BodyFormat); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GetDraft != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "get-draft", runtime.ParamLocationQuery, *params.GetDraft); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeLabels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include-labels", runtime.ParamLocationQuery, *params.IncludeLabels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeProperties != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include-properties", runtime.ParamLocationQuery, *params.IncludeProperties); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeOperations != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include-operations", runtime.ParamLocationQuery, *params.IncludeOperations); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeLikes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include-likes", runtime.ParamLocationQuery, *params.IncludeLikes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeVersions != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include-versions", runtime.ParamLocationQuery, *params.IncludeVersions); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeVersion != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include-version", runtime.ParamLocationQuery, *params.IncludeVersion); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeFavoritedByCurrentUserStatus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include-favorited-by-current-user-status", runtime.ParamLocationQuery, *params.IncludeFavoritedByCurrentUserStatus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateBlogPostRequest calls the generic UpdateBlogPost builder with application/json body
func NewUpdateBlogPostRequest(server string, id int64, body UpdateBlogPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateBlogPostRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateBlogPostRequestWithBody generates requests for UpdateBlogPost with any type of body
func NewUpdateBlogPostRequestWithBody(server string, id int64, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/blogposts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetBlogpostAttachmentsRequest generates requests for GetBlogpostAttachments
func NewGetBlogpostAttachmentsRequest(server string, id int64, params *GetBlogpostAttachmentsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/blogposts/%s/attachments", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MediaType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mediaType", runtime.ParamLocationQuery, *params.MediaType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filename != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filename", runtime.ParamLocationQuery, *params.Filename); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBlogPostClassificationLevelRequest generates requests for GetBlogPostClassificationLevel
func NewGetBlogPostClassificationLevelRequest(server string, id int64, params *GetBlogPostClassificationLevelParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/blogposts/%s/classification-level", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutBlogPostClassificationLevelRequest calls the generic PutBlogPostClassificationLevel builder with application/json body
func NewPutBlogPostClassificationLevelRequest(server string, id int64, body PutBlogPostClassificationLevelJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutBlogPostClassificationLevelRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPutBlogPostClassificationLevelRequestWithBody generates requests for PutBlogPostClassificationLevel with any type of body
func NewPutBlogPostClassificationLevelRequestWithBody(server string, id int64, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/blogposts/%s/classification-level", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostBlogPostClassificationLevelRequest calls the generic PostBlogPostClassificationLevel builder with application/json body
func NewPostBlogPostClassificationLevelRequest(server string, id int64, body PostBlogPostClassificationLevelJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostBlogPostClassificationLevelRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPostBlogPostClassificationLevelRequestWithBody generates requests for PostBlogPostClassificationLevel with any type of body
func NewPostBlogPostClassificationLevelRequestWithBody(server string, id int64, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/blogposts/%s/classification-level/reset", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetCustomContentByTypeInBlogPostRequest generates requests for GetCustomContentByTypeInBlogPost
func NewGetCustomContentByTypeInBlogPostRequest(server string, id int64, params *GetCustomContentByTypeInBlogPostParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/blogposts/%s/custom-content", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, params.Type); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BodyFormat != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "body-format", runtime.ParamLocationQuery, *params.BodyFormat); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBlogPostFooterCommentsRequest generates requests for GetBlogPostFooterComments
func NewGetBlogPostFooterCommentsRequest(server string, id int64, params *GetBlogPostFooterCommentsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/blogposts/%s/footer-comments", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.BodyFormat != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "body-format", runtime.ParamLocationQuery, *params.BodyFormat); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBlogPostInlineCommentsRequest generates requests for GetBlogPostInlineComments
func NewGetBlogPostInlineCommentsRequest(server string, id int64, params *GetBlogPostInlineCommentsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/blogposts/%s/inline-comments", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.BodyFormat != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "body-format", runtime.ParamLocationQuery, *params.BodyFormat); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ResolutionStatus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resolution-status", runtime.ParamLocationQuery, *params.ResolutionStatus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBlogPostLabelsRequest generates requests for GetBlogPostLabels
func NewGetBlogPostLabelsRequest(server string, id int64, params *GetBlogPostLabelsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/blogposts/%s/labels", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Prefix != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefix", runtime.ParamLocationQuery, *params.Prefix); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBlogPostLikeCountRequest generates requests for GetBlogPostLikeCount
func NewGetBlogPostLikeCountRequest(server string, id int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/blogposts/%s/likes/count", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBlogPostLikeUsersRequest generates requests for GetBlogPostLikeUsers
func NewGetBlogPostLikeUsersRequest(server string, id int64, params *GetBlogPostLikeUsersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/blogposts/%s/likes/users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBlogPostOperationsRequest generates requests for GetBlogPostOperations
func NewGetBlogPostOperationsRequest(server string, id int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/blogposts/%s/operations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBlogPostVersionsRequest generates requests for GetBlogPostVersions
func NewGetBlogPostVersionsRequest(server string, id int64, params *GetBlogPostVersionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/blogposts/%s/versions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.BodyFormat != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "body-format", runtime.ParamLocationQuery, *params.BodyFormat); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetClassificationLevelsRequest generates requests for GetClassificationLevels
func NewGetClassificationLevelsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/classification-levels")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCommentContentPropertiesRequest generates requests for GetCommentContentProperties
func NewGetCommentContentPropertiesRequest(server string, commentId int64, params *GetCommentContentPropertiesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "comment-id", runtime.ParamLocationPath, commentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/comments/%s/properties", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Key != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "key", runtime.ParamLocationQuery, *params.Key); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateCommentPropertyRequest calls the generic CreateCommentProperty builder with application/json body
func NewCreateCommentPropertyRequest(server string, commentId int64, body CreateCommentPropertyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateCommentPropertyRequestWithBody(server, commentId, "application/json", bodyReader)
}

// NewCreateCommentPropertyRequestWithBody generates requests for CreateCommentProperty with any type of body
func NewCreateCommentPropertyRequestWithBody(server string, commentId int64, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "comment-id", runtime.ParamLocationPath, commentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/comments/%s/properties", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteCommentPropertyByIdRequest generates requests for DeleteCommentPropertyById
func NewDeleteCommentPropertyByIdRequest(server string, commentId int64, propertyId int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "comment-id", runtime.ParamLocationPath, commentId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "property-id", runtime.ParamLocationPath, propertyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/comments/%s/properties/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCommentContentPropertiesByIdRequest generates requests for GetCommentContentPropertiesById
func NewGetCommentContentPropertiesByIdRequest(server string, commentId int64, propertyId int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "comment-id", runtime.ParamLocationPath, commentId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "property-id", runtime.ParamLocationPath, propertyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/comments/%s/properties/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateCommentPropertyByIdRequest calls the generic UpdateCommentPropertyById builder with application/json body
func NewUpdateCommentPropertyByIdRequest(server string, commentId int64, propertyId int64, body UpdateCommentPropertyByIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateCommentPropertyByIdRequestWithBody(server, commentId, propertyId, "application/json", bodyReader)
}

// NewUpdateCommentPropertyByIdRequestWithBody generates requests for UpdateCommentPropertyById with any type of body
func NewUpdateCommentPropertyByIdRequestWithBody(server string, commentId int64, propertyId int64, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "comment-id", runtime.ParamLocationPath, commentId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "property-id", runtime.ParamLocationPath, propertyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/comments/%s/properties/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewConvertContentIdsToContentTypesRequest calls the generic ConvertContentIdsToContentTypes builder with application/json body
func NewConvertContentIdsToContentTypesRequest(server string, body ConvertContentIdsToContentTypesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewConvertContentIdsToContentTypesRequestWithBody(server, "application/json", bodyReader)
}

// NewConvertContentIdsToContentTypesRequestWithBody generates requests for ConvertContentIdsToContentTypes with any type of body
func NewConvertContentIdsToContentTypesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/content/convert-ids-to-types")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetCustomContentByTypeRequest generates requests for GetCustomContentByType
func NewGetCustomContentByTypeRequest(server string, params *GetCustomContentByTypeParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/custom-content")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, params.Type); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SpaceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "space-id", runtime.ParamLocationQuery, *params.SpaceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BodyFormat != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "body-format", runtime.ParamLocationQuery, *params.BodyFormat); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateCustomContentRequest calls the generic CreateCustomContent builder with application/json body
func NewCreateCustomContentRequest(server string, body CreateCustomContentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateCustomContentRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateCustomContentRequestWithBody generates requests for CreateCustomContent with any type of body
func NewCreateCustomContentRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/custom-content")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetCustomContentContentPropertiesRequest generates requests for GetCustomContentContentProperties
func NewGetCustomContentContentPropertiesRequest(server string, customContentId int64, params *GetCustomContentContentPropertiesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "custom-content-id", runtime.ParamLocationPath, customContentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/custom-content/%s/properties", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Key != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "key", runtime.ParamLocationQuery, *params.Key); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateCustomContentPropertyRequest calls the generic CreateCustomContentProperty builder with application/json body
func NewCreateCustomContentPropertyRequest(server string, customContentId int64, body CreateCustomContentPropertyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateCustomContentPropertyRequestWithBody(server, customContentId, "application/json", bodyReader)
}

// NewCreateCustomContentPropertyRequestWithBody generates requests for CreateCustomContentProperty with any type of body
func NewCreateCustomContentPropertyRequestWithBody(server string, customContentId int64, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "custom-content-id", runtime.ParamLocationPath, customContentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/custom-content/%s/properties", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteCustomContentPropertyByIdRequest generates requests for DeleteCustomContentPropertyById
func NewDeleteCustomContentPropertyByIdRequest(server string, customContentId int64, propertyId int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "custom-content-id", runtime.ParamLocationPath, customContentId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "property-id", runtime.ParamLocationPath, propertyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/custom-content/%s/properties/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCustomContentContentPropertiesByIdRequest generates requests for GetCustomContentContentPropertiesById
func NewGetCustomContentContentPropertiesByIdRequest(server string, customContentId int64, propertyId int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "custom-content-id", runtime.ParamLocationPath, customContentId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "property-id", runtime.ParamLocationPath, propertyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/custom-content/%s/properties/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateCustomContentPropertyByIdRequest calls the generic UpdateCustomContentPropertyById builder with application/json body
func NewUpdateCustomContentPropertyByIdRequest(server string, customContentId int64, propertyId int64, body UpdateCustomContentPropertyByIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateCustomContentPropertyByIdRequestWithBody(server, customContentId, propertyId, "application/json", bodyReader)
}

// NewUpdateCustomContentPropertyByIdRequestWithBody generates requests for UpdateCustomContentPropertyById with any type of body
func NewUpdateCustomContentPropertyByIdRequestWithBody(server string, customContentId int64, propertyId int64, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "custom-content-id", runtime.ParamLocationPath, customContentId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "property-id", runtime.ParamLocationPath, propertyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/custom-content/%s/properties/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetCustomContentVersionsRequest generates requests for GetCustomContentVersions
func NewGetCustomContentVersionsRequest(server string, customContentId int64, params *GetCustomContentVersionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "custom-content-id", runtime.ParamLocationPath, customContentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/custom-content/%s/versions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.BodyFormat != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "body-format", runtime.ParamLocationQuery, *params.BodyFormat); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCustomContentVersionDetailsRequest generates requests for GetCustomContentVersionDetails
func NewGetCustomContentVersionDetailsRequest(server string, customContentId int64, versionNumber int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "custom-content-id", runtime.ParamLocationPath, customContentId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "version-number", runtime.ParamLocationPath, versionNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/custom-content/%s/versions/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteCustomContentRequest generates requests for DeleteCustomContent
func NewDeleteCustomContentRequest(server string, id int64, params *DeleteCustomContentParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/custom-content/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Purge != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "purge", runtime.ParamLocationQuery, *params.Purge); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCustomContentByIdRequest generates requests for GetCustomContentById
func NewGetCustomContentByIdRequest(server string, id int64, params *GetCustomContentByIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/custom-content/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.BodyFormat != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "body-format", runtime.ParamLocationQuery, *params.BodyFormat); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeLabels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include-labels", runtime.ParamLocationQuery, *params.IncludeLabels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeProperties != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include-properties", runtime.ParamLocationQuery, *params.IncludeProperties); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeOperations != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include-operations", runtime.ParamLocationQuery, *params.IncludeOperations); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeVersions != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include-versions", runtime.ParamLocationQuery, *params.IncludeVersions); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeVersion != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include-version", runtime.ParamLocationQuery, *params.IncludeVersion); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateCustomContentRequest calls the generic UpdateCustomContent builder with application/json body
func NewUpdateCustomContentRequest(server string, id int64, body UpdateCustomContentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateCustomContentRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateCustomContentRequestWithBody generates requests for UpdateCustomContent with any type of body
func NewUpdateCustomContentRequestWithBody(server string, id int64, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/custom-content/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetCustomContentAttachmentsRequest generates requests for GetCustomContentAttachments
func NewGetCustomContentAttachmentsRequest(server string, id int64, params *GetCustomContentAttachmentsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/custom-content/%s/attachments", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MediaType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mediaType", runtime.ParamLocationQuery, *params.MediaType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filename != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filename", runtime.ParamLocationQuery, *params.Filename); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetChildCustomContentRequest generates requests for GetChildCustomContent
func NewGetChildCustomContentRequest(server string, id int64, params *GetChildCustomContentParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/custom-content/%s/children", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCustomContentCommentsRequest generates requests for GetCustomContentComments
func NewGetCustomContentCommentsRequest(server string, id int64, params *GetCustomContentCommentsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/custom-content/%s/footer-comments", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.BodyFormat != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "body-format", runtime.ParamLocationQuery, *params.BodyFormat); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCustomContentLabelsRequest generates requests for GetCustomContentLabels
func NewGetCustomContentLabelsRequest(server string, id int64, params *GetCustomContentLabelsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/custom-content/%s/labels", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Prefix != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefix", runtime.ParamLocationQuery, *params.Prefix); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCustomContentOperationsRequest generates requests for GetCustomContentOperations
func NewGetCustomContentOperationsRequest(server string, id int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/custom-content/%s/operations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDataPolicyMetadataRequest generates requests for GetDataPolicyMetadata
func NewGetDataPolicyMetadataRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/data-policies/metadata")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDataPolicySpacesRequest generates requests for GetDataPolicySpaces
func NewGetDataPolicySpacesRequest(server string, params *GetDataPolicySpacesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/data-policies/spaces")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Keys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "keys", runtime.ParamLocationQuery, *params.Keys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateDatabaseRequest calls the generic CreateDatabase builder with application/json body
func NewCreateDatabaseRequest(server string, params *CreateDatabaseParams, body CreateDatabaseJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateDatabaseRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateDatabaseRequestWithBody generates requests for CreateDatabase with any type of body
func NewCreateDatabaseRequestWithBody(server string, params *CreateDatabaseParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/databases")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Private != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "private", runtime.ParamLocationQuery, *params.Private); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteDatabasePropertyByIdRequest generates requests for DeleteDatabasePropertyById
func NewDeleteDatabasePropertyByIdRequest(server string, databaseId int64, propertyId int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "database-id", runtime.ParamLocationPath, databaseId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "property-id", runtime.ParamLocationPath, propertyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/databases/%s/properties/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDatabaseContentPropertiesByIdRequest generates requests for GetDatabaseContentPropertiesById
func NewGetDatabaseContentPropertiesByIdRequest(server string, databaseId int64, propertyId int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "database-id", runtime.ParamLocationPath, databaseId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "property-id", runtime.ParamLocationPath, propertyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/databases/%s/properties/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateDatabasePropertyByIdRequest calls the generic UpdateDatabasePropertyById builder with application/json body
func NewUpdateDatabasePropertyByIdRequest(server string, databaseId int64, propertyId int64, body UpdateDatabasePropertyByIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateDatabasePropertyByIdRequestWithBody(server, databaseId, propertyId, "application/json", bodyReader)
}

// NewUpdateDatabasePropertyByIdRequestWithBody generates requests for UpdateDatabasePropertyById with any type of body
func NewUpdateDatabasePropertyByIdRequestWithBody(server string, databaseId int64, propertyId int64, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "database-id", runtime.ParamLocationPath, databaseId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "property-id", runtime.ParamLocationPath, propertyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/databases/%s/properties/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteDatabaseRequest generates requests for DeleteDatabase
func NewDeleteDatabaseRequest(server string, id int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/databases/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDatabaseByIdRequest generates requests for GetDatabaseById
func NewGetDatabaseByIdRequest(server string, id int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/databases/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDatabaseAncestorsRequest generates requests for GetDatabaseAncestors
func NewGetDatabaseAncestorsRequest(server string, id int64, params *GetDatabaseAncestorsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/databases/%s/ancestors", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDatabaseClassificationLevelRequest generates requests for GetDatabaseClassificationLevel
func NewGetDatabaseClassificationLevelRequest(server string, id int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/databases/%s/classification-level", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutDatabaseClassificationLevelRequest calls the generic PutDatabaseClassificationLevel builder with application/json body
func NewPutDatabaseClassificationLevelRequest(server string, id int64, body PutDatabaseClassificationLevelJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutDatabaseClassificationLevelRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPutDatabaseClassificationLevelRequestWithBody generates requests for PutDatabaseClassificationLevel with any type of body
func NewPutDatabaseClassificationLevelRequestWithBody(server string, id int64, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/databases/%s/classification-level", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostDatabaseClassificationLevelRequest calls the generic PostDatabaseClassificationLevel builder with application/json body
func NewPostDatabaseClassificationLevelRequest(server string, id int64, body PostDatabaseClassificationLevelJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostDatabaseClassificationLevelRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPostDatabaseClassificationLevelRequestWithBody generates requests for PostDatabaseClassificationLevel with any type of body
func NewPostDatabaseClassificationLevelRequestWithBody(server string, id int64, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/databases/%s/classification-level/reset", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetDatabaseOperationsRequest generates requests for GetDatabaseOperations
func NewGetDatabaseOperationsRequest(server string, id int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/databases/%s/operations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDatabaseContentPropertiesRequest generates requests for GetDatabaseContentProperties
func NewGetDatabaseContentPropertiesRequest(server string, id int64, params *GetDatabaseContentPropertiesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/databases/%s/properties", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Key != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "key", runtime.ParamLocationQuery, *params.Key); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateDatabasePropertyRequest calls the generic CreateDatabaseProperty builder with application/json body
func NewCreateDatabasePropertyRequest(server string, id int64, body CreateDatabasePropertyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateDatabasePropertyRequestWithBody(server, id, "application/json", bodyReader)
}

// NewCreateDatabasePropertyRequestWithBody generates requests for CreateDatabaseProperty with any type of body
func NewCreateDatabasePropertyRequestWithBody(server string, id int64, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/databases/%s/properties", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateSmartLinkRequest calls the generic CreateSmartLink builder with application/json body
func NewCreateSmartLinkRequest(server string, body CreateSmartLinkJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSmartLinkRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateSmartLinkRequestWithBody generates requests for CreateSmartLink with any type of body
func NewCreateSmartLinkRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/embeds")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSmartLinkPropertyByIdRequest generates requests for DeleteSmartLinkPropertyById
func NewDeleteSmartLinkPropertyByIdRequest(server string, embedId int64, propertyId int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "embed-id", runtime.ParamLocationPath, embedId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "property-id", runtime.ParamLocationPath, propertyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/embeds/%s/properties/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSmartLinkContentPropertiesByIdRequest generates requests for GetSmartLinkContentPropertiesById
func NewGetSmartLinkContentPropertiesByIdRequest(server string, embedId int64, propertyId int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "embed-id", runtime.ParamLocationPath, embedId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "property-id", runtime.ParamLocationPath, propertyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/embeds/%s/properties/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateSmartLinkPropertyByIdRequest calls the generic UpdateSmartLinkPropertyById builder with application/json body
func NewUpdateSmartLinkPropertyByIdRequest(server string, embedId int64, propertyId int64, body UpdateSmartLinkPropertyByIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateSmartLinkPropertyByIdRequestWithBody(server, embedId, propertyId, "application/json", bodyReader)
}

// NewUpdateSmartLinkPropertyByIdRequestWithBody generates requests for UpdateSmartLinkPropertyById with any type of body
func NewUpdateSmartLinkPropertyByIdRequestWithBody(server string, embedId int64, propertyId int64, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "embed-id", runtime.ParamLocationPath, embedId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "property-id", runtime.ParamLocationPath, propertyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/embeds/%s/properties/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSmartLinkRequest generates requests for DeleteSmartLink
func NewDeleteSmartLinkRequest(server string, id int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/embeds/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSmartLinkByIdRequest generates requests for GetSmartLinkById
func NewGetSmartLinkByIdRequest(server string, id int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/embeds/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSmartLinkAncestorsRequest generates requests for GetSmartLinkAncestors
func NewGetSmartLinkAncestorsRequest(server string, id int64, params *GetSmartLinkAncestorsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/embeds/%s/ancestors", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSmartLinkOperationsRequest generates requests for GetSmartLinkOperations
func NewGetSmartLinkOperationsRequest(server string, id int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/embeds/%s/operations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSmartLinkContentPropertiesRequest generates requests for GetSmartLinkContentProperties
func NewGetSmartLinkContentPropertiesRequest(server string, id int64, params *GetSmartLinkContentPropertiesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/embeds/%s/properties", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Key != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "key", runtime.ParamLocationQuery, *params.Key); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSmartLinkPropertyRequest calls the generic CreateSmartLinkProperty builder with application/json body
func NewCreateSmartLinkPropertyRequest(server string, id int64, body CreateSmartLinkPropertyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSmartLinkPropertyRequestWithBody(server, id, "application/json", bodyReader)
}

// NewCreateSmartLinkPropertyRequestWithBody generates requests for CreateSmartLinkProperty with any type of body
func NewCreateSmartLinkPropertyRequestWithBody(server string, id int64, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/embeds/%s/properties", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateFolderRequest calls the generic CreateFolder builder with application/json body
func NewCreateFolderRequest(server string, body CreateFolderJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateFolderRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateFolderRequestWithBody generates requests for CreateFolder with any type of body
func NewCreateFolderRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/folders")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteFolderPropertyByIdRequest generates requests for DeleteFolderPropertyById
func NewDeleteFolderPropertyByIdRequest(server string, folderId int64, propertyId int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "folder-id", runtime.ParamLocationPath, folderId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "property-id", runtime.ParamLocationPath, propertyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/folders/%s/properties/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFolderContentPropertiesByIdRequest generates requests for GetFolderContentPropertiesById
func NewGetFolderContentPropertiesByIdRequest(server string, folderId int64, propertyId int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "folder-id", runtime.ParamLocationPath, folderId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "property-id", runtime.ParamLocationPath, propertyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/folders/%s/properties/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateFolderPropertyByIdRequest calls the generic UpdateFolderPropertyById builder with application/json body
func NewUpdateFolderPropertyByIdRequest(server string, folderId int64, propertyId int64, body UpdateFolderPropertyByIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateFolderPropertyByIdRequestWithBody(server, folderId, propertyId, "application/json", bodyReader)
}

// NewUpdateFolderPropertyByIdRequestWithBody generates requests for UpdateFolderPropertyById with any type of body
func NewUpdateFolderPropertyByIdRequestWithBody(server string, folderId int64, propertyId int64, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "folder-id", runtime.ParamLocationPath, folderId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "property-id", runtime.ParamLocationPath, propertyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/folders/%s/properties/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteFolderRequest generates requests for DeleteFolder
func NewDeleteFolderRequest(server string, id int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/folders/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFolderByIdRequest generates requests for GetFolderById
func NewGetFolderByIdRequest(server string, id int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/folders/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFolderAncestorsRequest generates requests for GetFolderAncestors
func NewGetFolderAncestorsRequest(server string, id int64, params *GetFolderAncestorsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/folders/%s/ancestors", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFolderOperationsRequest generates requests for GetFolderOperations
func NewGetFolderOperationsRequest(server string, id int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/folders/%s/operations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFolderContentPropertiesRequest generates requests for GetFolderContentProperties
func NewGetFolderContentPropertiesRequest(server string, id int64, params *GetFolderContentPropertiesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/folders/%s/properties", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Key != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "key", runtime.ParamLocationQuery, *params.Key); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateFolderPropertyRequest calls the generic CreateFolderProperty builder with application/json body
func NewCreateFolderPropertyRequest(server string, id int64, body CreateFolderPropertyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateFolderPropertyRequestWithBody(server, id, "application/json", bodyReader)
}

// NewCreateFolderPropertyRequestWithBody generates requests for CreateFolderProperty with any type of body
func NewCreateFolderPropertyRequestWithBody(server string, id int64, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/folders/%s/properties", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetFooterCommentsRequest generates requests for GetFooterComments
func NewGetFooterCommentsRequest(server string, params *GetFooterCommentsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/footer-comments")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.BodyFormat != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "body-format", runtime.ParamLocationQuery, *params.BodyFormat); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateFooterCommentRequest calls the generic CreateFooterComment builder with application/json body
func NewCreateFooterCommentRequest(server string, body CreateFooterCommentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateFooterCommentRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateFooterCommentRequestWithBody generates requests for CreateFooterComment with any type of body
func NewCreateFooterCommentRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/footer-comments")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteFooterCommentRequest generates requests for DeleteFooterComment
func NewDeleteFooterCommentRequest(server string, commentId int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "comment-id", runtime.ParamLocationPath, commentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/footer-comments/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFooterCommentByIdRequest generates requests for GetFooterCommentById
func NewGetFooterCommentByIdRequest(server string, commentId int64, params *GetFooterCommentByIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "comment-id", runtime.ParamLocationPath, commentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/footer-comments/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.BodyFormat != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "body-format", runtime.ParamLocationQuery, *params.BodyFormat); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeProperties != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include-properties", runtime.ParamLocationQuery, *params.IncludeProperties); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeOperations != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include-operations", runtime.ParamLocationQuery, *params.IncludeOperations); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeLikes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include-likes", runtime.ParamLocationQuery, *params.IncludeLikes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeVersions != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include-versions", runtime.ParamLocationQuery, *params.IncludeVersions); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeVersion != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include-version", runtime.ParamLocationQuery, *params.IncludeVersion); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateFooterCommentRequest calls the generic UpdateFooterComment builder with application/json body
func NewUpdateFooterCommentRequest(server string, commentId int64, body UpdateFooterCommentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateFooterCommentRequestWithBody(server, commentId, "application/json", bodyReader)
}

// NewUpdateFooterCommentRequestWithBody generates requests for UpdateFooterComment with any type of body
func NewUpdateFooterCommentRequestWithBody(server string, commentId int64, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "comment-id", runtime.ParamLocationPath, commentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/footer-comments/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetFooterCommentChildrenRequest generates requests for GetFooterCommentChildren
func NewGetFooterCommentChildrenRequest(server string, id int64, params *GetFooterCommentChildrenParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/footer-comments/%s/children", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.BodyFormat != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "body-format", runtime.ParamLocationQuery, *params.BodyFormat); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFooterLikeCountRequest generates requests for GetFooterLikeCount
func NewGetFooterLikeCountRequest(server string, id int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/footer-comments/%s/likes/count", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFooterLikeUsersRequest generates requests for GetFooterLikeUsers
func NewGetFooterLikeUsersRequest(server string, id int64, params *GetFooterLikeUsersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/footer-comments/%s/likes/users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFooterCommentOperationsRequest generates requests for GetFooterCommentOperations
func NewGetFooterCommentOperationsRequest(server string, id int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/footer-comments/%s/operations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFooterCommentVersionsRequest generates requests for GetFooterCommentVersions
func NewGetFooterCommentVersionsRequest(server string, id int64, params *GetFooterCommentVersionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/footer-comments/%s/versions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.BodyFormat != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "body-format", runtime.ParamLocationQuery, *params.BodyFormat); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFooterCommentVersionDetailsRequest generates requests for GetFooterCommentVersionDetails
func NewGetFooterCommentVersionDetailsRequest(server string, id int64, versionNumber int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "version-number", runtime.ParamLocationPath, versionNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/footer-comments/%s/versions/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInlineCommentsRequest generates requests for GetInlineComments
func NewGetInlineCommentsRequest(server string, params *GetInlineCommentsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inline-comments")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.BodyFormat != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "body-format", runtime.ParamLocationQuery, *params.BodyFormat); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateInlineCommentRequest calls the generic CreateInlineComment builder with application/json body
func NewCreateInlineCommentRequest(server string, body CreateInlineCommentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateInlineCommentRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateInlineCommentRequestWithBody generates requests for CreateInlineComment with any type of body
func NewCreateInlineCommentRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inline-comments")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteInlineCommentRequest generates requests for DeleteInlineComment
func NewDeleteInlineCommentRequest(server string, commentId int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "comment-id", runtime.ParamLocationPath, commentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inline-comments/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInlineCommentByIdRequest generates requests for GetInlineCommentById
func NewGetInlineCommentByIdRequest(server string, commentId int64, params *GetInlineCommentByIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "comment-id", runtime.ParamLocationPath, commentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inline-comments/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.BodyFormat != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "body-format", runtime.ParamLocationQuery, *params.BodyFormat); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeProperties != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include-properties", runtime.ParamLocationQuery, *params.IncludeProperties); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeOperations != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include-operations", runtime.ParamLocationQuery, *params.IncludeOperations); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeLikes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include-likes", runtime.ParamLocationQuery, *params.IncludeLikes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeVersions != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include-versions", runtime.ParamLocationQuery, *params.IncludeVersions); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeVersion != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include-version", runtime.ParamLocationQuery, *params.IncludeVersion); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateInlineCommentRequest calls the generic UpdateInlineComment builder with application/json body
func NewUpdateInlineCommentRequest(server string, commentId int64, body UpdateInlineCommentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateInlineCommentRequestWithBody(server, commentId, "application/json", bodyReader)
}

// NewUpdateInlineCommentRequestWithBody generates requests for UpdateInlineComment with any type of body
func NewUpdateInlineCommentRequestWithBody(server string, commentId int64, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "comment-id", runtime.ParamLocationPath, commentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inline-comments/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetInlineCommentChildrenRequest generates requests for GetInlineCommentChildren
func NewGetInlineCommentChildrenRequest(server string, id int64, params *GetInlineCommentChildrenParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inline-comments/%s/children", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.BodyFormat != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "body-format", runtime.ParamLocationQuery, *params.BodyFormat); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInlineLikeCountRequest generates requests for GetInlineLikeCount
func NewGetInlineLikeCountRequest(server string, id int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inline-comments/%s/likes/count", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInlineLikeUsersRequest generates requests for GetInlineLikeUsers
func NewGetInlineLikeUsersRequest(server string, id int64, params *GetInlineLikeUsersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inline-comments/%s/likes/users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInlineCommentOperationsRequest generates requests for GetInlineCommentOperations
func NewGetInlineCommentOperationsRequest(server string, id int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inline-comments/%s/operations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInlineCommentVersionsRequest generates requests for GetInlineCommentVersions
func NewGetInlineCommentVersionsRequest(server string, id int64, params *GetInlineCommentVersionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inline-comments/%s/versions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.BodyFormat != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "body-format", runtime.ParamLocationQuery, *params.BodyFormat); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInlineCommentVersionDetailsRequest generates requests for GetInlineCommentVersionDetails
func NewGetInlineCommentVersionDetailsRequest(server string, id int64, versionNumber int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "version-number", runtime.ParamLocationPath, versionNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inline-comments/%s/versions/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLabelsRequest generates requests for GetLabels
func NewGetLabelsRequest(server string, params *GetLabelsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/labels")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.LabelId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "label-id", runtime.ParamLocationQuery, *params.LabelId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Prefix != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefix", runtime.ParamLocationQuery, *params.Prefix); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLabelAttachmentsRequest generates requests for GetLabelAttachments
func NewGetLabelAttachmentsRequest(server string, id int64, params *GetLabelAttachmentsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/labels/%s/attachments", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLabelBlogPostsRequest generates requests for GetLabelBlogPosts
func NewGetLabelBlogPostsRequest(server string, id int64, params *GetLabelBlogPostsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/labels/%s/blogposts", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SpaceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "space-id", runtime.ParamLocationQuery, *params.SpaceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BodyFormat != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "body-format", runtime.ParamLocationQuery, *params.BodyFormat); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLabelPagesRequest generates requests for GetLabelPages
func NewGetLabelPagesRequest(server string, id int64, params *GetLabelPagesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/labels/%s/pages", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SpaceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "space-id", runtime.ParamLocationQuery, *params.SpaceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BodyFormat != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "body-format", runtime.ParamLocationQuery, *params.BodyFormat); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPagesRequest generates requests for GetPages
func NewGetPagesRequest(server string, params *GetPagesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/pages")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SpaceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "space-id", runtime.ParamLocationQuery, *params.SpaceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Title != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "title", runtime.ParamLocationQuery, *params.Title); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BodyFormat != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "body-format", runtime.ParamLocationQuery, *params.BodyFormat); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreatePageRequest calls the generic CreatePage builder with application/json body
func NewCreatePageRequest(server string, params *CreatePageParams, body CreatePageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePageRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreatePageRequestWithBody generates requests for CreatePage with any type of body
func NewCreatePageRequestWithBody(server string, params *CreatePageParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/pages")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Embedded != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "embedded", runtime.ParamLocationQuery, *params.Embedded); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Private != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "private", runtime.ParamLocationQuery, *params.Private); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RootLevel != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "root-level", runtime.ParamLocationQuery, *params.RootLevel); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeletePageRequest generates requests for DeletePage
func NewDeletePageRequest(server string, id int64, params *DeletePageParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/pages/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Purge != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "purge", runtime.ParamLocationQuery, *params.Purge); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Draft != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "draft", runtime.ParamLocationQuery, *params.Draft); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPageByIdRequest generates requests for GetPageById
func NewGetPageByIdRequest(server string, id int64, params *GetPageByIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/pages/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.BodyFormat != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "body-format", runtime.ParamLocationQuery, *params.BodyFormat); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GetDraft != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "get-draft", runtime.ParamLocationQuery, *params.GetDraft); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeLabels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include-labels", runtime.ParamLocationQuery, *params.IncludeLabels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeProperties != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include-properties", runtime.ParamLocationQuery, *params.IncludeProperties); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeOperations != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include-operations", runtime.ParamLocationQuery, *params.IncludeOperations); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeLikes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include-likes", runtime.ParamLocationQuery, *params.IncludeLikes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeVersions != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include-versions", runtime.ParamLocationQuery, *params.IncludeVersions); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeVersion != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include-version", runtime.ParamLocationQuery, *params.IncludeVersion); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeFavoritedByCurrentUserStatus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include-favorited-by-current-user-status", runtime.ParamLocationQuery, *params.IncludeFavoritedByCurrentUserStatus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdatePageRequest calls the generic UpdatePage builder with application/json body
func NewUpdatePageRequest(server string, id int64, body UpdatePageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdatePageRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdatePageRequestWithBody generates requests for UpdatePage with any type of body
func NewUpdatePageRequestWithBody(server string, id int64, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/pages/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPageAncestorsRequest generates requests for GetPageAncestors
func NewGetPageAncestorsRequest(server string, id int64, params *GetPageAncestorsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/pages/%s/ancestors", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPageAttachmentsRequest generates requests for GetPageAttachments
func NewGetPageAttachmentsRequest(server string, id int64, params *GetPageAttachmentsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/pages/%s/attachments", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MediaType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mediaType", runtime.ParamLocationQuery, *params.MediaType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filename != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filename", runtime.ParamLocationQuery, *params.Filename); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetChildPagesRequest generates requests for GetChildPages
func NewGetChildPagesRequest(server string, id int64, params *GetChildPagesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/pages/%s/children", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPageClassificationLevelRequest generates requests for GetPageClassificationLevel
func NewGetPageClassificationLevelRequest(server string, id int64, params *GetPageClassificationLevelParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/pages/%s/classification-level", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutPageClassificationLevelRequest calls the generic PutPageClassificationLevel builder with application/json body
func NewPutPageClassificationLevelRequest(server string, id int64, body PutPageClassificationLevelJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutPageClassificationLevelRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPutPageClassificationLevelRequestWithBody generates requests for PutPageClassificationLevel with any type of body
func NewPutPageClassificationLevelRequestWithBody(server string, id int64, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/pages/%s/classification-level", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostPageClassificationLevelRequest calls the generic PostPageClassificationLevel builder with application/json body
func NewPostPageClassificationLevelRequest(server string, id int64, body PostPageClassificationLevelJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostPageClassificationLevelRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPostPageClassificationLevelRequestWithBody generates requests for PostPageClassificationLevel with any type of body
func NewPostPageClassificationLevelRequestWithBody(server string, id int64, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/pages/%s/classification-level/reset", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetCustomContentByTypeInPageRequest generates requests for GetCustomContentByTypeInPage
func NewGetCustomContentByTypeInPageRequest(server string, id int64, params *GetCustomContentByTypeInPageParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/pages/%s/custom-content", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, params.Type); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BodyFormat != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "body-format", runtime.ParamLocationQuery, *params.BodyFormat); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPageFooterCommentsRequest generates requests for GetPageFooterComments
func NewGetPageFooterCommentsRequest(server string, id int64, params *GetPageFooterCommentsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/pages/%s/footer-comments", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.BodyFormat != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "body-format", runtime.ParamLocationQuery, *params.BodyFormat); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPageInlineCommentsRequest generates requests for GetPageInlineComments
func NewGetPageInlineCommentsRequest(server string, id int64, params *GetPageInlineCommentsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/pages/%s/inline-comments", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.BodyFormat != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "body-format", runtime.ParamLocationQuery, *params.BodyFormat); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ResolutionStatus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resolution-status", runtime.ParamLocationQuery, *params.ResolutionStatus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPageLabelsRequest generates requests for GetPageLabels
func NewGetPageLabelsRequest(server string, id int64, params *GetPageLabelsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/pages/%s/labels", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Prefix != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefix", runtime.ParamLocationQuery, *params.Prefix); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPageLikeCountRequest generates requests for GetPageLikeCount
func NewGetPageLikeCountRequest(server string, id int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/pages/%s/likes/count", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPageLikeUsersRequest generates requests for GetPageLikeUsers
func NewGetPageLikeUsersRequest(server string, id int64, params *GetPageLikeUsersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/pages/%s/likes/users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPageOperationsRequest generates requests for GetPageOperations
func NewGetPageOperationsRequest(server string, id int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/pages/%s/operations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPageVersionsRequest generates requests for GetPageVersions
func NewGetPageVersionsRequest(server string, id int64, params *GetPageVersionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/pages/%s/versions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.BodyFormat != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "body-format", runtime.ParamLocationQuery, *params.BodyFormat); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPageContentPropertiesRequest generates requests for GetPageContentProperties
func NewGetPageContentPropertiesRequest(server string, pageId int64, params *GetPageContentPropertiesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "page-id", runtime.ParamLocationPath, pageId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/pages/%s/properties", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Key != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "key", runtime.ParamLocationQuery, *params.Key); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreatePagePropertyRequest calls the generic CreatePageProperty builder with application/json body
func NewCreatePagePropertyRequest(server string, pageId int64, body CreatePagePropertyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePagePropertyRequestWithBody(server, pageId, "application/json", bodyReader)
}

// NewCreatePagePropertyRequestWithBody generates requests for CreatePageProperty with any type of body
func NewCreatePagePropertyRequestWithBody(server string, pageId int64, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "page-id", runtime.ParamLocationPath, pageId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/pages/%s/properties", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeletePagePropertyByIdRequest generates requests for DeletePagePropertyById
func NewDeletePagePropertyByIdRequest(server string, pageId int64, propertyId int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "page-id", runtime.ParamLocationPath, pageId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "property-id", runtime.ParamLocationPath, propertyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/pages/%s/properties/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPageContentPropertiesByIdRequest generates requests for GetPageContentPropertiesById
func NewGetPageContentPropertiesByIdRequest(server string, pageId int64, propertyId int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "page-id", runtime.ParamLocationPath, pageId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "property-id", runtime.ParamLocationPath, propertyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/pages/%s/properties/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdatePagePropertyByIdRequest calls the generic UpdatePagePropertyById builder with application/json body
func NewUpdatePagePropertyByIdRequest(server string, pageId int64, propertyId int64, body UpdatePagePropertyByIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdatePagePropertyByIdRequestWithBody(server, pageId, propertyId, "application/json", bodyReader)
}

// NewUpdatePagePropertyByIdRequestWithBody generates requests for UpdatePagePropertyById with any type of body
func NewUpdatePagePropertyByIdRequestWithBody(server string, pageId int64, propertyId int64, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "page-id", runtime.ParamLocationPath, pageId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "property-id", runtime.ParamLocationPath, propertyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/pages/%s/properties/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPageVersionDetailsRequest generates requests for GetPageVersionDetails
func NewGetPageVersionDetailsRequest(server string, pageId int64, versionNumber int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "page-id", runtime.ParamLocationPath, pageId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "version-number", runtime.ParamLocationPath, versionNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/pages/%s/versions/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSpacesRequest generates requests for GetSpaces
func NewGetSpacesRequest(server string, params *GetSpacesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/spaces")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Keys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "keys", runtime.ParamLocationQuery, *params.Keys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Labels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "labels", runtime.ParamLocationQuery, *params.Labels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FavoritedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "favorited-by", runtime.ParamLocationQuery, *params.FavoritedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NotFavoritedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "not-favorited-by", runtime.ParamLocationQuery, *params.NotFavoritedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DescriptionFormat != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "description-format", runtime.ParamLocationQuery, *params.DescriptionFormat); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeIcon != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include-icon", runtime.ParamLocationQuery, *params.IncludeIcon); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSpaceByIdRequest generates requests for GetSpaceById
func NewGetSpaceByIdRequest(server string, id int64, params *GetSpaceByIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/spaces/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.DescriptionFormat != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "description-format", runtime.ParamLocationQuery, *params.DescriptionFormat); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeIcon != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include-icon", runtime.ParamLocationQuery, *params.IncludeIcon); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeOperations != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include-operations", runtime.ParamLocationQuery, *params.IncludeOperations); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeProperties != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include-properties", runtime.ParamLocationQuery, *params.IncludeProperties); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludePermissions != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include-permissions", runtime.ParamLocationQuery, *params.IncludePermissions); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeLabels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include-labels", runtime.ParamLocationQuery, *params.IncludeLabels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBlogPostsInSpaceRequest generates requests for GetBlogPostsInSpace
func NewGetBlogPostsInSpaceRequest(server string, id int64, params *GetBlogPostsInSpaceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/spaces/%s/blogposts", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Title != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "title", runtime.ParamLocationQuery, *params.Title); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BodyFormat != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "body-format", runtime.ParamLocationQuery, *params.BodyFormat); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteSpaceDefaultClassificationLevelRequest generates requests for DeleteSpaceDefaultClassificationLevel
func NewDeleteSpaceDefaultClassificationLevelRequest(server string, id int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/spaces/%s/classification-level/default", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSpaceDefaultClassificationLevelRequest generates requests for GetSpaceDefaultClassificationLevel
func NewGetSpaceDefaultClassificationLevelRequest(server string, id int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/spaces/%s/classification-level/default", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutSpaceDefaultClassificationLevelRequest calls the generic PutSpaceDefaultClassificationLevel builder with application/json body
func NewPutSpaceDefaultClassificationLevelRequest(server string, id int64, body PutSpaceDefaultClassificationLevelJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutSpaceDefaultClassificationLevelRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPutSpaceDefaultClassificationLevelRequestWithBody generates requests for PutSpaceDefaultClassificationLevel with any type of body
func NewPutSpaceDefaultClassificationLevelRequestWithBody(server string, id int64, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/spaces/%s/classification-level/default", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSpaceContentLabelsRequest generates requests for GetSpaceContentLabels
func NewGetSpaceContentLabelsRequest(server string, id int64, params *GetSpaceContentLabelsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/spaces/%s/content/labels", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Prefix != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefix", runtime.ParamLocationQuery, *params.Prefix); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCustomContentByTypeInSpaceRequest generates requests for GetCustomContentByTypeInSpace
func NewGetCustomContentByTypeInSpaceRequest(server string, id int64, params *GetCustomContentByTypeInSpaceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/spaces/%s/custom-content", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, params.Type); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BodyFormat != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "body-format", runtime.ParamLocationQuery, *params.BodyFormat); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSpaceLabelsRequest generates requests for GetSpaceLabels
func NewGetSpaceLabelsRequest(server string, id int64, params *GetSpaceLabelsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/spaces/%s/labels", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Prefix != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefix", runtime.ParamLocationQuery, *params.Prefix); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSpaceOperationsRequest generates requests for GetSpaceOperations
func NewGetSpaceOperationsRequest(server string, id int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/spaces/%s/operations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPagesInSpaceRequest generates requests for GetPagesInSpace
func NewGetPagesInSpaceRequest(server string, id int64, params *GetPagesInSpaceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/spaces/%s/pages", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Title != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "title", runtime.ParamLocationQuery, *params.Title); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BodyFormat != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "body-format", runtime.ParamLocationQuery, *params.BodyFormat); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSpacePermissionsRequest generates requests for GetSpacePermissions
func NewGetSpacePermissionsRequest(server string, id int64, params *GetSpacePermissionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/spaces/%s/permissions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSpacePropertiesRequest generates requests for GetSpaceProperties
func NewGetSpacePropertiesRequest(server string, spaceId int64, params *GetSpacePropertiesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "space-id", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/spaces/%s/properties", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Key != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "key", runtime.ParamLocationQuery, *params.Key); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSpacePropertyRequest calls the generic CreateSpaceProperty builder with application/json body
func NewCreateSpacePropertyRequest(server string, spaceId int64, body CreateSpacePropertyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSpacePropertyRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateSpacePropertyRequestWithBody generates requests for CreateSpaceProperty with any type of body
func NewCreateSpacePropertyRequestWithBody(server string, spaceId int64, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "space-id", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/spaces/%s/properties", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSpacePropertyByIdRequest generates requests for DeleteSpacePropertyById
func NewDeleteSpacePropertyByIdRequest(server string, spaceId int64, propertyId int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "space-id", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "property-id", runtime.ParamLocationPath, propertyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/spaces/%s/properties/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSpacePropertyByIdRequest generates requests for GetSpacePropertyById
func NewGetSpacePropertyByIdRequest(server string, spaceId int64, propertyId int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "space-id", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "property-id", runtime.ParamLocationPath, propertyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/spaces/%s/properties/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateSpacePropertyByIdRequest calls the generic UpdateSpacePropertyById builder with application/json body
func NewUpdateSpacePropertyByIdRequest(server string, spaceId int64, propertyId int64, body UpdateSpacePropertyByIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateSpacePropertyByIdRequestWithBody(server, spaceId, propertyId, "application/json", bodyReader)
}

// NewUpdateSpacePropertyByIdRequestWithBody generates requests for UpdateSpacePropertyById with any type of body
func NewUpdateSpacePropertyByIdRequestWithBody(server string, spaceId int64, propertyId int64, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "space-id", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "property-id", runtime.ParamLocationPath, propertyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/spaces/%s/properties/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetTasksRequest generates requests for GetTasks
func NewGetTasksRequest(server string, params *GetTasksParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tasks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.BodyFormat != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "body-format", runtime.ParamLocationQuery, *params.BodyFormat); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeBlankTasks != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include-blank-tasks", runtime.ParamLocationQuery, *params.IncludeBlankTasks); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TaskId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "task-id", runtime.ParamLocationQuery, *params.TaskId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SpaceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "space-id", runtime.ParamLocationQuery, *params.SpaceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page-id", runtime.ParamLocationQuery, *params.PageId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BlogpostId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "blogpost-id", runtime.ParamLocationQuery, *params.BlogpostId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created-by", runtime.ParamLocationQuery, *params.CreatedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AssignedTo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "assigned-to", runtime.ParamLocationQuery, *params.AssignedTo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CompletedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "completed-by", runtime.ParamLocationQuery, *params.CompletedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAtFrom != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created-at-from", runtime.ParamLocationQuery, *params.CreatedAtFrom); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAtTo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created-at-to", runtime.ParamLocationQuery, *params.CreatedAtTo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DueAtFrom != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "due-at-from", runtime.ParamLocationQuery, *params.DueAtFrom); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DueAtTo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "due-at-to", runtime.ParamLocationQuery, *params.DueAtTo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CompletedAtFrom != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "completed-at-from", runtime.ParamLocationQuery, *params.CompletedAtFrom); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CompletedAtTo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "completed-at-to", runtime.ParamLocationQuery, *params.CompletedAtTo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTaskByIdRequest generates requests for GetTaskById
func NewGetTaskByIdRequest(server string, id int64, params *GetTaskByIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tasks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.BodyFormat != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "body-format", runtime.ParamLocationQuery, *params.BodyFormat); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateTaskRequest calls the generic UpdateTask builder with application/json body
func NewUpdateTaskRequest(server string, id int64, params *UpdateTaskParams, body UpdateTaskJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateTaskRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewUpdateTaskRequestWithBody generates requests for UpdateTask with any type of body
func NewUpdateTaskRequestWithBody(server string, id int64, params *UpdateTaskParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tasks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.BodyFormat != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "body-format", runtime.ParamLocationQuery, *params.BodyFormat); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCheckAccessByEmailRequest calls the generic CheckAccessByEmail builder with application/json body
func NewCheckAccessByEmailRequest(server string, body CheckAccessByEmailJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCheckAccessByEmailRequestWithBody(server, "application/json", bodyReader)
}

// NewCheckAccessByEmailRequestWithBody generates requests for CheckAccessByEmail with any type of body
func NewCheckAccessByEmailRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/access/check-access-by-email")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewInviteByEmailRequest calls the generic InviteByEmail builder with application/json body
func NewInviteByEmailRequest(server string, body InviteByEmailJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewInviteByEmailRequestWithBody(server, "application/json", bodyReader)
}

// NewInviteByEmailRequestWithBody generates requests for InviteByEmail with any type of body
func NewInviteByEmailRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/access/invite-by-email")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateBulkUserLookupRequest calls the generic CreateBulkUserLookup builder with application/json body
func NewCreateBulkUserLookupRequest(server string, body CreateBulkUserLookupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateBulkUserLookupRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateBulkUserLookupRequestWithBody generates requests for CreateBulkUserLookup with any type of body
func NewCreateBulkUserLookupRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users-bulk")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateWhiteboardRequest calls the generic CreateWhiteboard builder with application/json body
func NewCreateWhiteboardRequest(server string, params *CreateWhiteboardParams, body CreateWhiteboardJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateWhiteboardRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateWhiteboardRequestWithBody generates requests for CreateWhiteboard with any type of body
func NewCreateWhiteboardRequestWithBody(server string, params *CreateWhiteboardParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/whiteboards")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Private != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "private", runtime.ParamLocationQuery, *params.Private); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteWhiteboardRequest generates requests for DeleteWhiteboard
func NewDeleteWhiteboardRequest(server string, id int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/whiteboards/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetWhiteboardByIdRequest generates requests for GetWhiteboardById
func NewGetWhiteboardByIdRequest(server string, id int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/whiteboards/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetWhiteboardAncestorsRequest generates requests for GetWhiteboardAncestors
func NewGetWhiteboardAncestorsRequest(server string, id int64, params *GetWhiteboardAncestorsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/whiteboards/%s/ancestors", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetWhiteboardClassificationLevelRequest generates requests for GetWhiteboardClassificationLevel
func NewGetWhiteboardClassificationLevelRequest(server string, id int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/whiteboards/%s/classification-level", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutWhiteboardClassificationLevelRequest calls the generic PutWhiteboardClassificationLevel builder with application/json body
func NewPutWhiteboardClassificationLevelRequest(server string, id int64, body PutWhiteboardClassificationLevelJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutWhiteboardClassificationLevelRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPutWhiteboardClassificationLevelRequestWithBody generates requests for PutWhiteboardClassificationLevel with any type of body
func NewPutWhiteboardClassificationLevelRequestWithBody(server string, id int64, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/whiteboards/%s/classification-level", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostWhiteboardClassificationLevelRequest calls the generic PostWhiteboardClassificationLevel builder with application/json body
func NewPostWhiteboardClassificationLevelRequest(server string, id int64, body PostWhiteboardClassificationLevelJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostWhiteboardClassificationLevelRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPostWhiteboardClassificationLevelRequestWithBody generates requests for PostWhiteboardClassificationLevel with any type of body
func NewPostWhiteboardClassificationLevelRequestWithBody(server string, id int64, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/whiteboards/%s/classification-level/reset", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetWhiteboardOperationsRequest generates requests for GetWhiteboardOperations
func NewGetWhiteboardOperationsRequest(server string, id int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/whiteboards/%s/operations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetWhiteboardContentPropertiesRequest generates requests for GetWhiteboardContentProperties
func NewGetWhiteboardContentPropertiesRequest(server string, id int64, params *GetWhiteboardContentPropertiesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/whiteboards/%s/properties", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Key != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "key", runtime.ParamLocationQuery, *params.Key); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateWhiteboardPropertyRequest calls the generic CreateWhiteboardProperty builder with application/json body
func NewCreateWhiteboardPropertyRequest(server string, id int64, body CreateWhiteboardPropertyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateWhiteboardPropertyRequestWithBody(server, id, "application/json", bodyReader)
}

// NewCreateWhiteboardPropertyRequestWithBody generates requests for CreateWhiteboardProperty with any type of body
func NewCreateWhiteboardPropertyRequestWithBody(server string, id int64, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/whiteboards/%s/properties", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteWhiteboardPropertyByIdRequest generates requests for DeleteWhiteboardPropertyById
func NewDeleteWhiteboardPropertyByIdRequest(server string, whiteboardId int64, propertyId int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "whiteboard-id", runtime.ParamLocationPath, whiteboardId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "property-id", runtime.ParamLocationPath, propertyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/whiteboards/%s/properties/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetWhiteboardContentPropertiesByIdRequest generates requests for GetWhiteboardContentPropertiesById
func NewGetWhiteboardContentPropertiesByIdRequest(server string, whiteboardId int64, propertyId int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "whiteboard-id", runtime.ParamLocationPath, whiteboardId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "property-id", runtime.ParamLocationPath, propertyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/whiteboards/%s/properties/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateWhiteboardPropertyByIdRequest calls the generic UpdateWhiteboardPropertyById builder with application/json body
func NewUpdateWhiteboardPropertyByIdRequest(server string, whiteboardId int64, propertyId int64, body UpdateWhiteboardPropertyByIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateWhiteboardPropertyByIdRequestWithBody(server, whiteboardId, propertyId, "application/json", bodyReader)
}

// NewUpdateWhiteboardPropertyByIdRequestWithBody generates requests for UpdateWhiteboardPropertyById with any type of body
func NewUpdateWhiteboardPropertyByIdRequestWithBody(server string, whiteboardId int64, propertyId int64, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "whiteboard-id", runtime.ParamLocationPath, whiteboardId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "property-id", runtime.ParamLocationPath, propertyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/whiteboards/%s/properties/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetAttachmentsWithResponse request
	GetAttachmentsWithResponse(ctx context.Context, params *GetAttachmentsParams, reqEditors ...RequestEditorFn) (*GetAttachmentsResponse, error)

	// GetAttachmentContentPropertiesWithResponse request
	GetAttachmentContentPropertiesWithResponse(ctx context.Context, attachmentId string, params *GetAttachmentContentPropertiesParams, reqEditors ...RequestEditorFn) (*GetAttachmentContentPropertiesResponse, error)

	// CreateAttachmentPropertyWithBodyWithResponse request with any body
	CreateAttachmentPropertyWithBodyWithResponse(ctx context.Context, attachmentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAttachmentPropertyResponse, error)

	CreateAttachmentPropertyWithResponse(ctx context.Context, attachmentId string, body CreateAttachmentPropertyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAttachmentPropertyResponse, error)

	// DeleteAttachmentPropertyByIdWithResponse request
	DeleteAttachmentPropertyByIdWithResponse(ctx context.Context, attachmentId string, propertyId int64, reqEditors ...RequestEditorFn) (*DeleteAttachmentPropertyByIdResponse, error)

	// GetAttachmentContentPropertiesByIdWithResponse request
	GetAttachmentContentPropertiesByIdWithResponse(ctx context.Context, attachmentId string, propertyId int64, reqEditors ...RequestEditorFn) (*GetAttachmentContentPropertiesByIdResponse, error)

	// UpdateAttachmentPropertyByIdWithBodyWithResponse request with any body
	UpdateAttachmentPropertyByIdWithBodyWithResponse(ctx context.Context, attachmentId string, propertyId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAttachmentPropertyByIdResponse, error)

	UpdateAttachmentPropertyByIdWithResponse(ctx context.Context, attachmentId string, propertyId int64, body UpdateAttachmentPropertyByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAttachmentPropertyByIdResponse, error)

	// GetAttachmentVersionDetailsWithResponse request
	GetAttachmentVersionDetailsWithResponse(ctx context.Context, attachmentId string, versionNumber int64, reqEditors ...RequestEditorFn) (*GetAttachmentVersionDetailsResponse, error)

	// DeleteAttachmentWithResponse request
	DeleteAttachmentWithResponse(ctx context.Context, id int64, params *DeleteAttachmentParams, reqEditors ...RequestEditorFn) (*DeleteAttachmentResponse, error)

	// GetAttachmentByIdWithResponse request
	GetAttachmentByIdWithResponse(ctx context.Context, id string, params *GetAttachmentByIdParams, reqEditors ...RequestEditorFn) (*GetAttachmentByIdResponse, error)

	// GetAttachmentCommentsWithResponse request
	GetAttachmentCommentsWithResponse(ctx context.Context, id string, params *GetAttachmentCommentsParams, reqEditors ...RequestEditorFn) (*GetAttachmentCommentsResponse, error)

	// GetAttachmentLabelsWithResponse request
	GetAttachmentLabelsWithResponse(ctx context.Context, id int64, params *GetAttachmentLabelsParams, reqEditors ...RequestEditorFn) (*GetAttachmentLabelsResponse, error)

	// GetAttachmentOperationsWithResponse request
	GetAttachmentOperationsWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetAttachmentOperationsResponse, error)

	// GetAttachmentVersionsWithResponse request
	GetAttachmentVersionsWithResponse(ctx context.Context, id string, params *GetAttachmentVersionsParams, reqEditors ...RequestEditorFn) (*GetAttachmentVersionsResponse, error)

	// GetBlogPostsWithResponse request
	GetBlogPostsWithResponse(ctx context.Context, params *GetBlogPostsParams, reqEditors ...RequestEditorFn) (*GetBlogPostsResponse, error)

	// CreateBlogPostWithBodyWithResponse request with any body
	CreateBlogPostWithBodyWithResponse(ctx context.Context, params *CreateBlogPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBlogPostResponse, error)

	CreateBlogPostWithResponse(ctx context.Context, params *CreateBlogPostParams, body CreateBlogPostJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBlogPostResponse, error)

	// GetBlogpostContentPropertiesWithResponse request
	GetBlogpostContentPropertiesWithResponse(ctx context.Context, blogpostId int64, params *GetBlogpostContentPropertiesParams, reqEditors ...RequestEditorFn) (*GetBlogpostContentPropertiesResponse, error)

	// CreateBlogpostPropertyWithBodyWithResponse request with any body
	CreateBlogpostPropertyWithBodyWithResponse(ctx context.Context, blogpostId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBlogpostPropertyResponse, error)

	CreateBlogpostPropertyWithResponse(ctx context.Context, blogpostId int64, body CreateBlogpostPropertyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBlogpostPropertyResponse, error)

	// DeleteBlogpostPropertyByIdWithResponse request
	DeleteBlogpostPropertyByIdWithResponse(ctx context.Context, blogpostId int64, propertyId int64, reqEditors ...RequestEditorFn) (*DeleteBlogpostPropertyByIdResponse, error)

	// GetBlogpostContentPropertiesByIdWithResponse request
	GetBlogpostContentPropertiesByIdWithResponse(ctx context.Context, blogpostId int64, propertyId int64, reqEditors ...RequestEditorFn) (*GetBlogpostContentPropertiesByIdResponse, error)

	// UpdateBlogpostPropertyByIdWithBodyWithResponse request with any body
	UpdateBlogpostPropertyByIdWithBodyWithResponse(ctx context.Context, blogpostId int64, propertyId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateBlogpostPropertyByIdResponse, error)

	UpdateBlogpostPropertyByIdWithResponse(ctx context.Context, blogpostId int64, propertyId int64, body UpdateBlogpostPropertyByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateBlogpostPropertyByIdResponse, error)

	// GetBlogPostVersionDetailsWithResponse request
	GetBlogPostVersionDetailsWithResponse(ctx context.Context, blogpostId int64, versionNumber int64, reqEditors ...RequestEditorFn) (*GetBlogPostVersionDetailsResponse, error)

	// DeleteBlogPostWithResponse request
	DeleteBlogPostWithResponse(ctx context.Context, id int64, params *DeleteBlogPostParams, reqEditors ...RequestEditorFn) (*DeleteBlogPostResponse, error)

	// GetBlogPostByIdWithResponse request
	GetBlogPostByIdWithResponse(ctx context.Context, id int64, params *GetBlogPostByIdParams, reqEditors ...RequestEditorFn) (*GetBlogPostByIdResponse, error)

	// UpdateBlogPostWithBodyWithResponse request with any body
	UpdateBlogPostWithBodyWithResponse(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateBlogPostResponse, error)

	UpdateBlogPostWithResponse(ctx context.Context, id int64, body UpdateBlogPostJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateBlogPostResponse, error)

	// GetBlogpostAttachmentsWithResponse request
	GetBlogpostAttachmentsWithResponse(ctx context.Context, id int64, params *GetBlogpostAttachmentsParams, reqEditors ...RequestEditorFn) (*GetBlogpostAttachmentsResponse, error)

	// GetBlogPostClassificationLevelWithResponse request
	GetBlogPostClassificationLevelWithResponse(ctx context.Context, id int64, params *GetBlogPostClassificationLevelParams, reqEditors ...RequestEditorFn) (*GetBlogPostClassificationLevelResponse, error)

	// PutBlogPostClassificationLevelWithBodyWithResponse request with any body
	PutBlogPostClassificationLevelWithBodyWithResponse(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutBlogPostClassificationLevelResponse, error)

	PutBlogPostClassificationLevelWithResponse(ctx context.Context, id int64, body PutBlogPostClassificationLevelJSONRequestBody, reqEditors ...RequestEditorFn) (*PutBlogPostClassificationLevelResponse, error)

	// PostBlogPostClassificationLevelWithBodyWithResponse request with any body
	PostBlogPostClassificationLevelWithBodyWithResponse(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostBlogPostClassificationLevelResponse, error)

	PostBlogPostClassificationLevelWithResponse(ctx context.Context, id int64, body PostBlogPostClassificationLevelJSONRequestBody, reqEditors ...RequestEditorFn) (*PostBlogPostClassificationLevelResponse, error)

	// GetCustomContentByTypeInBlogPostWithResponse request
	GetCustomContentByTypeInBlogPostWithResponse(ctx context.Context, id int64, params *GetCustomContentByTypeInBlogPostParams, reqEditors ...RequestEditorFn) (*GetCustomContentByTypeInBlogPostResponse, error)

	// GetBlogPostFooterCommentsWithResponse request
	GetBlogPostFooterCommentsWithResponse(ctx context.Context, id int64, params *GetBlogPostFooterCommentsParams, reqEditors ...RequestEditorFn) (*GetBlogPostFooterCommentsResponse, error)

	// GetBlogPostInlineCommentsWithResponse request
	GetBlogPostInlineCommentsWithResponse(ctx context.Context, id int64, params *GetBlogPostInlineCommentsParams, reqEditors ...RequestEditorFn) (*GetBlogPostInlineCommentsResponse, error)

	// GetBlogPostLabelsWithResponse request
	GetBlogPostLabelsWithResponse(ctx context.Context, id int64, params *GetBlogPostLabelsParams, reqEditors ...RequestEditorFn) (*GetBlogPostLabelsResponse, error)

	// GetBlogPostLikeCountWithResponse request
	GetBlogPostLikeCountWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetBlogPostLikeCountResponse, error)

	// GetBlogPostLikeUsersWithResponse request
	GetBlogPostLikeUsersWithResponse(ctx context.Context, id int64, params *GetBlogPostLikeUsersParams, reqEditors ...RequestEditorFn) (*GetBlogPostLikeUsersResponse, error)

	// GetBlogPostOperationsWithResponse request
	GetBlogPostOperationsWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetBlogPostOperationsResponse, error)

	// GetBlogPostVersionsWithResponse request
	GetBlogPostVersionsWithResponse(ctx context.Context, id int64, params *GetBlogPostVersionsParams, reqEditors ...RequestEditorFn) (*GetBlogPostVersionsResponse, error)

	// GetClassificationLevelsWithResponse request
	GetClassificationLevelsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetClassificationLevelsResponse, error)

	// GetCommentContentPropertiesWithResponse request
	GetCommentContentPropertiesWithResponse(ctx context.Context, commentId int64, params *GetCommentContentPropertiesParams, reqEditors ...RequestEditorFn) (*GetCommentContentPropertiesResponse, error)

	// CreateCommentPropertyWithBodyWithResponse request with any body
	CreateCommentPropertyWithBodyWithResponse(ctx context.Context, commentId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCommentPropertyResponse, error)

	CreateCommentPropertyWithResponse(ctx context.Context, commentId int64, body CreateCommentPropertyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCommentPropertyResponse, error)

	// DeleteCommentPropertyByIdWithResponse request
	DeleteCommentPropertyByIdWithResponse(ctx context.Context, commentId int64, propertyId int64, reqEditors ...RequestEditorFn) (*DeleteCommentPropertyByIdResponse, error)

	// GetCommentContentPropertiesByIdWithResponse request
	GetCommentContentPropertiesByIdWithResponse(ctx context.Context, commentId int64, propertyId int64, reqEditors ...RequestEditorFn) (*GetCommentContentPropertiesByIdResponse, error)

	// UpdateCommentPropertyByIdWithBodyWithResponse request with any body
	UpdateCommentPropertyByIdWithBodyWithResponse(ctx context.Context, commentId int64, propertyId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCommentPropertyByIdResponse, error)

	UpdateCommentPropertyByIdWithResponse(ctx context.Context, commentId int64, propertyId int64, body UpdateCommentPropertyByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCommentPropertyByIdResponse, error)

	// ConvertContentIdsToContentTypesWithBodyWithResponse request with any body
	ConvertContentIdsToContentTypesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConvertContentIdsToContentTypesResponse, error)

	ConvertContentIdsToContentTypesWithResponse(ctx context.Context, body ConvertContentIdsToContentTypesJSONRequestBody, reqEditors ...RequestEditorFn) (*ConvertContentIdsToContentTypesResponse, error)

	// GetCustomContentByTypeWithResponse request
	GetCustomContentByTypeWithResponse(ctx context.Context, params *GetCustomContentByTypeParams, reqEditors ...RequestEditorFn) (*GetCustomContentByTypeResponse, error)

	// CreateCustomContentWithBodyWithResponse request with any body
	CreateCustomContentWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCustomContentResponse, error)

	CreateCustomContentWithResponse(ctx context.Context, body CreateCustomContentJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCustomContentResponse, error)

	// GetCustomContentContentPropertiesWithResponse request
	GetCustomContentContentPropertiesWithResponse(ctx context.Context, customContentId int64, params *GetCustomContentContentPropertiesParams, reqEditors ...RequestEditorFn) (*GetCustomContentContentPropertiesResponse, error)

	// CreateCustomContentPropertyWithBodyWithResponse request with any body
	CreateCustomContentPropertyWithBodyWithResponse(ctx context.Context, customContentId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCustomContentPropertyResponse, error)

	CreateCustomContentPropertyWithResponse(ctx context.Context, customContentId int64, body CreateCustomContentPropertyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCustomContentPropertyResponse, error)

	// DeleteCustomContentPropertyByIdWithResponse request
	DeleteCustomContentPropertyByIdWithResponse(ctx context.Context, customContentId int64, propertyId int64, reqEditors ...RequestEditorFn) (*DeleteCustomContentPropertyByIdResponse, error)

	// GetCustomContentContentPropertiesByIdWithResponse request
	GetCustomContentContentPropertiesByIdWithResponse(ctx context.Context, customContentId int64, propertyId int64, reqEditors ...RequestEditorFn) (*GetCustomContentContentPropertiesByIdResponse, error)

	// UpdateCustomContentPropertyByIdWithBodyWithResponse request with any body
	UpdateCustomContentPropertyByIdWithBodyWithResponse(ctx context.Context, customContentId int64, propertyId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCustomContentPropertyByIdResponse, error)

	UpdateCustomContentPropertyByIdWithResponse(ctx context.Context, customContentId int64, propertyId int64, body UpdateCustomContentPropertyByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCustomContentPropertyByIdResponse, error)

	// GetCustomContentVersionsWithResponse request
	GetCustomContentVersionsWithResponse(ctx context.Context, customContentId int64, params *GetCustomContentVersionsParams, reqEditors ...RequestEditorFn) (*GetCustomContentVersionsResponse, error)

	// GetCustomContentVersionDetailsWithResponse request
	GetCustomContentVersionDetailsWithResponse(ctx context.Context, customContentId int64, versionNumber int64, reqEditors ...RequestEditorFn) (*GetCustomContentVersionDetailsResponse, error)

	// DeleteCustomContentWithResponse request
	DeleteCustomContentWithResponse(ctx context.Context, id int64, params *DeleteCustomContentParams, reqEditors ...RequestEditorFn) (*DeleteCustomContentResponse, error)

	// GetCustomContentByIdWithResponse request
	GetCustomContentByIdWithResponse(ctx context.Context, id int64, params *GetCustomContentByIdParams, reqEditors ...RequestEditorFn) (*GetCustomContentByIdResponse, error)

	// UpdateCustomContentWithBodyWithResponse request with any body
	UpdateCustomContentWithBodyWithResponse(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCustomContentResponse, error)

	UpdateCustomContentWithResponse(ctx context.Context, id int64, body UpdateCustomContentJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCustomContentResponse, error)

	// GetCustomContentAttachmentsWithResponse request
	GetCustomContentAttachmentsWithResponse(ctx context.Context, id int64, params *GetCustomContentAttachmentsParams, reqEditors ...RequestEditorFn) (*GetCustomContentAttachmentsResponse, error)

	// GetChildCustomContentWithResponse request
	GetChildCustomContentWithResponse(ctx context.Context, id int64, params *GetChildCustomContentParams, reqEditors ...RequestEditorFn) (*GetChildCustomContentResponse, error)

	// GetCustomContentCommentsWithResponse request
	GetCustomContentCommentsWithResponse(ctx context.Context, id int64, params *GetCustomContentCommentsParams, reqEditors ...RequestEditorFn) (*GetCustomContentCommentsResponse, error)

	// GetCustomContentLabelsWithResponse request
	GetCustomContentLabelsWithResponse(ctx context.Context, id int64, params *GetCustomContentLabelsParams, reqEditors ...RequestEditorFn) (*GetCustomContentLabelsResponse, error)

	// GetCustomContentOperationsWithResponse request
	GetCustomContentOperationsWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetCustomContentOperationsResponse, error)

	// GetDataPolicyMetadataWithResponse request
	GetDataPolicyMetadataWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDataPolicyMetadataResponse, error)

	// GetDataPolicySpacesWithResponse request
	GetDataPolicySpacesWithResponse(ctx context.Context, params *GetDataPolicySpacesParams, reqEditors ...RequestEditorFn) (*GetDataPolicySpacesResponse, error)

	// CreateDatabaseWithBodyWithResponse request with any body
	CreateDatabaseWithBodyWithResponse(ctx context.Context, params *CreateDatabaseParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDatabaseResponse, error)

	CreateDatabaseWithResponse(ctx context.Context, params *CreateDatabaseParams, body CreateDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDatabaseResponse, error)

	// DeleteDatabasePropertyByIdWithResponse request
	DeleteDatabasePropertyByIdWithResponse(ctx context.Context, databaseId int64, propertyId int64, reqEditors ...RequestEditorFn) (*DeleteDatabasePropertyByIdResponse, error)

	// GetDatabaseContentPropertiesByIdWithResponse request
	GetDatabaseContentPropertiesByIdWithResponse(ctx context.Context, databaseId int64, propertyId int64, reqEditors ...RequestEditorFn) (*GetDatabaseContentPropertiesByIdResponse, error)

	// UpdateDatabasePropertyByIdWithBodyWithResponse request with any body
	UpdateDatabasePropertyByIdWithBodyWithResponse(ctx context.Context, databaseId int64, propertyId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDatabasePropertyByIdResponse, error)

	UpdateDatabasePropertyByIdWithResponse(ctx context.Context, databaseId int64, propertyId int64, body UpdateDatabasePropertyByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDatabasePropertyByIdResponse, error)

	// DeleteDatabaseWithResponse request
	DeleteDatabaseWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*DeleteDatabaseResponse, error)

	// GetDatabaseByIdWithResponse request
	GetDatabaseByIdWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetDatabaseByIdResponse, error)

	// GetDatabaseAncestorsWithResponse request
	GetDatabaseAncestorsWithResponse(ctx context.Context, id int64, params *GetDatabaseAncestorsParams, reqEditors ...RequestEditorFn) (*GetDatabaseAncestorsResponse, error)

	// GetDatabaseClassificationLevelWithResponse request
	GetDatabaseClassificationLevelWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetDatabaseClassificationLevelResponse, error)

	// PutDatabaseClassificationLevelWithBodyWithResponse request with any body
	PutDatabaseClassificationLevelWithBodyWithResponse(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutDatabaseClassificationLevelResponse, error)

	PutDatabaseClassificationLevelWithResponse(ctx context.Context, id int64, body PutDatabaseClassificationLevelJSONRequestBody, reqEditors ...RequestEditorFn) (*PutDatabaseClassificationLevelResponse, error)

	// PostDatabaseClassificationLevelWithBodyWithResponse request with any body
	PostDatabaseClassificationLevelWithBodyWithResponse(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostDatabaseClassificationLevelResponse, error)

	PostDatabaseClassificationLevelWithResponse(ctx context.Context, id int64, body PostDatabaseClassificationLevelJSONRequestBody, reqEditors ...RequestEditorFn) (*PostDatabaseClassificationLevelResponse, error)

	// GetDatabaseOperationsWithResponse request
	GetDatabaseOperationsWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetDatabaseOperationsResponse, error)

	// GetDatabaseContentPropertiesWithResponse request
	GetDatabaseContentPropertiesWithResponse(ctx context.Context, id int64, params *GetDatabaseContentPropertiesParams, reqEditors ...RequestEditorFn) (*GetDatabaseContentPropertiesResponse, error)

	// CreateDatabasePropertyWithBodyWithResponse request with any body
	CreateDatabasePropertyWithBodyWithResponse(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDatabasePropertyResponse, error)

	CreateDatabasePropertyWithResponse(ctx context.Context, id int64, body CreateDatabasePropertyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDatabasePropertyResponse, error)

	// CreateSmartLinkWithBodyWithResponse request with any body
	CreateSmartLinkWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSmartLinkResponse, error)

	CreateSmartLinkWithResponse(ctx context.Context, body CreateSmartLinkJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSmartLinkResponse, error)

	// DeleteSmartLinkPropertyByIdWithResponse request
	DeleteSmartLinkPropertyByIdWithResponse(ctx context.Context, embedId int64, propertyId int64, reqEditors ...RequestEditorFn) (*DeleteSmartLinkPropertyByIdResponse, error)

	// GetSmartLinkContentPropertiesByIdWithResponse request
	GetSmartLinkContentPropertiesByIdWithResponse(ctx context.Context, embedId int64, propertyId int64, reqEditors ...RequestEditorFn) (*GetSmartLinkContentPropertiesByIdResponse, error)

	// UpdateSmartLinkPropertyByIdWithBodyWithResponse request with any body
	UpdateSmartLinkPropertyByIdWithBodyWithResponse(ctx context.Context, embedId int64, propertyId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSmartLinkPropertyByIdResponse, error)

	UpdateSmartLinkPropertyByIdWithResponse(ctx context.Context, embedId int64, propertyId int64, body UpdateSmartLinkPropertyByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSmartLinkPropertyByIdResponse, error)

	// DeleteSmartLinkWithResponse request
	DeleteSmartLinkWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*DeleteSmartLinkResponse, error)

	// GetSmartLinkByIdWithResponse request
	GetSmartLinkByIdWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetSmartLinkByIdResponse, error)

	// GetSmartLinkAncestorsWithResponse request
	GetSmartLinkAncestorsWithResponse(ctx context.Context, id int64, params *GetSmartLinkAncestorsParams, reqEditors ...RequestEditorFn) (*GetSmartLinkAncestorsResponse, error)

	// GetSmartLinkOperationsWithResponse request
	GetSmartLinkOperationsWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetSmartLinkOperationsResponse, error)

	// GetSmartLinkContentPropertiesWithResponse request
	GetSmartLinkContentPropertiesWithResponse(ctx context.Context, id int64, params *GetSmartLinkContentPropertiesParams, reqEditors ...RequestEditorFn) (*GetSmartLinkContentPropertiesResponse, error)

	// CreateSmartLinkPropertyWithBodyWithResponse request with any body
	CreateSmartLinkPropertyWithBodyWithResponse(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSmartLinkPropertyResponse, error)

	CreateSmartLinkPropertyWithResponse(ctx context.Context, id int64, body CreateSmartLinkPropertyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSmartLinkPropertyResponse, error)

	// CreateFolderWithBodyWithResponse request with any body
	CreateFolderWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFolderResponse, error)

	CreateFolderWithResponse(ctx context.Context, body CreateFolderJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFolderResponse, error)

	// DeleteFolderPropertyByIdWithResponse request
	DeleteFolderPropertyByIdWithResponse(ctx context.Context, folderId int64, propertyId int64, reqEditors ...RequestEditorFn) (*DeleteFolderPropertyByIdResponse, error)

	// GetFolderContentPropertiesByIdWithResponse request
	GetFolderContentPropertiesByIdWithResponse(ctx context.Context, folderId int64, propertyId int64, reqEditors ...RequestEditorFn) (*GetFolderContentPropertiesByIdResponse, error)

	// UpdateFolderPropertyByIdWithBodyWithResponse request with any body
	UpdateFolderPropertyByIdWithBodyWithResponse(ctx context.Context, folderId int64, propertyId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateFolderPropertyByIdResponse, error)

	UpdateFolderPropertyByIdWithResponse(ctx context.Context, folderId int64, propertyId int64, body UpdateFolderPropertyByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateFolderPropertyByIdResponse, error)

	// DeleteFolderWithResponse request
	DeleteFolderWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*DeleteFolderResponse, error)

	// GetFolderByIdWithResponse request
	GetFolderByIdWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetFolderByIdResponse, error)

	// GetFolderAncestorsWithResponse request
	GetFolderAncestorsWithResponse(ctx context.Context, id int64, params *GetFolderAncestorsParams, reqEditors ...RequestEditorFn) (*GetFolderAncestorsResponse, error)

	// GetFolderOperationsWithResponse request
	GetFolderOperationsWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetFolderOperationsResponse, error)

	// GetFolderContentPropertiesWithResponse request
	GetFolderContentPropertiesWithResponse(ctx context.Context, id int64, params *GetFolderContentPropertiesParams, reqEditors ...RequestEditorFn) (*GetFolderContentPropertiesResponse, error)

	// CreateFolderPropertyWithBodyWithResponse request with any body
	CreateFolderPropertyWithBodyWithResponse(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFolderPropertyResponse, error)

	CreateFolderPropertyWithResponse(ctx context.Context, id int64, body CreateFolderPropertyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFolderPropertyResponse, error)

	// GetFooterCommentsWithResponse request
	GetFooterCommentsWithResponse(ctx context.Context, params *GetFooterCommentsParams, reqEditors ...RequestEditorFn) (*GetFooterCommentsResponse, error)

	// CreateFooterCommentWithBodyWithResponse request with any body
	CreateFooterCommentWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFooterCommentResponse, error)

	CreateFooterCommentWithResponse(ctx context.Context, body CreateFooterCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFooterCommentResponse, error)

	// DeleteFooterCommentWithResponse request
	DeleteFooterCommentWithResponse(ctx context.Context, commentId int64, reqEditors ...RequestEditorFn) (*DeleteFooterCommentResponse, error)

	// GetFooterCommentByIdWithResponse request
	GetFooterCommentByIdWithResponse(ctx context.Context, commentId int64, params *GetFooterCommentByIdParams, reqEditors ...RequestEditorFn) (*GetFooterCommentByIdResponse, error)

	// UpdateFooterCommentWithBodyWithResponse request with any body
	UpdateFooterCommentWithBodyWithResponse(ctx context.Context, commentId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateFooterCommentResponse, error)

	UpdateFooterCommentWithResponse(ctx context.Context, commentId int64, body UpdateFooterCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateFooterCommentResponse, error)

	// GetFooterCommentChildrenWithResponse request
	GetFooterCommentChildrenWithResponse(ctx context.Context, id int64, params *GetFooterCommentChildrenParams, reqEditors ...RequestEditorFn) (*GetFooterCommentChildrenResponse, error)

	// GetFooterLikeCountWithResponse request
	GetFooterLikeCountWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetFooterLikeCountResponse, error)

	// GetFooterLikeUsersWithResponse request
	GetFooterLikeUsersWithResponse(ctx context.Context, id int64, params *GetFooterLikeUsersParams, reqEditors ...RequestEditorFn) (*GetFooterLikeUsersResponse, error)

	// GetFooterCommentOperationsWithResponse request
	GetFooterCommentOperationsWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetFooterCommentOperationsResponse, error)

	// GetFooterCommentVersionsWithResponse request
	GetFooterCommentVersionsWithResponse(ctx context.Context, id int64, params *GetFooterCommentVersionsParams, reqEditors ...RequestEditorFn) (*GetFooterCommentVersionsResponse, error)

	// GetFooterCommentVersionDetailsWithResponse request
	GetFooterCommentVersionDetailsWithResponse(ctx context.Context, id int64, versionNumber int64, reqEditors ...RequestEditorFn) (*GetFooterCommentVersionDetailsResponse, error)

	// GetInlineCommentsWithResponse request
	GetInlineCommentsWithResponse(ctx context.Context, params *GetInlineCommentsParams, reqEditors ...RequestEditorFn) (*GetInlineCommentsResponse, error)

	// CreateInlineCommentWithBodyWithResponse request with any body
	CreateInlineCommentWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateInlineCommentResponse, error)

	CreateInlineCommentWithResponse(ctx context.Context, body CreateInlineCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateInlineCommentResponse, error)

	// DeleteInlineCommentWithResponse request
	DeleteInlineCommentWithResponse(ctx context.Context, commentId int64, reqEditors ...RequestEditorFn) (*DeleteInlineCommentResponse, error)

	// GetInlineCommentByIdWithResponse request
	GetInlineCommentByIdWithResponse(ctx context.Context, commentId int64, params *GetInlineCommentByIdParams, reqEditors ...RequestEditorFn) (*GetInlineCommentByIdResponse, error)

	// UpdateInlineCommentWithBodyWithResponse request with any body
	UpdateInlineCommentWithBodyWithResponse(ctx context.Context, commentId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateInlineCommentResponse, error)

	UpdateInlineCommentWithResponse(ctx context.Context, commentId int64, body UpdateInlineCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateInlineCommentResponse, error)

	// GetInlineCommentChildrenWithResponse request
	GetInlineCommentChildrenWithResponse(ctx context.Context, id int64, params *GetInlineCommentChildrenParams, reqEditors ...RequestEditorFn) (*GetInlineCommentChildrenResponse, error)

	// GetInlineLikeCountWithResponse request
	GetInlineLikeCountWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetInlineLikeCountResponse, error)

	// GetInlineLikeUsersWithResponse request
	GetInlineLikeUsersWithResponse(ctx context.Context, id int64, params *GetInlineLikeUsersParams, reqEditors ...RequestEditorFn) (*GetInlineLikeUsersResponse, error)

	// GetInlineCommentOperationsWithResponse request
	GetInlineCommentOperationsWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetInlineCommentOperationsResponse, error)

	// GetInlineCommentVersionsWithResponse request
	GetInlineCommentVersionsWithResponse(ctx context.Context, id int64, params *GetInlineCommentVersionsParams, reqEditors ...RequestEditorFn) (*GetInlineCommentVersionsResponse, error)

	// GetInlineCommentVersionDetailsWithResponse request
	GetInlineCommentVersionDetailsWithResponse(ctx context.Context, id int64, versionNumber int64, reqEditors ...RequestEditorFn) (*GetInlineCommentVersionDetailsResponse, error)

	// GetLabelsWithResponse request
	GetLabelsWithResponse(ctx context.Context, params *GetLabelsParams, reqEditors ...RequestEditorFn) (*GetLabelsResponse, error)

	// GetLabelAttachmentsWithResponse request
	GetLabelAttachmentsWithResponse(ctx context.Context, id int64, params *GetLabelAttachmentsParams, reqEditors ...RequestEditorFn) (*GetLabelAttachmentsResponse, error)

	// GetLabelBlogPostsWithResponse request
	GetLabelBlogPostsWithResponse(ctx context.Context, id int64, params *GetLabelBlogPostsParams, reqEditors ...RequestEditorFn) (*GetLabelBlogPostsResponse, error)

	// GetLabelPagesWithResponse request
	GetLabelPagesWithResponse(ctx context.Context, id int64, params *GetLabelPagesParams, reqEditors ...RequestEditorFn) (*GetLabelPagesResponse, error)

	// GetPagesWithResponse request
	GetPagesWithResponse(ctx context.Context, params *GetPagesParams, reqEditors ...RequestEditorFn) (*GetPagesResponse, error)

	// CreatePageWithBodyWithResponse request with any body
	CreatePageWithBodyWithResponse(ctx context.Context, params *CreatePageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePageResponse, error)

	CreatePageWithResponse(ctx context.Context, params *CreatePageParams, body CreatePageJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePageResponse, error)

	// DeletePageWithResponse request
	DeletePageWithResponse(ctx context.Context, id int64, params *DeletePageParams, reqEditors ...RequestEditorFn) (*DeletePageResponse, error)

	// GetPageByIdWithResponse request
	GetPageByIdWithResponse(ctx context.Context, id int64, params *GetPageByIdParams, reqEditors ...RequestEditorFn) (*GetPageByIdResponse, error)

	// UpdatePageWithBodyWithResponse request with any body
	UpdatePageWithBodyWithResponse(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePageResponse, error)

	UpdatePageWithResponse(ctx context.Context, id int64, body UpdatePageJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePageResponse, error)

	// GetPageAncestorsWithResponse request
	GetPageAncestorsWithResponse(ctx context.Context, id int64, params *GetPageAncestorsParams, reqEditors ...RequestEditorFn) (*GetPageAncestorsResponse, error)

	// GetPageAttachmentsWithResponse request
	GetPageAttachmentsWithResponse(ctx context.Context, id int64, params *GetPageAttachmentsParams, reqEditors ...RequestEditorFn) (*GetPageAttachmentsResponse, error)

	// GetChildPagesWithResponse request
	GetChildPagesWithResponse(ctx context.Context, id int64, params *GetChildPagesParams, reqEditors ...RequestEditorFn) (*GetChildPagesResponse, error)

	// GetPageClassificationLevelWithResponse request
	GetPageClassificationLevelWithResponse(ctx context.Context, id int64, params *GetPageClassificationLevelParams, reqEditors ...RequestEditorFn) (*GetPageClassificationLevelResponse, error)

	// PutPageClassificationLevelWithBodyWithResponse request with any body
	PutPageClassificationLevelWithBodyWithResponse(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutPageClassificationLevelResponse, error)

	PutPageClassificationLevelWithResponse(ctx context.Context, id int64, body PutPageClassificationLevelJSONRequestBody, reqEditors ...RequestEditorFn) (*PutPageClassificationLevelResponse, error)

	// PostPageClassificationLevelWithBodyWithResponse request with any body
	PostPageClassificationLevelWithBodyWithResponse(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostPageClassificationLevelResponse, error)

	PostPageClassificationLevelWithResponse(ctx context.Context, id int64, body PostPageClassificationLevelJSONRequestBody, reqEditors ...RequestEditorFn) (*PostPageClassificationLevelResponse, error)

	// GetCustomContentByTypeInPageWithResponse request
	GetCustomContentByTypeInPageWithResponse(ctx context.Context, id int64, params *GetCustomContentByTypeInPageParams, reqEditors ...RequestEditorFn) (*GetCustomContentByTypeInPageResponse, error)

	// GetPageFooterCommentsWithResponse request
	GetPageFooterCommentsWithResponse(ctx context.Context, id int64, params *GetPageFooterCommentsParams, reqEditors ...RequestEditorFn) (*GetPageFooterCommentsResponse, error)

	// GetPageInlineCommentsWithResponse request
	GetPageInlineCommentsWithResponse(ctx context.Context, id int64, params *GetPageInlineCommentsParams, reqEditors ...RequestEditorFn) (*GetPageInlineCommentsResponse, error)

	// GetPageLabelsWithResponse request
	GetPageLabelsWithResponse(ctx context.Context, id int64, params *GetPageLabelsParams, reqEditors ...RequestEditorFn) (*GetPageLabelsResponse, error)

	// GetPageLikeCountWithResponse request
	GetPageLikeCountWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetPageLikeCountResponse, error)

	// GetPageLikeUsersWithResponse request
	GetPageLikeUsersWithResponse(ctx context.Context, id int64, params *GetPageLikeUsersParams, reqEditors ...RequestEditorFn) (*GetPageLikeUsersResponse, error)

	// GetPageOperationsWithResponse request
	GetPageOperationsWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetPageOperationsResponse, error)

	// GetPageVersionsWithResponse request
	GetPageVersionsWithResponse(ctx context.Context, id int64, params *GetPageVersionsParams, reqEditors ...RequestEditorFn) (*GetPageVersionsResponse, error)

	// GetPageContentPropertiesWithResponse request
	GetPageContentPropertiesWithResponse(ctx context.Context, pageId int64, params *GetPageContentPropertiesParams, reqEditors ...RequestEditorFn) (*GetPageContentPropertiesResponse, error)

	// CreatePagePropertyWithBodyWithResponse request with any body
	CreatePagePropertyWithBodyWithResponse(ctx context.Context, pageId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePagePropertyResponse, error)

	CreatePagePropertyWithResponse(ctx context.Context, pageId int64, body CreatePagePropertyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePagePropertyResponse, error)

	// DeletePagePropertyByIdWithResponse request
	DeletePagePropertyByIdWithResponse(ctx context.Context, pageId int64, propertyId int64, reqEditors ...RequestEditorFn) (*DeletePagePropertyByIdResponse, error)

	// GetPageContentPropertiesByIdWithResponse request
	GetPageContentPropertiesByIdWithResponse(ctx context.Context, pageId int64, propertyId int64, reqEditors ...RequestEditorFn) (*GetPageContentPropertiesByIdResponse, error)

	// UpdatePagePropertyByIdWithBodyWithResponse request with any body
	UpdatePagePropertyByIdWithBodyWithResponse(ctx context.Context, pageId int64, propertyId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePagePropertyByIdResponse, error)

	UpdatePagePropertyByIdWithResponse(ctx context.Context, pageId int64, propertyId int64, body UpdatePagePropertyByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePagePropertyByIdResponse, error)

	// GetPageVersionDetailsWithResponse request
	GetPageVersionDetailsWithResponse(ctx context.Context, pageId int64, versionNumber int64, reqEditors ...RequestEditorFn) (*GetPageVersionDetailsResponse, error)

	// GetSpacesWithResponse request
	GetSpacesWithResponse(ctx context.Context, params *GetSpacesParams, reqEditors ...RequestEditorFn) (*GetSpacesResponse, error)

	// GetSpaceByIdWithResponse request
	GetSpaceByIdWithResponse(ctx context.Context, id int64, params *GetSpaceByIdParams, reqEditors ...RequestEditorFn) (*GetSpaceByIdResponse, error)

	// GetBlogPostsInSpaceWithResponse request
	GetBlogPostsInSpaceWithResponse(ctx context.Context, id int64, params *GetBlogPostsInSpaceParams, reqEditors ...RequestEditorFn) (*GetBlogPostsInSpaceResponse, error)

	// DeleteSpaceDefaultClassificationLevelWithResponse request
	DeleteSpaceDefaultClassificationLevelWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*DeleteSpaceDefaultClassificationLevelResponse, error)

	// GetSpaceDefaultClassificationLevelWithResponse request
	GetSpaceDefaultClassificationLevelWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetSpaceDefaultClassificationLevelResponse, error)

	// PutSpaceDefaultClassificationLevelWithBodyWithResponse request with any body
	PutSpaceDefaultClassificationLevelWithBodyWithResponse(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutSpaceDefaultClassificationLevelResponse, error)

	PutSpaceDefaultClassificationLevelWithResponse(ctx context.Context, id int64, body PutSpaceDefaultClassificationLevelJSONRequestBody, reqEditors ...RequestEditorFn) (*PutSpaceDefaultClassificationLevelResponse, error)

	// GetSpaceContentLabelsWithResponse request
	GetSpaceContentLabelsWithResponse(ctx context.Context, id int64, params *GetSpaceContentLabelsParams, reqEditors ...RequestEditorFn) (*GetSpaceContentLabelsResponse, error)

	// GetCustomContentByTypeInSpaceWithResponse request
	GetCustomContentByTypeInSpaceWithResponse(ctx context.Context, id int64, params *GetCustomContentByTypeInSpaceParams, reqEditors ...RequestEditorFn) (*GetCustomContentByTypeInSpaceResponse, error)

	// GetSpaceLabelsWithResponse request
	GetSpaceLabelsWithResponse(ctx context.Context, id int64, params *GetSpaceLabelsParams, reqEditors ...RequestEditorFn) (*GetSpaceLabelsResponse, error)

	// GetSpaceOperationsWithResponse request
	GetSpaceOperationsWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetSpaceOperationsResponse, error)

	// GetPagesInSpaceWithResponse request
	GetPagesInSpaceWithResponse(ctx context.Context, id int64, params *GetPagesInSpaceParams, reqEditors ...RequestEditorFn) (*GetPagesInSpaceResponse, error)

	// GetSpacePermissionsWithResponse request
	GetSpacePermissionsWithResponse(ctx context.Context, id int64, params *GetSpacePermissionsParams, reqEditors ...RequestEditorFn) (*GetSpacePermissionsResponse, error)

	// GetSpacePropertiesWithResponse request
	GetSpacePropertiesWithResponse(ctx context.Context, spaceId int64, params *GetSpacePropertiesParams, reqEditors ...RequestEditorFn) (*GetSpacePropertiesResponse, error)

	// CreateSpacePropertyWithBodyWithResponse request with any body
	CreateSpacePropertyWithBodyWithResponse(ctx context.Context, spaceId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSpacePropertyResponse, error)

	CreateSpacePropertyWithResponse(ctx context.Context, spaceId int64, body CreateSpacePropertyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSpacePropertyResponse, error)

	// DeleteSpacePropertyByIdWithResponse request
	DeleteSpacePropertyByIdWithResponse(ctx context.Context, spaceId int64, propertyId int64, reqEditors ...RequestEditorFn) (*DeleteSpacePropertyByIdResponse, error)

	// GetSpacePropertyByIdWithResponse request
	GetSpacePropertyByIdWithResponse(ctx context.Context, spaceId int64, propertyId int64, reqEditors ...RequestEditorFn) (*GetSpacePropertyByIdResponse, error)

	// UpdateSpacePropertyByIdWithBodyWithResponse request with any body
	UpdateSpacePropertyByIdWithBodyWithResponse(ctx context.Context, spaceId int64, propertyId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSpacePropertyByIdResponse, error)

	UpdateSpacePropertyByIdWithResponse(ctx context.Context, spaceId int64, propertyId int64, body UpdateSpacePropertyByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSpacePropertyByIdResponse, error)

	// GetTasksWithResponse request
	GetTasksWithResponse(ctx context.Context, params *GetTasksParams, reqEditors ...RequestEditorFn) (*GetTasksResponse, error)

	// GetTaskByIdWithResponse request
	GetTaskByIdWithResponse(ctx context.Context, id int64, params *GetTaskByIdParams, reqEditors ...RequestEditorFn) (*GetTaskByIdResponse, error)

	// UpdateTaskWithBodyWithResponse request with any body
	UpdateTaskWithBodyWithResponse(ctx context.Context, id int64, params *UpdateTaskParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTaskResponse, error)

	UpdateTaskWithResponse(ctx context.Context, id int64, params *UpdateTaskParams, body UpdateTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTaskResponse, error)

	// CheckAccessByEmailWithBodyWithResponse request with any body
	CheckAccessByEmailWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CheckAccessByEmailResponse, error)

	CheckAccessByEmailWithResponse(ctx context.Context, body CheckAccessByEmailJSONRequestBody, reqEditors ...RequestEditorFn) (*CheckAccessByEmailResponse, error)

	// InviteByEmailWithBodyWithResponse request with any body
	InviteByEmailWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InviteByEmailResponse, error)

	InviteByEmailWithResponse(ctx context.Context, body InviteByEmailJSONRequestBody, reqEditors ...RequestEditorFn) (*InviteByEmailResponse, error)

	// CreateBulkUserLookupWithBodyWithResponse request with any body
	CreateBulkUserLookupWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBulkUserLookupResponse, error)

	CreateBulkUserLookupWithResponse(ctx context.Context, body CreateBulkUserLookupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBulkUserLookupResponse, error)

	// CreateWhiteboardWithBodyWithResponse request with any body
	CreateWhiteboardWithBodyWithResponse(ctx context.Context, params *CreateWhiteboardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateWhiteboardResponse, error)

	CreateWhiteboardWithResponse(ctx context.Context, params *CreateWhiteboardParams, body CreateWhiteboardJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateWhiteboardResponse, error)

	// DeleteWhiteboardWithResponse request
	DeleteWhiteboardWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*DeleteWhiteboardResponse, error)

	// GetWhiteboardByIdWithResponse request
	GetWhiteboardByIdWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetWhiteboardByIdResponse, error)

	// GetWhiteboardAncestorsWithResponse request
	GetWhiteboardAncestorsWithResponse(ctx context.Context, id int64, params *GetWhiteboardAncestorsParams, reqEditors ...RequestEditorFn) (*GetWhiteboardAncestorsResponse, error)

	// GetWhiteboardClassificationLevelWithResponse request
	GetWhiteboardClassificationLevelWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetWhiteboardClassificationLevelResponse, error)

	// PutWhiteboardClassificationLevelWithBodyWithResponse request with any body
	PutWhiteboardClassificationLevelWithBodyWithResponse(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutWhiteboardClassificationLevelResponse, error)

	PutWhiteboardClassificationLevelWithResponse(ctx context.Context, id int64, body PutWhiteboardClassificationLevelJSONRequestBody, reqEditors ...RequestEditorFn) (*PutWhiteboardClassificationLevelResponse, error)

	// PostWhiteboardClassificationLevelWithBodyWithResponse request with any body
	PostWhiteboardClassificationLevelWithBodyWithResponse(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostWhiteboardClassificationLevelResponse, error)

	PostWhiteboardClassificationLevelWithResponse(ctx context.Context, id int64, body PostWhiteboardClassificationLevelJSONRequestBody, reqEditors ...RequestEditorFn) (*PostWhiteboardClassificationLevelResponse, error)

	// GetWhiteboardOperationsWithResponse request
	GetWhiteboardOperationsWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetWhiteboardOperationsResponse, error)

	// GetWhiteboardContentPropertiesWithResponse request
	GetWhiteboardContentPropertiesWithResponse(ctx context.Context, id int64, params *GetWhiteboardContentPropertiesParams, reqEditors ...RequestEditorFn) (*GetWhiteboardContentPropertiesResponse, error)

	// CreateWhiteboardPropertyWithBodyWithResponse request with any body
	CreateWhiteboardPropertyWithBodyWithResponse(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateWhiteboardPropertyResponse, error)

	CreateWhiteboardPropertyWithResponse(ctx context.Context, id int64, body CreateWhiteboardPropertyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateWhiteboardPropertyResponse, error)

	// DeleteWhiteboardPropertyByIdWithResponse request
	DeleteWhiteboardPropertyByIdWithResponse(ctx context.Context, whiteboardId int64, propertyId int64, reqEditors ...RequestEditorFn) (*DeleteWhiteboardPropertyByIdResponse, error)

	// GetWhiteboardContentPropertiesByIdWithResponse request
	GetWhiteboardContentPropertiesByIdWithResponse(ctx context.Context, whiteboardId int64, propertyId int64, reqEditors ...RequestEditorFn) (*GetWhiteboardContentPropertiesByIdResponse, error)

	// UpdateWhiteboardPropertyByIdWithBodyWithResponse request with any body
	UpdateWhiteboardPropertyByIdWithBodyWithResponse(ctx context.Context, whiteboardId int64, propertyId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateWhiteboardPropertyByIdResponse, error)

	UpdateWhiteboardPropertyByIdWithResponse(ctx context.Context, whiteboardId int64, propertyId int64, body UpdateWhiteboardPropertyByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateWhiteboardPropertyByIdResponse, error)
}

type GetAttachmentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Links   *MultiEntityLinks `json:"_links,omitempty"`
		Results *[]AttachmentBulk `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetAttachmentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAttachmentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAttachmentContentPropertiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Links   *MultiEntityLinks  `json:"_links,omitempty"`
		Results *[]ContentProperty `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetAttachmentContentPropertiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAttachmentContentPropertiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAttachmentPropertyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ContentProperty
}

// Status returns HTTPResponse.Status
func (r CreateAttachmentPropertyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAttachmentPropertyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAttachmentPropertyByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteAttachmentPropertyByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAttachmentPropertyByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAttachmentContentPropertiesByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ContentProperty
}

// Status returns HTTPResponse.Status
func (r GetAttachmentContentPropertiesByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAttachmentContentPropertiesByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAttachmentPropertyByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ContentProperty
}

// Status returns HTTPResponse.Status
func (r UpdateAttachmentPropertyByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAttachmentPropertyByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAttachmentVersionDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DetailedVersion
}

// Status returns HTTPResponse.Status
func (r GetAttachmentVersionDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAttachmentVersionDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAttachmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteAttachmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAttachmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAttachmentByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Links *struct {
			// Base Base url of the Confluence site.
			Base *string `json:"base,omitempty"`
		} `json:"_links,omitempty"`

		// BlogPostId ID of the containing blog post.
		//
		// Note: This is only returned if the attachment has a container that is a blog post.
		BlogPostId *string `json:"blogPostId,omitempty"`

		// Comment Comment for the attachment.
		Comment *string `json:"comment,omitempty"`

		// CreatedAt Date and time when the attachment was created. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
		CreatedAt *time.Time `json:"createdAt,omitempty"`

		// CustomContentId ID of the containing custom content.
		//
		// Note: This is only returned if the attachment has a container that is custom content.
		CustomContentId *string `json:"customContentId,omitempty"`

		// DownloadLink Download link of the attachment.
		DownloadLink *string `json:"downloadLink,omitempty"`

		// FileId File ID of the attachment. This is the ID referenced in `atlas_doc_format` bodies and is distinct from the attachment ID.
		FileId *string `json:"fileId,omitempty"`

		// FileSize File size of the attachment.
		FileSize *int64 `json:"fileSize,omitempty"`

		// Id ID of the attachment.
		Id     *string `json:"id,omitempty"`
		Labels *struct {
			Links   *OptionalFieldLinks `json:"_links,omitempty"`
			Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
			Results *[]Label            `json:"results,omitempty"`
		} `json:"labels,omitempty"`

		// MediaType Media Type for the attachment.
		MediaType *string `json:"mediaType,omitempty"`

		// MediaTypeDescription Media Type description for the attachment.
		MediaTypeDescription *string `json:"mediaTypeDescription,omitempty"`
		Operations           *struct {
			Links   *OptionalFieldLinks `json:"_links,omitempty"`
			Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
			Results *[]Operation        `json:"results,omitempty"`
		} `json:"operations,omitempty"`

		// PageId ID of the containing page.
		//
		// Note: This is only returned if the attachment has a container that is a page.
		PageId     *string `json:"pageId,omitempty"`
		Properties *struct {
			Links   *OptionalFieldLinks `json:"_links,omitempty"`
			Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
			Results *[]ContentProperty  `json:"results,omitempty"`
		} `json:"properties,omitempty"`

		// Status The status of the content.
		Status *ContentStatus `json:"status,omitempty"`

		// Title Title of the comment.
		Title    *string  `json:"title,omitempty"`
		Version  *Version `json:"version,omitempty"`
		Versions *struct {
			Links   *OptionalFieldLinks `json:"_links,omitempty"`
			Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
			Results *[]Version          `json:"results,omitempty"`
		} `json:"versions,omitempty"`

		// WebuiLink WebUI link of the attachment.
		WebuiLink *string `json:"webuiLink,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetAttachmentByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAttachmentByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAttachmentCommentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Links   *MultiEntityLinks         `json:"_links,omitempty"`
		Results *[]AttachmentCommentModel `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetAttachmentCommentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAttachmentCommentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAttachmentLabelsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Links   *MultiEntityLinks `json:"_links,omitempty"`
		Results *[]Label          `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetAttachmentLabelsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAttachmentLabelsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAttachmentOperationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PermittedOperationsResponse
}

// Status returns HTTPResponse.Status
func (r GetAttachmentOperationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAttachmentOperationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAttachmentVersionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Links   *MultiEntityLinks    `json:"_links,omitempty"`
		Results *[]AttachmentVersion `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetAttachmentVersionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAttachmentVersionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBlogPostsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Links   *MultiEntityLinks `json:"_links,omitempty"`
		Results *[]BlogPostBulk   `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetBlogPostsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBlogPostsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBlogPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Links *struct {
			// Base Base url of the Confluence site.
			Base *string `json:"base,omitempty"`
		} `json:"_links,omitempty"`

		// AuthorId The account ID of the user who created this blog post originally.
		AuthorId *string `json:"authorId,omitempty"`

		// Body Contains fields for each representation type requested.
		Body *BodySingle `json:"body,omitempty"`

		// CreatedAt Date and time when the blog post was created. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
		CreatedAt *time.Time `json:"createdAt,omitempty"`

		// Id ID of the blog post.
		Id *string `json:"id,omitempty"`

		// IsFavoritedByCurrentUser Whether the blog post has been favorited by the current user.
		IsFavoritedByCurrentUser *bool `json:"isFavoritedByCurrentUser,omitempty"`
		Labels                   *struct {
			Links   *OptionalFieldLinks `json:"_links,omitempty"`
			Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
			Results *[]Label            `json:"results,omitempty"`
		} `json:"labels,omitempty"`
		Likes *struct {
			Links   *OptionalFieldLinks `json:"_links,omitempty"`
			Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
			Results *[]Like             `json:"results,omitempty"`
		} `json:"likes,omitempty"`
		Operations *struct {
			Links   *OptionalFieldLinks `json:"_links,omitempty"`
			Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
			Results *[]Operation        `json:"results,omitempty"`
		} `json:"operations,omitempty"`
		Properties *struct {
			Links   *OptionalFieldLinks `json:"_links,omitempty"`
			Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
			Results *[]ContentProperty  `json:"results,omitempty"`
		} `json:"properties,omitempty"`

		// SpaceId ID of the space the blog post is in.
		SpaceId *string `json:"spaceId,omitempty"`

		// Status The status of the content.
		Status *BlogPostContentStatus `json:"status,omitempty"`

		// Title Title of the blog post.
		Title    *string  `json:"title,omitempty"`
		Version  *Version `json:"version,omitempty"`
		Versions *struct {
			Links   *OptionalFieldLinks `json:"_links,omitempty"`
			Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
			Results *[]Version          `json:"results,omitempty"`
		} `json:"versions,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateBlogPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBlogPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBlogpostContentPropertiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Links   *MultiEntityLinks  `json:"_links,omitempty"`
		Results *[]ContentProperty `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetBlogpostContentPropertiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBlogpostContentPropertiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBlogpostPropertyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ContentProperty
}

// Status returns HTTPResponse.Status
func (r CreateBlogpostPropertyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBlogpostPropertyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteBlogpostPropertyByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteBlogpostPropertyByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteBlogpostPropertyByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBlogpostContentPropertiesByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ContentProperty
}

// Status returns HTTPResponse.Status
func (r GetBlogpostContentPropertiesByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBlogpostContentPropertiesByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateBlogpostPropertyByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ContentProperty
}

// Status returns HTTPResponse.Status
func (r UpdateBlogpostPropertyByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateBlogpostPropertyByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBlogPostVersionDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DetailedVersion
}

// Status returns HTTPResponse.Status
func (r GetBlogPostVersionDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBlogPostVersionDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteBlogPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteBlogPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteBlogPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBlogPostByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Links *struct {
			// Base Base url of the Confluence site.
			Base *string `json:"base,omitempty"`
		} `json:"_links,omitempty"`

		// AuthorId The account ID of the user who created this blog post originally.
		AuthorId *string `json:"authorId,omitempty"`

		// Body Contains fields for each representation type requested.
		Body *BodySingle `json:"body,omitempty"`

		// CreatedAt Date and time when the blog post was created. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
		CreatedAt *time.Time `json:"createdAt,omitempty"`

		// Id ID of the blog post.
		Id *string `json:"id,omitempty"`

		// IsFavoritedByCurrentUser Whether the blog post has been favorited by the current user.
		IsFavoritedByCurrentUser *bool `json:"isFavoritedByCurrentUser,omitempty"`
		Labels                   *struct {
			Links   *OptionalFieldLinks `json:"_links,omitempty"`
			Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
			Results *[]Label            `json:"results,omitempty"`
		} `json:"labels,omitempty"`
		Likes *struct {
			Links   *OptionalFieldLinks `json:"_links,omitempty"`
			Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
			Results *[]Like             `json:"results,omitempty"`
		} `json:"likes,omitempty"`
		Operations *struct {
			Links   *OptionalFieldLinks `json:"_links,omitempty"`
			Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
			Results *[]Operation        `json:"results,omitempty"`
		} `json:"operations,omitempty"`
		Properties *struct {
			Links   *OptionalFieldLinks `json:"_links,omitempty"`
			Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
			Results *[]ContentProperty  `json:"results,omitempty"`
		} `json:"properties,omitempty"`

		// SpaceId ID of the space the blog post is in.
		SpaceId *string `json:"spaceId,omitempty"`

		// Status The status of the content.
		Status *BlogPostContentStatus `json:"status,omitempty"`

		// Title Title of the blog post.
		Title    *string  `json:"title,omitempty"`
		Version  *Version `json:"version,omitempty"`
		Versions *struct {
			Links   *OptionalFieldLinks `json:"_links,omitempty"`
			Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
			Results *[]Version          `json:"results,omitempty"`
		} `json:"versions,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetBlogPostByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBlogPostByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateBlogPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Links *struct {
			// Base Base url of the Confluence site.
			Base *string `json:"base,omitempty"`
		} `json:"_links,omitempty"`

		// AuthorId The account ID of the user who created this blog post originally.
		AuthorId *string `json:"authorId,omitempty"`

		// Body Contains fields for each representation type requested.
		Body *BodySingle `json:"body,omitempty"`

		// CreatedAt Date and time when the blog post was created. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
		CreatedAt *time.Time `json:"createdAt,omitempty"`

		// Id ID of the blog post.
		Id *string `json:"id,omitempty"`

		// IsFavoritedByCurrentUser Whether the blog post has been favorited by the current user.
		IsFavoritedByCurrentUser *bool `json:"isFavoritedByCurrentUser,omitempty"`
		Labels                   *struct {
			Links   *OptionalFieldLinks `json:"_links,omitempty"`
			Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
			Results *[]Label            `json:"results,omitempty"`
		} `json:"labels,omitempty"`
		Likes *struct {
			Links   *OptionalFieldLinks `json:"_links,omitempty"`
			Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
			Results *[]Like             `json:"results,omitempty"`
		} `json:"likes,omitempty"`
		Operations *struct {
			Links   *OptionalFieldLinks `json:"_links,omitempty"`
			Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
			Results *[]Operation        `json:"results,omitempty"`
		} `json:"operations,omitempty"`
		Properties *struct {
			Links   *OptionalFieldLinks `json:"_links,omitempty"`
			Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
			Results *[]ContentProperty  `json:"results,omitempty"`
		} `json:"properties,omitempty"`

		// SpaceId ID of the space the blog post is in.
		SpaceId *string `json:"spaceId,omitempty"`

		// Status The status of the content.
		Status *BlogPostContentStatus `json:"status,omitempty"`

		// Title Title of the blog post.
		Title    *string  `json:"title,omitempty"`
		Version  *Version `json:"version,omitempty"`
		Versions *struct {
			Links   *OptionalFieldLinks `json:"_links,omitempty"`
			Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
			Results *[]Version          `json:"results,omitempty"`
		} `json:"versions,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdateBlogPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateBlogPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBlogpostAttachmentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Links   *MultiEntityLinks `json:"_links,omitempty"`
		Results *[]AttachmentBulk `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetBlogpostAttachmentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBlogpostAttachmentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBlogPostClassificationLevelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ClassificationLevel
}

// Status returns HTTPResponse.Status
func (r GetBlogPostClassificationLevelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBlogPostClassificationLevelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutBlogPostClassificationLevelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PutBlogPostClassificationLevelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutBlogPostClassificationLevelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostBlogPostClassificationLevelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PostBlogPostClassificationLevelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostBlogPostClassificationLevelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCustomContentByTypeInBlogPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Links   *MultiEntityLinks    `json:"_links,omitempty"`
		Results *[]CustomContentBulk `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetCustomContentByTypeInBlogPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCustomContentByTypeInBlogPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBlogPostFooterCommentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Links   *MultiEntityLinks       `json:"_links,omitempty"`
		Results *[]BlogPostCommentModel `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetBlogPostFooterCommentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBlogPostFooterCommentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBlogPostInlineCommentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Links   *MultiEntityLinks             `json:"_links,omitempty"`
		Results *[]BlogPostInlineCommentModel `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetBlogPostInlineCommentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBlogPostInlineCommentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBlogPostLabelsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Links   *MultiEntityLinks `json:"_links,omitempty"`
		Results *[]Label          `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetBlogPostLabelsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBlogPostLabelsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBlogPostLikeCountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count The count number
		Count *int64 `json:"count,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetBlogPostLikeCountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBlogPostLikeCountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBlogPostLikeUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Links   *MultiEntityLinks `json:"_links,omitempty"`
		Results *[]Like           `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetBlogPostLikeUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBlogPostLikeUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBlogPostOperationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PermittedOperationsResponse
}

// Status returns HTTPResponse.Status
func (r GetBlogPostOperationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBlogPostOperationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBlogPostVersionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Links   *MultiEntityLinks  `json:"_links,omitempty"`
		Results *[]BlogPostVersion `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetBlogPostVersionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBlogPostVersionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClassificationLevelsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ClassificationLevel
}

// Status returns HTTPResponse.Status
func (r GetClassificationLevelsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClassificationLevelsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCommentContentPropertiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Links   *MultiEntityLinks  `json:"_links,omitempty"`
		Results *[]ContentProperty `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetCommentContentPropertiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCommentContentPropertiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateCommentPropertyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ContentProperty
}

// Status returns HTTPResponse.Status
func (r CreateCommentPropertyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateCommentPropertyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCommentPropertyByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteCommentPropertyByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCommentPropertyByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCommentContentPropertiesByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ContentProperty
}

// Status returns HTTPResponse.Status
func (r GetCommentContentPropertiesByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCommentContentPropertiesByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateCommentPropertyByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ContentProperty
}

// Status returns HTTPResponse.Status
func (r UpdateCommentPropertyByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateCommentPropertyByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ConvertContentIdsToContentTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ContentIdToContentTypeResponse
}

// Status returns HTTPResponse.Status
func (r ConvertContentIdsToContentTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ConvertContentIdsToContentTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCustomContentByTypeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Links   *MultiEntityLinks    `json:"_links,omitempty"`
		Results *[]CustomContentBulk `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetCustomContentByTypeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCustomContentByTypeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateCustomContentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Links *struct {
			// Base Base url of the Confluence site.
			Base *string `json:"base,omitempty"`
		} `json:"_links,omitempty"`

		// AuthorId The account ID of the user who created this custom content originally.
		AuthorId *string `json:"authorId,omitempty"`

		// BlogPostId ID of the containing blog post.
		//
		// Note: This is only returned if the custom content has a container that is a blog post.
		BlogPostId *string `json:"blogPostId,omitempty"`

		// Body Contains fields for each representation type requested.
		Body *CustomContentBodySingle `json:"body,omitempty"`

		// CreatedAt Date and time when the custom content was created. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
		CreatedAt *time.Time `json:"createdAt,omitempty"`

		// CustomContentId ID of the containing custom content.
		//
		// Note: This is only returned if the custom content has a container that is custom content.
		CustomContentId *string `json:"customContentId,omitempty"`

		// Id ID of the custom content.
		Id     *string `json:"id,omitempty"`
		Labels *struct {
			Links   *OptionalFieldLinks `json:"_links,omitempty"`
			Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
			Results *[]Label            `json:"results,omitempty"`
		} `json:"labels,omitempty"`
		Operations *struct {
			Links   *OptionalFieldLinks `json:"_links,omitempty"`
			Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
			Results *[]Operation        `json:"results,omitempty"`
		} `json:"operations,omitempty"`

		// PageId ID of the containing page.
		//
		// Note: This is only returned if the custom content has a container that is a page.
		PageId     *string `json:"pageId,omitempty"`
		Properties *struct {
			Links   *OptionalFieldLinks `json:"_links,omitempty"`
			Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
			Results *[]ContentProperty  `json:"results,omitempty"`
		} `json:"properties,omitempty"`

		// SpaceId ID of the space the custom content is in.
		//
		// Note: This is always returned, regardless of if the custom content has a container that is a space.
		SpaceId *string `json:"spaceId,omitempty"`

		// Status The status of the content.
		Status *ContentStatus `json:"status,omitempty"`

		// Title Title of the custom content.
		Title *string `json:"title,omitempty"`

		// Type The type of custom content.
		Type     *string  `json:"type,omitempty"`
		Version  *Version `json:"version,omitempty"`
		Versions *struct {
			Links   *OptionalFieldLinks `json:"_links,omitempty"`
			Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
			Results *[]Version          `json:"results,omitempty"`
		} `json:"versions,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateCustomContentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateCustomContentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCustomContentContentPropertiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Links   *MultiEntityLinks  `json:"_links,omitempty"`
		Results *[]ContentProperty `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetCustomContentContentPropertiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCustomContentContentPropertiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateCustomContentPropertyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ContentProperty
}

// Status returns HTTPResponse.Status
func (r CreateCustomContentPropertyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateCustomContentPropertyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCustomContentPropertyByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteCustomContentPropertyByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCustomContentPropertyByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCustomContentContentPropertiesByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ContentProperty
}

// Status returns HTTPResponse.Status
func (r GetCustomContentContentPropertiesByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCustomContentContentPropertiesByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateCustomContentPropertyByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ContentProperty
}

// Status returns HTTPResponse.Status
func (r UpdateCustomContentPropertyByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateCustomContentPropertyByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCustomContentVersionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Links   *MultiEntityLinks       `json:"_links,omitempty"`
		Results *[]CustomContentVersion `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetCustomContentVersionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCustomContentVersionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCustomContentVersionDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DetailedVersion
}

// Status returns HTTPResponse.Status
func (r GetCustomContentVersionDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCustomContentVersionDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCustomContentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteCustomContentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCustomContentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCustomContentByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Links *struct {
			// Base Base url of the Confluence site.
			Base *string `json:"base,omitempty"`
		} `json:"_links,omitempty"`

		// AuthorId The account ID of the user who created this custom content originally.
		AuthorId *string `json:"authorId,omitempty"`

		// BlogPostId ID of the containing blog post.
		//
		// Note: This is only returned if the custom content has a container that is a blog post.
		BlogPostId *string `json:"blogPostId,omitempty"`

		// Body Contains fields for each representation type requested.
		Body *CustomContentBodySingle `json:"body,omitempty"`

		// CreatedAt Date and time when the custom content was created. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
		CreatedAt *time.Time `json:"createdAt,omitempty"`

		// CustomContentId ID of the containing custom content.
		//
		// Note: This is only returned if the custom content has a container that is custom content.
		CustomContentId *string `json:"customContentId,omitempty"`

		// Id ID of the custom content.
		Id     *string `json:"id,omitempty"`
		Labels *struct {
			Links   *OptionalFieldLinks `json:"_links,omitempty"`
			Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
			Results *[]Label            `json:"results,omitempty"`
		} `json:"labels,omitempty"`
		Operations *struct {
			Links   *OptionalFieldLinks `json:"_links,omitempty"`
			Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
			Results *[]Operation        `json:"results,omitempty"`
		} `json:"operations,omitempty"`

		// PageId ID of the containing page.
		//
		// Note: This is only returned if the custom content has a container that is a page.
		PageId     *string `json:"pageId,omitempty"`
		Properties *struct {
			Links   *OptionalFieldLinks `json:"_links,omitempty"`
			Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
			Results *[]ContentProperty  `json:"results,omitempty"`
		} `json:"properties,omitempty"`

		// SpaceId ID of the space the custom content is in.
		//
		// Note: This is always returned, regardless of if the custom content has a container that is a space.
		SpaceId *string `json:"spaceId,omitempty"`

		// Status The status of the content.
		Status *ContentStatus `json:"status,omitempty"`

		// Title Title of the custom content.
		Title *string `json:"title,omitempty"`

		// Type The type of custom content.
		Type     *string  `json:"type,omitempty"`
		Version  *Version `json:"version,omitempty"`
		Versions *struct {
			Links   *OptionalFieldLinks `json:"_links,omitempty"`
			Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
			Results *[]Version          `json:"results,omitempty"`
		} `json:"versions,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetCustomContentByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCustomContentByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateCustomContentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Links *struct {
			// Base Base url of the Confluence site.
			Base *string `json:"base,omitempty"`
		} `json:"_links,omitempty"`

		// AuthorId The account ID of the user who created this custom content originally.
		AuthorId *string `json:"authorId,omitempty"`

		// BlogPostId ID of the containing blog post.
		//
		// Note: This is only returned if the custom content has a container that is a blog post.
		BlogPostId *string `json:"blogPostId,omitempty"`

		// Body Contains fields for each representation type requested.
		Body *CustomContentBodySingle `json:"body,omitempty"`

		// CreatedAt Date and time when the custom content was created. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
		CreatedAt *time.Time `json:"createdAt,omitempty"`

		// CustomContentId ID of the containing custom content.
		//
		// Note: This is only returned if the custom content has a container that is custom content.
		CustomContentId *string `json:"customContentId,omitempty"`

		// Id ID of the custom content.
		Id     *string `json:"id,omitempty"`
		Labels *struct {
			Links   *OptionalFieldLinks `json:"_links,omitempty"`
			Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
			Results *[]Label            `json:"results,omitempty"`
		} `json:"labels,omitempty"`
		Operations *struct {
			Links   *OptionalFieldLinks `json:"_links,omitempty"`
			Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
			Results *[]Operation        `json:"results,omitempty"`
		} `json:"operations,omitempty"`

		// PageId ID of the containing page.
		//
		// Note: This is only returned if the custom content has a container that is a page.
		PageId     *string `json:"pageId,omitempty"`
		Properties *struct {
			Links   *OptionalFieldLinks `json:"_links,omitempty"`
			Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
			Results *[]ContentProperty  `json:"results,omitempty"`
		} `json:"properties,omitempty"`

		// SpaceId ID of the space the custom content is in.
		//
		// Note: This is always returned, regardless of if the custom content has a container that is a space.
		SpaceId *string `json:"spaceId,omitempty"`

		// Status The status of the content.
		Status *ContentStatus `json:"status,omitempty"`

		// Title Title of the custom content.
		Title *string `json:"title,omitempty"`

		// Type The type of custom content.
		Type     *string  `json:"type,omitempty"`
		Version  *Version `json:"version,omitempty"`
		Versions *struct {
			Links   *OptionalFieldLinks `json:"_links,omitempty"`
			Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
			Results *[]Version          `json:"results,omitempty"`
		} `json:"versions,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdateCustomContentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateCustomContentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCustomContentAttachmentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Links   *MultiEntityLinks `json:"_links,omitempty"`
		Results *[]AttachmentBulk `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetCustomContentAttachmentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCustomContentAttachmentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetChildCustomContentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Links   *MultiEntityLinks     `json:"_links,omitempty"`
		Results *[]ChildCustomContent `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetChildCustomContentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetChildCustomContentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCustomContentCommentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Links   *MultiEntityLinks            `json:"_links,omitempty"`
		Results *[]CustomContentCommentModel `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetCustomContentCommentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCustomContentCommentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCustomContentLabelsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Links   *MultiEntityLinks `json:"_links,omitempty"`
		Results *[]Label          `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetCustomContentLabelsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCustomContentLabelsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCustomContentOperationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PermittedOperationsResponse
}

// Status returns HTTPResponse.Status
func (r GetCustomContentOperationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCustomContentOperationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDataPolicyMetadataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DataPolicyMetadata
}

// Status returns HTTPResponse.Status
func (r GetDataPolicyMetadataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDataPolicyMetadataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDataPolicySpacesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Links   *MultiEntityLinks  `json:"_links,omitempty"`
		Results *[]DataPolicySpace `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetDataPolicySpacesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDataPolicySpacesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateDatabaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Links *struct {
			// Base Base url of the Confluence site.
			Base *string `json:"base,omitempty"`
		} `json:"_links,omitempty"`

		// AuthorId The account ID of the user who created this database originally.
		AuthorId *string `json:"authorId,omitempty"`

		// CreatedAt Date and time when the database was created. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
		CreatedAt *time.Time `json:"createdAt,omitempty"`

		// Id ID of the database.
		Id *string `json:"id,omitempty"`

		// OwnerId The account ID of the user who owns this database.
		OwnerId *string `json:"ownerId,omitempty"`

		// ParentId ID of the parent content, or null if there is no parent content.
		ParentId *string `json:"parentId,omitempty"`

		// ParentType Content type of the parent, or null if there is no parent.
		ParentType *ParentContentType `json:"parentType,omitempty"`

		// Position Position of the database within the given parent page tree.
		Position *int32 `json:"position"`

		// Status The status of the content.
		Status *ContentStatus `json:"status,omitempty"`

		// Title Title of the database.
		Title *string `json:"title,omitempty"`

		// Type The content type of the object.
		Type    *string  `json:"type,omitempty"`
		Version *Version `json:"version,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateDatabaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDatabaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDatabasePropertyByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteDatabasePropertyByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDatabasePropertyByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDatabaseContentPropertiesByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ContentProperty
}

// Status returns HTTPResponse.Status
func (r GetDatabaseContentPropertiesByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDatabaseContentPropertiesByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateDatabasePropertyByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ContentProperty
}

// Status returns HTTPResponse.Status
func (r UpdateDatabasePropertyByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateDatabasePropertyByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDatabaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteDatabaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDatabaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDatabaseByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Links *struct {
			// Base Base url of the Confluence site.
			Base *string `json:"base,omitempty"`
		} `json:"_links,omitempty"`

		// AuthorId The account ID of the user who created this database originally.
		AuthorId *string `json:"authorId,omitempty"`

		// CreatedAt Date and time when the database was created. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
		CreatedAt *time.Time `json:"createdAt,omitempty"`

		// Id ID of the database.
		Id *string `json:"id,omitempty"`

		// OwnerId The account ID of the user who owns this database.
		OwnerId *string `json:"ownerId,omitempty"`

		// ParentId ID of the parent content, or null if there is no parent content.
		ParentId *string `json:"parentId,omitempty"`

		// ParentType Content type of the parent, or null if there is no parent.
		ParentType *ParentContentType `json:"parentType,omitempty"`

		// Position Position of the database within the given parent page tree.
		Position *int32 `json:"position"`

		// Status The status of the content.
		Status *ContentStatus `json:"status,omitempty"`

		// Title Title of the database.
		Title *string `json:"title,omitempty"`

		// Type The content type of the object.
		Type    *string  `json:"type,omitempty"`
		Version *Version `json:"version,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetDatabaseByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDatabaseByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDatabaseAncestorsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Results *[]Ancestor `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetDatabaseAncestorsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDatabaseAncestorsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDatabaseClassificationLevelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ClassificationLevel
}

// Status returns HTTPResponse.Status
func (r GetDatabaseClassificationLevelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDatabaseClassificationLevelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutDatabaseClassificationLevelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PutDatabaseClassificationLevelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutDatabaseClassificationLevelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostDatabaseClassificationLevelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PostDatabaseClassificationLevelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostDatabaseClassificationLevelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDatabaseOperationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PermittedOperationsResponse
}

// Status returns HTTPResponse.Status
func (r GetDatabaseOperationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDatabaseOperationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDatabaseContentPropertiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Links   *MultiEntityLinks  `json:"_links,omitempty"`
		Results *[]ContentProperty `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetDatabaseContentPropertiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDatabaseContentPropertiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateDatabasePropertyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ContentProperty
}

// Status returns HTTPResponse.Status
func (r CreateDatabasePropertyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDatabasePropertyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSmartLinkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Links *struct {
			// Base Base url of the Confluence site.
			Base *string `json:"base,omitempty"`
		} `json:"_links,omitempty"`

		// AuthorId The account ID of the user who created this Smart Link in the content tree originally.
		AuthorId *string `json:"authorId,omitempty"`

		// CreatedAt Date and time when the Smart Link in the content tree was created. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
		CreatedAt *time.Time `json:"createdAt,omitempty"`

		// EmbedUrl The embedded URL of the Smart Link. If the Smart Link does not have an embedded URL, this property will not be included in the response.
		EmbedUrl *string `json:"embedUrl,omitempty"`

		// Id ID of the Smart Link in the content tree.
		Id *string `json:"id,omitempty"`

		// OwnerId The account ID of the user who owns this Smart Link in the content tree.
		OwnerId *string `json:"ownerId,omitempty"`

		// ParentId ID of the parent content, or null if there is no parent content.
		ParentId *string `json:"parentId,omitempty"`

		// ParentType Content type of the parent, or null if there is no parent.
		ParentType *ParentContentType `json:"parentType,omitempty"`

		// Position Position of the Smart Link within the given parent page tree.
		Position *int32 `json:"position"`

		// Status The status of the content.
		Status *ContentStatus `json:"status,omitempty"`

		// Title Title of the Smart Link in the content tree.
		Title *string `json:"title,omitempty"`

		// Type The content type of the object.
		Type    *string  `json:"type,omitempty"`
		Version *Version `json:"version,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateSmartLinkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSmartLinkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSmartLinkPropertyByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteSmartLinkPropertyByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSmartLinkPropertyByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSmartLinkContentPropertiesByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ContentProperty
}

// Status returns HTTPResponse.Status
func (r GetSmartLinkContentPropertiesByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSmartLinkContentPropertiesByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateSmartLinkPropertyByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ContentProperty
}

// Status returns HTTPResponse.Status
func (r UpdateSmartLinkPropertyByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSmartLinkPropertyByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSmartLinkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteSmartLinkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSmartLinkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSmartLinkByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Links *struct {
			// Base Base url of the Confluence site.
			Base *string `json:"base,omitempty"`
		} `json:"_links,omitempty"`

		// AuthorId The account ID of the user who created this Smart Link in the content tree originally.
		AuthorId *string `json:"authorId,omitempty"`

		// CreatedAt Date and time when the Smart Link in the content tree was created. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
		CreatedAt *time.Time `json:"createdAt,omitempty"`

		// EmbedUrl The embedded URL of the Smart Link. If the Smart Link does not have an embedded URL, this property will not be included in the response.
		EmbedUrl *string `json:"embedUrl,omitempty"`

		// Id ID of the Smart Link in the content tree.
		Id *string `json:"id,omitempty"`

		// OwnerId The account ID of the user who owns this Smart Link in the content tree.
		OwnerId *string `json:"ownerId,omitempty"`

		// ParentId ID of the parent content, or null if there is no parent content.
		ParentId *string `json:"parentId,omitempty"`

		// ParentType Content type of the parent, or null if there is no parent.
		ParentType *ParentContentType `json:"parentType,omitempty"`

		// Position Position of the Smart Link within the given parent page tree.
		Position *int32 `json:"position"`

		// Status The status of the content.
		Status *ContentStatus `json:"status,omitempty"`

		// Title Title of the Smart Link in the content tree.
		Title *string `json:"title,omitempty"`

		// Type The content type of the object.
		Type    *string  `json:"type,omitempty"`
		Version *Version `json:"version,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetSmartLinkByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSmartLinkByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSmartLinkAncestorsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Results *[]Ancestor `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetSmartLinkAncestorsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSmartLinkAncestorsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSmartLinkOperationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PermittedOperationsResponse
}

// Status returns HTTPResponse.Status
func (r GetSmartLinkOperationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSmartLinkOperationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSmartLinkContentPropertiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Links   *MultiEntityLinks  `json:"_links,omitempty"`
		Results *[]ContentProperty `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetSmartLinkContentPropertiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSmartLinkContentPropertiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSmartLinkPropertyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ContentProperty
}

// Status returns HTTPResponse.Status
func (r CreateSmartLinkPropertyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSmartLinkPropertyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateFolderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Links *struct {
			// Base Base url of the Confluence site.
			Base *string `json:"base,omitempty"`
		} `json:"_links,omitempty"`

		// AuthorId The account ID of the user who created this folder.
		AuthorId *string `json:"authorId,omitempty"`

		// CreatedAt Date and time when the folder was created. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
		CreatedAt *time.Time `json:"createdAt,omitempty"`

		// Id ID of the folder.
		Id *string `json:"id,omitempty"`

		// OwnerId The account ID of the user who owns this folder.
		OwnerId *string `json:"ownerId,omitempty"`

		// ParentId ID of the parent content, or null if there is no parent content.
		ParentId *string `json:"parentId,omitempty"`

		// ParentType Content type of the parent, or null if there is no parent.
		ParentType *ParentContentType `json:"parentType,omitempty"`

		// Position Position of the folder within the given parent page tree.
		Position *int32 `json:"position"`

		// Status The status of the content.
		Status *ContentStatus `json:"status,omitempty"`

		// Title Title of the folder.
		Title *string `json:"title,omitempty"`

		// Type The content type of the object.
		Type    *string  `json:"type,omitempty"`
		Version *Version `json:"version,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateFolderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateFolderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteFolderPropertyByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteFolderPropertyByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteFolderPropertyByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFolderContentPropertiesByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ContentProperty
}

// Status returns HTTPResponse.Status
func (r GetFolderContentPropertiesByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFolderContentPropertiesByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateFolderPropertyByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ContentProperty
}

// Status returns HTTPResponse.Status
func (r UpdateFolderPropertyByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateFolderPropertyByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteFolderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteFolderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteFolderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFolderByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Links *struct {
			// Base Base url of the Confluence site.
			Base *string `json:"base,omitempty"`
		} `json:"_links,omitempty"`

		// AuthorId The account ID of the user who created this folder.
		AuthorId *string `json:"authorId,omitempty"`

		// CreatedAt Date and time when the folder was created. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
		CreatedAt *time.Time `json:"createdAt,omitempty"`

		// Id ID of the folder.
		Id *string `json:"id,omitempty"`

		// OwnerId The account ID of the user who owns this folder.
		OwnerId *string `json:"ownerId,omitempty"`

		// ParentId ID of the parent content, or null if there is no parent content.
		ParentId *string `json:"parentId,omitempty"`

		// ParentType Content type of the parent, or null if there is no parent.
		ParentType *ParentContentType `json:"parentType,omitempty"`

		// Position Position of the folder within the given parent page tree.
		Position *int32 `json:"position"`

		// Status The status of the content.
		Status *ContentStatus `json:"status,omitempty"`

		// Title Title of the folder.
		Title *string `json:"title,omitempty"`

		// Type The content type of the object.
		Type    *string  `json:"type,omitempty"`
		Version *Version `json:"version,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetFolderByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFolderByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFolderAncestorsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Results *[]Ancestor `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetFolderAncestorsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFolderAncestorsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFolderOperationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PermittedOperationsResponse
}

// Status returns HTTPResponse.Status
func (r GetFolderOperationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFolderOperationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFolderContentPropertiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Links   *MultiEntityLinks  `json:"_links,omitempty"`
		Results *[]ContentProperty `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetFolderContentPropertiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFolderContentPropertiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateFolderPropertyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ContentProperty
}

// Status returns HTTPResponse.Status
func (r CreateFolderPropertyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateFolderPropertyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFooterCommentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Links   *MultiEntityLinks     `json:"_links,omitempty"`
		Results *[]FooterCommentModel `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetFooterCommentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFooterCommentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateFooterCommentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Links *struct {
			// Base Base url of the Confluence site.
			Base *string `json:"base,omitempty"`
		} `json:"_links,omitempty"`

		// AttachmentId ID of the attachment containing the comment if the comment is on an attachment.
		AttachmentId *string `json:"attachmentId,omitempty"`

		// BlogPostId ID of the blog post containing the comment if the comment is on a blog post.
		BlogPostId *string `json:"blogPostId,omitempty"`

		// Body Contains fields for each representation type requested.
		Body *BodySingle `json:"body,omitempty"`

		// CustomContentId ID of the custom content containing the comment if the comment is on a custom content.
		CustomContentId *string `json:"customContentId,omitempty"`

		// Id ID of the comment.
		Id    *string `json:"id,omitempty"`
		Likes *struct {
			Links   *OptionalFieldLinks `json:"_links,omitempty"`
			Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
			Results *[]Like             `json:"results,omitempty"`
		} `json:"likes,omitempty"`
		Operations *struct {
			Links   *OptionalFieldLinks `json:"_links,omitempty"`
			Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
			Results *[]Operation        `json:"results,omitempty"`
		} `json:"operations,omitempty"`

		// PageId ID of the page containing the comment if the comment is on a page.
		PageId *string `json:"pageId,omitempty"`

		// ParentCommentId ID of the parent comment if the comment is a reply.
		ParentCommentId *string `json:"parentCommentId,omitempty"`
		Properties      *struct {
			Links   *OptionalFieldLinks `json:"_links,omitempty"`
			Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
			Results *[]ContentProperty  `json:"results,omitempty"`
		} `json:"properties,omitempty"`

		// Status The status of the content.
		Status *ContentStatus `json:"status,omitempty"`

		// Title Title of the comment.
		Title    *string  `json:"title,omitempty"`
		Version  *Version `json:"version,omitempty"`
		Versions *struct {
			Links   *OptionalFieldLinks `json:"_links,omitempty"`
			Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
			Results *[]Version          `json:"results,omitempty"`
		} `json:"versions,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateFooterCommentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateFooterCommentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteFooterCommentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteFooterCommentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteFooterCommentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFooterCommentByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Links *struct {
			// Base Base url of the Confluence site.
			Base *string `json:"base,omitempty"`
		} `json:"_links,omitempty"`

		// AttachmentId ID of the attachment containing the comment if the comment is on an attachment.
		AttachmentId *string `json:"attachmentId,omitempty"`

		// BlogPostId ID of the blog post containing the comment if the comment is on a blog post.
		BlogPostId *string `json:"blogPostId,omitempty"`

		// Body Contains fields for each representation type requested.
		Body *BodySingle `json:"body,omitempty"`

		// CustomContentId ID of the custom content containing the comment if the comment is on a custom content.
		CustomContentId *string `json:"customContentId,omitempty"`

		// Id ID of the comment.
		Id    *string `json:"id,omitempty"`
		Likes *struct {
			Links   *OptionalFieldLinks `json:"_links,omitempty"`
			Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
			Results *[]Like             `json:"results,omitempty"`
		} `json:"likes,omitempty"`
		Operations *struct {
			Links   *OptionalFieldLinks `json:"_links,omitempty"`
			Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
			Results *[]Operation        `json:"results,omitempty"`
		} `json:"operations,omitempty"`

		// PageId ID of the page containing the comment if the comment is on a page.
		PageId *string `json:"pageId,omitempty"`

		// ParentCommentId ID of the parent comment if the comment is a reply.
		ParentCommentId *string `json:"parentCommentId,omitempty"`
		Properties      *struct {
			Links   *OptionalFieldLinks `json:"_links,omitempty"`
			Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
			Results *[]ContentProperty  `json:"results,omitempty"`
		} `json:"properties,omitempty"`

		// Status The status of the content.
		Status *ContentStatus `json:"status,omitempty"`

		// Title Title of the comment.
		Title    *string  `json:"title,omitempty"`
		Version  *Version `json:"version,omitempty"`
		Versions *struct {
			Links   *OptionalFieldLinks `json:"_links,omitempty"`
			Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
			Results *[]Version          `json:"results,omitempty"`
		} `json:"versions,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetFooterCommentByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFooterCommentByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateFooterCommentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FooterCommentModel
}

// Status returns HTTPResponse.Status
func (r UpdateFooterCommentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateFooterCommentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFooterCommentChildrenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Links   *MultiEntityLinks       `json:"_links,omitempty"`
		Results *[]ChildrenCommentModel `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetFooterCommentChildrenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFooterCommentChildrenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFooterLikeCountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count The count number
		Count *int64 `json:"count,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetFooterLikeCountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFooterLikeCountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFooterLikeUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Links   *MultiEntityLinks `json:"_links,omitempty"`
		Results *[]Like           `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetFooterLikeUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFooterLikeUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFooterCommentOperationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PermittedOperationsResponse
}

// Status returns HTTPResponse.Status
func (r GetFooterCommentOperationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFooterCommentOperationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFooterCommentVersionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Links   *MultiEntityLinks `json:"_links,omitempty"`
		Results *[]CommentVersion `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetFooterCommentVersionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFooterCommentVersionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFooterCommentVersionDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DetailedVersion
}

// Status returns HTTPResponse.Status
func (r GetFooterCommentVersionDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFooterCommentVersionDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInlineCommentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Links   *MultiEntityLinks     `json:"_links,omitempty"`
		Results *[]InlineCommentModel `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetInlineCommentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInlineCommentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateInlineCommentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Links *struct {
			// Base Base url of the Confluence site.
			Base *string `json:"base,omitempty"`
		} `json:"_links,omitempty"`

		// BlogPostId ID of the blog post containing the comment if the comment is on a blog post.
		BlogPostId *string `json:"blogPostId,omitempty"`

		// Body Contains fields for each representation type requested.
		Body *BodySingle `json:"body,omitempty"`

		// Id ID of the comment.
		Id    *string `json:"id,omitempty"`
		Likes *struct {
			Links   *OptionalFieldLinks `json:"_links,omitempty"`
			Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
			Results *[]Like             `json:"results,omitempty"`
		} `json:"likes,omitempty"`
		Operations *struct {
			Links   *OptionalFieldLinks `json:"_links,omitempty"`
			Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
			Results *[]Operation        `json:"results,omitempty"`
		} `json:"operations,omitempty"`

		// PageId ID of the page containing the comment if the comment is on a page.
		PageId *string `json:"pageId,omitempty"`

		// ParentCommentId ID of the parent comment if the comment is a reply.
		ParentCommentId *string `json:"parentCommentId,omitempty"`
		Properties      *struct {
			Links *OptionalFieldLinks `json:"_links,omitempty"`

			// InlineMarkerRef Property value used to reference the highlighted element in DOM.
			InlineMarkerRef *string `json:"inlineMarkerRef,omitempty"`

			// InlineOriginalSelection Text that is highlighted.
			InlineOriginalSelection *string            `json:"inlineOriginalSelection,omitempty"`
			Meta                    *OptionalFieldMeta `json:"meta,omitempty"`
			Results                 *[]ContentProperty `json:"results,omitempty"`
		} `json:"properties,omitempty"`

		// ResolutionLastModifiedAt Timestamp of the last modification to the comment's resolution status. Null until comment is resolved or reopened.
		ResolutionLastModifiedAt *time.Time `json:"resolutionLastModifiedAt,omitempty"`

		// ResolutionLastModifierId Atlassian Account ID of last person who modified the resolve state of the comment. Null until comment is resolved or reopened.
		ResolutionLastModifierId *string `json:"resolutionLastModifierId,omitempty"`

		// ResolutionStatus Inline comment resolution status
		ResolutionStatus *InlineCommentResolutionStatus `json:"resolutionStatus,omitempty"`

		// Status The status of the content.
		Status *ContentStatus `json:"status,omitempty"`

		// Title Title of the comment.
		Title    *string  `json:"title,omitempty"`
		Version  *Version `json:"version,omitempty"`
		Versions *struct {
			Links   *OptionalFieldLinks `json:"_links,omitempty"`
			Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
			Results *[]Version          `json:"results,omitempty"`
		} `json:"versions,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateInlineCommentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateInlineCommentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteInlineCommentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteInlineCommentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteInlineCommentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInlineCommentByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Links *struct {
			// Base Base url of the Confluence site.
			Base *string `json:"base,omitempty"`
		} `json:"_links,omitempty"`

		// BlogPostId ID of the blog post containing the comment if the comment is on a blog post.
		BlogPostId *string `json:"blogPostId,omitempty"`

		// Body Contains fields for each representation type requested.
		Body *BodySingle `json:"body,omitempty"`

		// Id ID of the comment.
		Id    *string `json:"id,omitempty"`
		Likes *struct {
			Links   *OptionalFieldLinks `json:"_links,omitempty"`
			Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
			Results *[]Like             `json:"results,omitempty"`
		} `json:"likes,omitempty"`
		Operations *struct {
			Links   *OptionalFieldLinks `json:"_links,omitempty"`
			Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
			Results *[]Operation        `json:"results,omitempty"`
		} `json:"operations,omitempty"`

		// PageId ID of the page containing the comment if the comment is on a page.
		PageId *string `json:"pageId,omitempty"`

		// ParentCommentId ID of the parent comment if the comment is a reply.
		ParentCommentId *string `json:"parentCommentId,omitempty"`
		Properties      *struct {
			Links *OptionalFieldLinks `json:"_links,omitempty"`

			// InlineMarkerRef Property value used to reference the highlighted element in DOM.
			InlineMarkerRef *string `json:"inlineMarkerRef,omitempty"`

			// InlineOriginalSelection Text that is highlighted.
			InlineOriginalSelection *string            `json:"inlineOriginalSelection,omitempty"`
			Meta                    *OptionalFieldMeta `json:"meta,omitempty"`
			Results                 *[]ContentProperty `json:"results,omitempty"`
		} `json:"properties,omitempty"`

		// ResolutionLastModifiedAt Timestamp of the last modification to the comment's resolution status. Null until comment is resolved or reopened.
		ResolutionLastModifiedAt *time.Time `json:"resolutionLastModifiedAt,omitempty"`

		// ResolutionLastModifierId Atlassian Account ID of last person who modified the resolve state of the comment. Null until comment is resolved or reopened.
		ResolutionLastModifierId *string `json:"resolutionLastModifierId,omitempty"`

		// ResolutionStatus Inline comment resolution status
		ResolutionStatus *InlineCommentResolutionStatus `json:"resolutionStatus,omitempty"`

		// Status The status of the content.
		Status *ContentStatus `json:"status,omitempty"`

		// Title Title of the comment.
		Title    *string  `json:"title,omitempty"`
		Version  *Version `json:"version,omitempty"`
		Versions *struct {
			Links   *OptionalFieldLinks `json:"_links,omitempty"`
			Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
			Results *[]Version          `json:"results,omitempty"`
		} `json:"versions,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetInlineCommentByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInlineCommentByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateInlineCommentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Links *struct {
			// Base Base url of the Confluence site.
			Base *string `json:"base,omitempty"`
		} `json:"_links,omitempty"`

		// BlogPostId ID of the blog post containing the comment if the comment is on a blog post.
		BlogPostId *string `json:"blogPostId,omitempty"`

		// Body Contains fields for each representation type requested.
		Body *BodySingle `json:"body,omitempty"`

		// Id ID of the comment.
		Id    *string `json:"id,omitempty"`
		Likes *struct {
			Links   *OptionalFieldLinks `json:"_links,omitempty"`
			Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
			Results *[]Like             `json:"results,omitempty"`
		} `json:"likes,omitempty"`
		Operations *struct {
			Links   *OptionalFieldLinks `json:"_links,omitempty"`
			Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
			Results *[]Operation        `json:"results,omitempty"`
		} `json:"operations,omitempty"`

		// PageId ID of the page containing the comment if the comment is on a page.
		PageId *string `json:"pageId,omitempty"`

		// ParentCommentId ID of the parent comment if the comment is a reply.
		ParentCommentId *string `json:"parentCommentId,omitempty"`
		Properties      *struct {
			Links *OptionalFieldLinks `json:"_links,omitempty"`

			// InlineMarkerRef Property value used to reference the highlighted element in DOM.
			InlineMarkerRef *string `json:"inlineMarkerRef,omitempty"`

			// InlineOriginalSelection Text that is highlighted.
			InlineOriginalSelection *string            `json:"inlineOriginalSelection,omitempty"`
			Meta                    *OptionalFieldMeta `json:"meta,omitempty"`
			Results                 *[]ContentProperty `json:"results,omitempty"`
		} `json:"properties,omitempty"`

		// ResolutionLastModifiedAt Timestamp of the last modification to the comment's resolution status. Null until comment is resolved or reopened.
		ResolutionLastModifiedAt *time.Time `json:"resolutionLastModifiedAt,omitempty"`

		// ResolutionLastModifierId Atlassian Account ID of last person who modified the resolve state of the comment. Null until comment is resolved or reopened.
		ResolutionLastModifierId *string `json:"resolutionLastModifierId,omitempty"`

		// ResolutionStatus Inline comment resolution status
		ResolutionStatus *InlineCommentResolutionStatus `json:"resolutionStatus,omitempty"`

		// Status The status of the content.
		Status *ContentStatus `json:"status,omitempty"`

		// Title Title of the comment.
		Title    *string  `json:"title,omitempty"`
		Version  *Version `json:"version,omitempty"`
		Versions *struct {
			Links   *OptionalFieldLinks `json:"_links,omitempty"`
			Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
			Results *[]Version          `json:"results,omitempty"`
		} `json:"versions,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdateInlineCommentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateInlineCommentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInlineCommentChildrenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Links   *MultiEntityLinks             `json:"_links,omitempty"`
		Results *[]InlineCommentChildrenModel `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetInlineCommentChildrenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInlineCommentChildrenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInlineLikeCountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count The count number
		Count *int64 `json:"count,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetInlineLikeCountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInlineLikeCountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInlineLikeUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Links   *MultiEntityLinks `json:"_links,omitempty"`
		Results *[]Like           `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetInlineLikeUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInlineLikeUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInlineCommentOperationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PermittedOperationsResponse
}

// Status returns HTTPResponse.Status
func (r GetInlineCommentOperationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInlineCommentOperationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInlineCommentVersionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Links   *MultiEntityLinks `json:"_links,omitempty"`
		Results *[]CommentVersion `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetInlineCommentVersionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInlineCommentVersionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInlineCommentVersionDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DetailedVersion
}

// Status returns HTTPResponse.Status
func (r GetInlineCommentVersionDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInlineCommentVersionDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLabelsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Links   *MultiEntityLinks `json:"_links,omitempty"`
		Results *[]Label          `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetLabelsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLabelsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLabelAttachmentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Links   *MultiEntityLinks `json:"_links,omitempty"`
		Results *[]AttachmentBulk `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetLabelAttachmentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLabelAttachmentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLabelBlogPostsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Links   *MultiEntityLinks `json:"_links,omitempty"`
		Results *[]BlogPostBulk   `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetLabelBlogPostsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLabelBlogPostsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLabelPagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Links   *MultiEntityLinks `json:"_links,omitempty"`
		Results *[]PageBulk       `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetLabelPagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLabelPagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Links   *MultiEntityLinks `json:"_links,omitempty"`
		Results *[]PageBulk       `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetPagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Links *struct {
			// Base Base url of the Confluence site.
			Base *string `json:"base,omitempty"`
		} `json:"_links,omitempty"`

		// AuthorId The account ID of the user who created this page originally.
		AuthorId *string `json:"authorId,omitempty"`

		// Body Contains fields for each representation type requested.
		Body *BodySingle `json:"body,omitempty"`

		// CreatedAt Date and time when the page was created. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
		CreatedAt *time.Time `json:"createdAt,omitempty"`

		// Id ID of the page.
		Id *string `json:"id,omitempty"`

		// IsFavoritedByCurrentUser Whether the page has been favorited by the current user.
		IsFavoritedByCurrentUser *bool `json:"isFavoritedByCurrentUser,omitempty"`
		Labels                   *struct {
			Links   *OptionalFieldLinks `json:"_links,omitempty"`
			Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
			Results *[]Label            `json:"results,omitempty"`
		} `json:"labels,omitempty"`

		// LastOwnerId The account ID of the user who owned this page previously, or null if there is no previous owner.
		LastOwnerId *string `json:"lastOwnerId"`
		Likes       *struct {
			Links   *OptionalFieldLinks `json:"_links,omitempty"`
			Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
			Results *[]Like             `json:"results,omitempty"`
		} `json:"likes,omitempty"`
		Operations *struct {
			Links   *OptionalFieldLinks `json:"_links,omitempty"`
			Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
			Results *[]Operation        `json:"results,omitempty"`
		} `json:"operations,omitempty"`

		// OwnerId The account ID of the user who owns this page.
		OwnerId *string `json:"ownerId"`

		// ParentId ID of the parent page, or null if there is no parent page.
		ParentId *string `json:"parentId,omitempty"`

		// ParentType Content type of the parent, or null if there is no parent.
		ParentType *ParentContentType `json:"parentType,omitempty"`

		// Position Position of child page within the given parent page tree.
		Position   *int32 `json:"position"`
		Properties *struct {
			Links   *OptionalFieldLinks `json:"_links,omitempty"`
			Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
			Results *[]ContentProperty  `json:"results,omitempty"`
		} `json:"properties,omitempty"`

		// SpaceId ID of the space the page is in.
		SpaceId *string `json:"spaceId,omitempty"`

		// Status The status of the content.
		Status *ContentStatus `json:"status,omitempty"`

		// Title Title of the page.
		Title    *string  `json:"title,omitempty"`
		Version  *Version `json:"version,omitempty"`
		Versions *struct {
			Links   *OptionalFieldLinks `json:"_links,omitempty"`
			Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
			Results *[]Version          `json:"results,omitempty"`
		} `json:"versions,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreatePageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeletePageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPageByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Links *struct {
			// Base Base url of the Confluence site.
			Base *string `json:"base,omitempty"`
		} `json:"_links,omitempty"`

		// AuthorId The account ID of the user who created this page originally.
		AuthorId *string `json:"authorId,omitempty"`

		// Body Contains fields for each representation type requested.
		Body *BodySingle `json:"body,omitempty"`

		// CreatedAt Date and time when the page was created. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
		CreatedAt *time.Time `json:"createdAt,omitempty"`

		// Id ID of the page.
		Id *string `json:"id,omitempty"`

		// IsFavoritedByCurrentUser Whether the page has been favorited by the current user.
		IsFavoritedByCurrentUser *bool `json:"isFavoritedByCurrentUser,omitempty"`
		Labels                   *struct {
			Links   *OptionalFieldLinks `json:"_links,omitempty"`
			Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
			Results *[]Label            `json:"results,omitempty"`
		} `json:"labels,omitempty"`

		// LastOwnerId The account ID of the user who owned this page previously, or null if there is no previous owner.
		LastOwnerId *string `json:"lastOwnerId"`
		Likes       *struct {
			Links   *OptionalFieldLinks `json:"_links,omitempty"`
			Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
			Results *[]Like             `json:"results,omitempty"`
		} `json:"likes,omitempty"`
		Operations *struct {
			Links   *OptionalFieldLinks `json:"_links,omitempty"`
			Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
			Results *[]Operation        `json:"results,omitempty"`
		} `json:"operations,omitempty"`

		// OwnerId The account ID of the user who owns this page.
		OwnerId *string `json:"ownerId"`

		// ParentId ID of the parent page, or null if there is no parent page.
		ParentId *string `json:"parentId,omitempty"`

		// ParentType Content type of the parent, or null if there is no parent.
		ParentType *ParentContentType `json:"parentType,omitempty"`

		// Position Position of child page within the given parent page tree.
		Position   *int32 `json:"position"`
		Properties *struct {
			Links   *OptionalFieldLinks `json:"_links,omitempty"`
			Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
			Results *[]ContentProperty  `json:"results,omitempty"`
		} `json:"properties,omitempty"`

		// SpaceId ID of the space the page is in.
		SpaceId *string `json:"spaceId,omitempty"`

		// Status The status of the content.
		Status *ContentStatus `json:"status,omitempty"`

		// Title Title of the page.
		Title    *string  `json:"title,omitempty"`
		Version  *Version `json:"version,omitempty"`
		Versions *struct {
			Links   *OptionalFieldLinks `json:"_links,omitempty"`
			Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
			Results *[]Version          `json:"results,omitempty"`
		} `json:"versions,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetPageByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPageByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Links *struct {
			// Base Base url of the Confluence site.
			Base *string `json:"base,omitempty"`
		} `json:"_links,omitempty"`

		// AuthorId The account ID of the user who created this page originally.
		AuthorId *string `json:"authorId,omitempty"`

		// Body Contains fields for each representation type requested.
		Body *BodySingle `json:"body,omitempty"`

		// CreatedAt Date and time when the page was created. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
		CreatedAt *time.Time `json:"createdAt,omitempty"`

		// Id ID of the page.
		Id *string `json:"id,omitempty"`

		// IsFavoritedByCurrentUser Whether the page has been favorited by the current user.
		IsFavoritedByCurrentUser *bool `json:"isFavoritedByCurrentUser,omitempty"`
		Labels                   *struct {
			Links   *OptionalFieldLinks `json:"_links,omitempty"`
			Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
			Results *[]Label            `json:"results,omitempty"`
		} `json:"labels,omitempty"`

		// LastOwnerId The account ID of the user who owned this page previously, or null if there is no previous owner.
		LastOwnerId *string `json:"lastOwnerId"`
		Likes       *struct {
			Links   *OptionalFieldLinks `json:"_links,omitempty"`
			Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
			Results *[]Like             `json:"results,omitempty"`
		} `json:"likes,omitempty"`
		Operations *struct {
			Links   *OptionalFieldLinks `json:"_links,omitempty"`
			Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
			Results *[]Operation        `json:"results,omitempty"`
		} `json:"operations,omitempty"`

		// OwnerId The account ID of the user who owns this page.
		OwnerId *string `json:"ownerId"`

		// ParentId ID of the parent page, or null if there is no parent page.
		ParentId *string `json:"parentId,omitempty"`

		// ParentType Content type of the parent, or null if there is no parent.
		ParentType *ParentContentType `json:"parentType,omitempty"`

		// Position Position of child page within the given parent page tree.
		Position   *int32 `json:"position"`
		Properties *struct {
			Links   *OptionalFieldLinks `json:"_links,omitempty"`
			Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
			Results *[]ContentProperty  `json:"results,omitempty"`
		} `json:"properties,omitempty"`

		// SpaceId ID of the space the page is in.
		SpaceId *string `json:"spaceId,omitempty"`

		// Status The status of the content.
		Status *ContentStatus `json:"status,omitempty"`

		// Title Title of the page.
		Title    *string  `json:"title,omitempty"`
		Version  *Version `json:"version,omitempty"`
		Versions *struct {
			Links   *OptionalFieldLinks `json:"_links,omitempty"`
			Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
			Results *[]Version          `json:"results,omitempty"`
		} `json:"versions,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdatePageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPageAncestorsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Links   *MultiEntityLinks `json:"_links,omitempty"`
		Results *[]Ancestor       `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetPageAncestorsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPageAncestorsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPageAttachmentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Links   *MultiEntityLinks `json:"_links,omitempty"`
		Results *[]AttachmentBulk `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetPageAttachmentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPageAttachmentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetChildPagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Links   *MultiEntityLinks `json:"_links,omitempty"`
		Results *[]ChildPage      `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetChildPagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetChildPagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPageClassificationLevelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ClassificationLevel
}

// Status returns HTTPResponse.Status
func (r GetPageClassificationLevelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPageClassificationLevelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutPageClassificationLevelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PutPageClassificationLevelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutPageClassificationLevelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostPageClassificationLevelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PostPageClassificationLevelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostPageClassificationLevelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCustomContentByTypeInPageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Links   *MultiEntityLinks    `json:"_links,omitempty"`
		Results *[]CustomContentBulk `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetCustomContentByTypeInPageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCustomContentByTypeInPageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPageFooterCommentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Links   *MultiEntityLinks   `json:"_links,omitempty"`
		Results *[]PageCommentModel `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetPageFooterCommentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPageFooterCommentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPageInlineCommentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Links   *MultiEntityLinks         `json:"_links,omitempty"`
		Results *[]PageInlineCommentModel `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetPageInlineCommentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPageInlineCommentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPageLabelsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Links   *MultiEntityLinks `json:"_links,omitempty"`
		Results *[]Label          `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetPageLabelsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPageLabelsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPageLikeCountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count The count number
		Count *int64 `json:"count,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetPageLikeCountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPageLikeCountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPageLikeUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Links   *MultiEntityLinks `json:"_links,omitempty"`
		Results *[]Like           `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetPageLikeUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPageLikeUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPageOperationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PermittedOperationsResponse
}

// Status returns HTTPResponse.Status
func (r GetPageOperationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPageOperationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPageVersionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Links   *MultiEntityLinks `json:"_links,omitempty"`
		Results *[]PageVersion    `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetPageVersionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPageVersionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPageContentPropertiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Links   *MultiEntityLinks  `json:"_links,omitempty"`
		Results *[]ContentProperty `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetPageContentPropertiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPageContentPropertiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePagePropertyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ContentProperty
}

// Status returns HTTPResponse.Status
func (r CreatePagePropertyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePagePropertyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePagePropertyByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeletePagePropertyByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePagePropertyByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPageContentPropertiesByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ContentProperty
}

// Status returns HTTPResponse.Status
func (r GetPageContentPropertiesByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPageContentPropertiesByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePagePropertyByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ContentProperty
}

// Status returns HTTPResponse.Status
func (r UpdatePagePropertyByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePagePropertyByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPageVersionDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DetailedVersion
}

// Status returns HTTPResponse.Status
func (r GetPageVersionDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPageVersionDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSpacesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Links   *MultiEntityLinks `json:"_links,omitempty"`
		Results *[]SpaceBulk      `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetSpacesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSpacesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSpaceByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Links *struct {
			// Base Base url of the Confluence site.
			Base *string `json:"base,omitempty"`
		} `json:"_links,omitempty"`

		// AuthorId The account ID of the user who created this space originally.
		AuthorId *string `json:"authorId,omitempty"`

		// CreatedAt Date and time when the space was created. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
		CreatedAt *time.Time `json:"createdAt,omitempty"`

		// Description Contains fields for each representation type requested.
		Description *SpaceDescription `json:"description,omitempty"`

		// HomepageId ID of the space's homepage.
		HomepageId *string `json:"homepageId,omitempty"`

		// Icon The icon of the space
		Icon *SpaceIcon `json:"icon,omitempty"`

		// Id ID of the space.
		Id *string `json:"id,omitempty"`

		// Key Key of the space.
		Key    *string `json:"key,omitempty"`
		Labels *struct {
			Links   *OptionalFieldLinks `json:"_links,omitempty"`
			Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
			Results *[]Label            `json:"results,omitempty"`
		} `json:"labels,omitempty"`

		// Name Name of the space.
		Name       *string `json:"name,omitempty"`
		Operations *struct {
			Links   *OptionalFieldLinks `json:"_links,omitempty"`
			Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
			Results *[]Operation        `json:"results,omitempty"`
		} `json:"operations,omitempty"`
		Permissions *struct {
			Links   *OptionalFieldLinks `json:"_links,omitempty"`
			Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
			Results *[]SpacePermission  `json:"results,omitempty"`
		} `json:"permissions,omitempty"`
		Properties *struct {
			Links   *OptionalFieldLinks `json:"_links,omitempty"`
			Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
			Results *[]SpaceProperty    `json:"results,omitempty"`
		} `json:"properties,omitempty"`

		// Status The status of the space.
		Status *SpaceStatus `json:"status,omitempty"`

		// Type The type of space.
		Type *SpaceType `json:"type,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetSpaceByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSpaceByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBlogPostsInSpaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Links   *MultiEntityLinks `json:"_links,omitempty"`
		Results *[]BlogPostBulk   `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetBlogPostsInSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBlogPostsInSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSpaceDefaultClassificationLevelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteSpaceDefaultClassificationLevelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSpaceDefaultClassificationLevelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSpaceDefaultClassificationLevelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ClassificationLevel
}

// Status returns HTTPResponse.Status
func (r GetSpaceDefaultClassificationLevelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSpaceDefaultClassificationLevelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutSpaceDefaultClassificationLevelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PutSpaceDefaultClassificationLevelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutSpaceDefaultClassificationLevelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSpaceContentLabelsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Links   *MultiEntityLinks `json:"_links,omitempty"`
		Results *[]Label          `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetSpaceContentLabelsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSpaceContentLabelsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCustomContentByTypeInSpaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Links   *MultiEntityLinks    `json:"_links,omitempty"`
		Results *[]CustomContentBulk `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetCustomContentByTypeInSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCustomContentByTypeInSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSpaceLabelsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Links   *MultiEntityLinks `json:"_links,omitempty"`
		Results *[]Label          `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetSpaceLabelsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSpaceLabelsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSpaceOperationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PermittedOperationsResponse
}

// Status returns HTTPResponse.Status
func (r GetSpaceOperationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSpaceOperationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPagesInSpaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Links   *MultiEntityLinks `json:"_links,omitempty"`
		Results *[]PageBulk       `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetPagesInSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPagesInSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSpacePermissionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Links   *MultiEntityLinks  `json:"_links,omitempty"`
		Results *[]SpacePermission `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetSpacePermissionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSpacePermissionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSpacePropertiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Links   *MultiEntityLinks `json:"_links,omitempty"`
		Results *[]SpaceProperty  `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetSpacePropertiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSpacePropertiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSpacePropertyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SpaceProperty
}

// Status returns HTTPResponse.Status
func (r CreateSpacePropertyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSpacePropertyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSpacePropertyByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteSpacePropertyByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSpacePropertyByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSpacePropertyByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SpaceProperty
}

// Status returns HTTPResponse.Status
func (r GetSpacePropertyByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSpacePropertyByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateSpacePropertyByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SpaceProperty
}

// Status returns HTTPResponse.Status
func (r UpdateSpacePropertyByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSpacePropertyByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTasksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Links   *MultiEntityLinks `json:"_links,omitempty"`
		Results *[]Task           `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetTasksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTasksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTaskByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Task
}

// Status returns HTTPResponse.Status
func (r GetTaskByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTaskByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateTaskResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Task
}

// Status returns HTTPResponse.Status
func (r UpdateTaskResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateTaskResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CheckAccessByEmailResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// EmailsWithoutAccess List of emails that do not have access to site.
		EmailsWithoutAccess *[]string `json:"emailsWithoutAccess,omitempty"`

		// InvalidEmails List of invalid emails provided in the request.
		InvalidEmails *[]string `json:"invalidEmails,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CheckAccessByEmailResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CheckAccessByEmailResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InviteByEmailResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r InviteByEmailResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InviteByEmailResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBulkUserLookupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Links   *MultiEntityLinks `json:"_links,omitempty"`
		Results *[]User           `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateBulkUserLookupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBulkUserLookupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateWhiteboardResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Links *struct {
			// Base Base url of the Confluence site.
			Base *string `json:"base,omitempty"`
		} `json:"_links,omitempty"`

		// AuthorId The account ID of the user who created this whiteboard originally.
		AuthorId *string `json:"authorId,omitempty"`

		// CreatedAt Date and time when the whiteboard was created. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
		CreatedAt *time.Time `json:"createdAt,omitempty"`

		// Id ID of the whiteboard.
		Id *string `json:"id,omitempty"`

		// OwnerId The account ID of the user who owns this whiteboard.
		OwnerId *string `json:"ownerId,omitempty"`

		// ParentId ID of the parent content, or null if there is no parent content.
		ParentId *string `json:"parentId,omitempty"`

		// ParentType Content type of the parent, or null if there is no parent.
		ParentType *ParentContentType `json:"parentType,omitempty"`

		// Position Position of the whiteboard within the given parent page tree.
		Position *int32 `json:"position"`

		// Status The status of the content.
		Status *ContentStatus `json:"status,omitempty"`

		// Title Title of the whiteboard.
		Title *string `json:"title,omitempty"`

		// Type The content type of the object.
		Type    *string  `json:"type,omitempty"`
		Version *Version `json:"version,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateWhiteboardResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateWhiteboardResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteWhiteboardResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteWhiteboardResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteWhiteboardResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWhiteboardByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Links *struct {
			// Base Base url of the Confluence site.
			Base *string `json:"base,omitempty"`
		} `json:"_links,omitempty"`

		// AuthorId The account ID of the user who created this whiteboard originally.
		AuthorId *string `json:"authorId,omitempty"`

		// CreatedAt Date and time when the whiteboard was created. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
		CreatedAt *time.Time `json:"createdAt,omitempty"`

		// Id ID of the whiteboard.
		Id *string `json:"id,omitempty"`

		// OwnerId The account ID of the user who owns this whiteboard.
		OwnerId *string `json:"ownerId,omitempty"`

		// ParentId ID of the parent content, or null if there is no parent content.
		ParentId *string `json:"parentId,omitempty"`

		// ParentType Content type of the parent, or null if there is no parent.
		ParentType *ParentContentType `json:"parentType,omitempty"`

		// Position Position of the whiteboard within the given parent page tree.
		Position *int32 `json:"position"`

		// Status The status of the content.
		Status *ContentStatus `json:"status,omitempty"`

		// Title Title of the whiteboard.
		Title *string `json:"title,omitempty"`

		// Type The content type of the object.
		Type    *string  `json:"type,omitempty"`
		Version *Version `json:"version,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetWhiteboardByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWhiteboardByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWhiteboardAncestorsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Results *[]Ancestor `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetWhiteboardAncestorsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWhiteboardAncestorsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWhiteboardClassificationLevelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ClassificationLevel
}

// Status returns HTTPResponse.Status
func (r GetWhiteboardClassificationLevelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWhiteboardClassificationLevelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutWhiteboardClassificationLevelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PutWhiteboardClassificationLevelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutWhiteboardClassificationLevelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostWhiteboardClassificationLevelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PostWhiteboardClassificationLevelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostWhiteboardClassificationLevelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWhiteboardOperationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PermittedOperationsResponse
}

// Status returns HTTPResponse.Status
func (r GetWhiteboardOperationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWhiteboardOperationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWhiteboardContentPropertiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Links   *MultiEntityLinks  `json:"_links,omitempty"`
		Results *[]ContentProperty `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetWhiteboardContentPropertiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWhiteboardContentPropertiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateWhiteboardPropertyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ContentProperty
}

// Status returns HTTPResponse.Status
func (r CreateWhiteboardPropertyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateWhiteboardPropertyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteWhiteboardPropertyByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteWhiteboardPropertyByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteWhiteboardPropertyByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWhiteboardContentPropertiesByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ContentProperty
}

// Status returns HTTPResponse.Status
func (r GetWhiteboardContentPropertiesByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWhiteboardContentPropertiesByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateWhiteboardPropertyByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ContentProperty
}

// Status returns HTTPResponse.Status
func (r UpdateWhiteboardPropertyByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateWhiteboardPropertyByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetAttachmentsWithResponse request returning *GetAttachmentsResponse
func (c *ClientWithResponses) GetAttachmentsWithResponse(ctx context.Context, params *GetAttachmentsParams, reqEditors ...RequestEditorFn) (*GetAttachmentsResponse, error) {
	rsp, err := c.GetAttachments(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAttachmentsResponse(rsp)
}

// GetAttachmentContentPropertiesWithResponse request returning *GetAttachmentContentPropertiesResponse
func (c *ClientWithResponses) GetAttachmentContentPropertiesWithResponse(ctx context.Context, attachmentId string, params *GetAttachmentContentPropertiesParams, reqEditors ...RequestEditorFn) (*GetAttachmentContentPropertiesResponse, error) {
	rsp, err := c.GetAttachmentContentProperties(ctx, attachmentId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAttachmentContentPropertiesResponse(rsp)
}

// CreateAttachmentPropertyWithBodyWithResponse request with arbitrary body returning *CreateAttachmentPropertyResponse
func (c *ClientWithResponses) CreateAttachmentPropertyWithBodyWithResponse(ctx context.Context, attachmentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAttachmentPropertyResponse, error) {
	rsp, err := c.CreateAttachmentPropertyWithBody(ctx, attachmentId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAttachmentPropertyResponse(rsp)
}

func (c *ClientWithResponses) CreateAttachmentPropertyWithResponse(ctx context.Context, attachmentId string, body CreateAttachmentPropertyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAttachmentPropertyResponse, error) {
	rsp, err := c.CreateAttachmentProperty(ctx, attachmentId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAttachmentPropertyResponse(rsp)
}

// DeleteAttachmentPropertyByIdWithResponse request returning *DeleteAttachmentPropertyByIdResponse
func (c *ClientWithResponses) DeleteAttachmentPropertyByIdWithResponse(ctx context.Context, attachmentId string, propertyId int64, reqEditors ...RequestEditorFn) (*DeleteAttachmentPropertyByIdResponse, error) {
	rsp, err := c.DeleteAttachmentPropertyById(ctx, attachmentId, propertyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAttachmentPropertyByIdResponse(rsp)
}

// GetAttachmentContentPropertiesByIdWithResponse request returning *GetAttachmentContentPropertiesByIdResponse
func (c *ClientWithResponses) GetAttachmentContentPropertiesByIdWithResponse(ctx context.Context, attachmentId string, propertyId int64, reqEditors ...RequestEditorFn) (*GetAttachmentContentPropertiesByIdResponse, error) {
	rsp, err := c.GetAttachmentContentPropertiesById(ctx, attachmentId, propertyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAttachmentContentPropertiesByIdResponse(rsp)
}

// UpdateAttachmentPropertyByIdWithBodyWithResponse request with arbitrary body returning *UpdateAttachmentPropertyByIdResponse
func (c *ClientWithResponses) UpdateAttachmentPropertyByIdWithBodyWithResponse(ctx context.Context, attachmentId string, propertyId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAttachmentPropertyByIdResponse, error) {
	rsp, err := c.UpdateAttachmentPropertyByIdWithBody(ctx, attachmentId, propertyId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAttachmentPropertyByIdResponse(rsp)
}

func (c *ClientWithResponses) UpdateAttachmentPropertyByIdWithResponse(ctx context.Context, attachmentId string, propertyId int64, body UpdateAttachmentPropertyByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAttachmentPropertyByIdResponse, error) {
	rsp, err := c.UpdateAttachmentPropertyById(ctx, attachmentId, propertyId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAttachmentPropertyByIdResponse(rsp)
}

// GetAttachmentVersionDetailsWithResponse request returning *GetAttachmentVersionDetailsResponse
func (c *ClientWithResponses) GetAttachmentVersionDetailsWithResponse(ctx context.Context, attachmentId string, versionNumber int64, reqEditors ...RequestEditorFn) (*GetAttachmentVersionDetailsResponse, error) {
	rsp, err := c.GetAttachmentVersionDetails(ctx, attachmentId, versionNumber, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAttachmentVersionDetailsResponse(rsp)
}

// DeleteAttachmentWithResponse request returning *DeleteAttachmentResponse
func (c *ClientWithResponses) DeleteAttachmentWithResponse(ctx context.Context, id int64, params *DeleteAttachmentParams, reqEditors ...RequestEditorFn) (*DeleteAttachmentResponse, error) {
	rsp, err := c.DeleteAttachment(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAttachmentResponse(rsp)
}

// GetAttachmentByIdWithResponse request returning *GetAttachmentByIdResponse
func (c *ClientWithResponses) GetAttachmentByIdWithResponse(ctx context.Context, id string, params *GetAttachmentByIdParams, reqEditors ...RequestEditorFn) (*GetAttachmentByIdResponse, error) {
	rsp, err := c.GetAttachmentById(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAttachmentByIdResponse(rsp)
}

// GetAttachmentCommentsWithResponse request returning *GetAttachmentCommentsResponse
func (c *ClientWithResponses) GetAttachmentCommentsWithResponse(ctx context.Context, id string, params *GetAttachmentCommentsParams, reqEditors ...RequestEditorFn) (*GetAttachmentCommentsResponse, error) {
	rsp, err := c.GetAttachmentComments(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAttachmentCommentsResponse(rsp)
}

// GetAttachmentLabelsWithResponse request returning *GetAttachmentLabelsResponse
func (c *ClientWithResponses) GetAttachmentLabelsWithResponse(ctx context.Context, id int64, params *GetAttachmentLabelsParams, reqEditors ...RequestEditorFn) (*GetAttachmentLabelsResponse, error) {
	rsp, err := c.GetAttachmentLabels(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAttachmentLabelsResponse(rsp)
}

// GetAttachmentOperationsWithResponse request returning *GetAttachmentOperationsResponse
func (c *ClientWithResponses) GetAttachmentOperationsWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetAttachmentOperationsResponse, error) {
	rsp, err := c.GetAttachmentOperations(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAttachmentOperationsResponse(rsp)
}

// GetAttachmentVersionsWithResponse request returning *GetAttachmentVersionsResponse
func (c *ClientWithResponses) GetAttachmentVersionsWithResponse(ctx context.Context, id string, params *GetAttachmentVersionsParams, reqEditors ...RequestEditorFn) (*GetAttachmentVersionsResponse, error) {
	rsp, err := c.GetAttachmentVersions(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAttachmentVersionsResponse(rsp)
}

// GetBlogPostsWithResponse request returning *GetBlogPostsResponse
func (c *ClientWithResponses) GetBlogPostsWithResponse(ctx context.Context, params *GetBlogPostsParams, reqEditors ...RequestEditorFn) (*GetBlogPostsResponse, error) {
	rsp, err := c.GetBlogPosts(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBlogPostsResponse(rsp)
}

// CreateBlogPostWithBodyWithResponse request with arbitrary body returning *CreateBlogPostResponse
func (c *ClientWithResponses) CreateBlogPostWithBodyWithResponse(ctx context.Context, params *CreateBlogPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBlogPostResponse, error) {
	rsp, err := c.CreateBlogPostWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBlogPostResponse(rsp)
}

func (c *ClientWithResponses) CreateBlogPostWithResponse(ctx context.Context, params *CreateBlogPostParams, body CreateBlogPostJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBlogPostResponse, error) {
	rsp, err := c.CreateBlogPost(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBlogPostResponse(rsp)
}

// GetBlogpostContentPropertiesWithResponse request returning *GetBlogpostContentPropertiesResponse
func (c *ClientWithResponses) GetBlogpostContentPropertiesWithResponse(ctx context.Context, blogpostId int64, params *GetBlogpostContentPropertiesParams, reqEditors ...RequestEditorFn) (*GetBlogpostContentPropertiesResponse, error) {
	rsp, err := c.GetBlogpostContentProperties(ctx, blogpostId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBlogpostContentPropertiesResponse(rsp)
}

// CreateBlogpostPropertyWithBodyWithResponse request with arbitrary body returning *CreateBlogpostPropertyResponse
func (c *ClientWithResponses) CreateBlogpostPropertyWithBodyWithResponse(ctx context.Context, blogpostId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBlogpostPropertyResponse, error) {
	rsp, err := c.CreateBlogpostPropertyWithBody(ctx, blogpostId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBlogpostPropertyResponse(rsp)
}

func (c *ClientWithResponses) CreateBlogpostPropertyWithResponse(ctx context.Context, blogpostId int64, body CreateBlogpostPropertyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBlogpostPropertyResponse, error) {
	rsp, err := c.CreateBlogpostProperty(ctx, blogpostId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBlogpostPropertyResponse(rsp)
}

// DeleteBlogpostPropertyByIdWithResponse request returning *DeleteBlogpostPropertyByIdResponse
func (c *ClientWithResponses) DeleteBlogpostPropertyByIdWithResponse(ctx context.Context, blogpostId int64, propertyId int64, reqEditors ...RequestEditorFn) (*DeleteBlogpostPropertyByIdResponse, error) {
	rsp, err := c.DeleteBlogpostPropertyById(ctx, blogpostId, propertyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteBlogpostPropertyByIdResponse(rsp)
}

// GetBlogpostContentPropertiesByIdWithResponse request returning *GetBlogpostContentPropertiesByIdResponse
func (c *ClientWithResponses) GetBlogpostContentPropertiesByIdWithResponse(ctx context.Context, blogpostId int64, propertyId int64, reqEditors ...RequestEditorFn) (*GetBlogpostContentPropertiesByIdResponse, error) {
	rsp, err := c.GetBlogpostContentPropertiesById(ctx, blogpostId, propertyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBlogpostContentPropertiesByIdResponse(rsp)
}

// UpdateBlogpostPropertyByIdWithBodyWithResponse request with arbitrary body returning *UpdateBlogpostPropertyByIdResponse
func (c *ClientWithResponses) UpdateBlogpostPropertyByIdWithBodyWithResponse(ctx context.Context, blogpostId int64, propertyId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateBlogpostPropertyByIdResponse, error) {
	rsp, err := c.UpdateBlogpostPropertyByIdWithBody(ctx, blogpostId, propertyId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateBlogpostPropertyByIdResponse(rsp)
}

func (c *ClientWithResponses) UpdateBlogpostPropertyByIdWithResponse(ctx context.Context, blogpostId int64, propertyId int64, body UpdateBlogpostPropertyByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateBlogpostPropertyByIdResponse, error) {
	rsp, err := c.UpdateBlogpostPropertyById(ctx, blogpostId, propertyId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateBlogpostPropertyByIdResponse(rsp)
}

// GetBlogPostVersionDetailsWithResponse request returning *GetBlogPostVersionDetailsResponse
func (c *ClientWithResponses) GetBlogPostVersionDetailsWithResponse(ctx context.Context, blogpostId int64, versionNumber int64, reqEditors ...RequestEditorFn) (*GetBlogPostVersionDetailsResponse, error) {
	rsp, err := c.GetBlogPostVersionDetails(ctx, blogpostId, versionNumber, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBlogPostVersionDetailsResponse(rsp)
}

// DeleteBlogPostWithResponse request returning *DeleteBlogPostResponse
func (c *ClientWithResponses) DeleteBlogPostWithResponse(ctx context.Context, id int64, params *DeleteBlogPostParams, reqEditors ...RequestEditorFn) (*DeleteBlogPostResponse, error) {
	rsp, err := c.DeleteBlogPost(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteBlogPostResponse(rsp)
}

// GetBlogPostByIdWithResponse request returning *GetBlogPostByIdResponse
func (c *ClientWithResponses) GetBlogPostByIdWithResponse(ctx context.Context, id int64, params *GetBlogPostByIdParams, reqEditors ...RequestEditorFn) (*GetBlogPostByIdResponse, error) {
	rsp, err := c.GetBlogPostById(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBlogPostByIdResponse(rsp)
}

// UpdateBlogPostWithBodyWithResponse request with arbitrary body returning *UpdateBlogPostResponse
func (c *ClientWithResponses) UpdateBlogPostWithBodyWithResponse(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateBlogPostResponse, error) {
	rsp, err := c.UpdateBlogPostWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateBlogPostResponse(rsp)
}

func (c *ClientWithResponses) UpdateBlogPostWithResponse(ctx context.Context, id int64, body UpdateBlogPostJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateBlogPostResponse, error) {
	rsp, err := c.UpdateBlogPost(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateBlogPostResponse(rsp)
}

// GetBlogpostAttachmentsWithResponse request returning *GetBlogpostAttachmentsResponse
func (c *ClientWithResponses) GetBlogpostAttachmentsWithResponse(ctx context.Context, id int64, params *GetBlogpostAttachmentsParams, reqEditors ...RequestEditorFn) (*GetBlogpostAttachmentsResponse, error) {
	rsp, err := c.GetBlogpostAttachments(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBlogpostAttachmentsResponse(rsp)
}

// GetBlogPostClassificationLevelWithResponse request returning *GetBlogPostClassificationLevelResponse
func (c *ClientWithResponses) GetBlogPostClassificationLevelWithResponse(ctx context.Context, id int64, params *GetBlogPostClassificationLevelParams, reqEditors ...RequestEditorFn) (*GetBlogPostClassificationLevelResponse, error) {
	rsp, err := c.GetBlogPostClassificationLevel(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBlogPostClassificationLevelResponse(rsp)
}

// PutBlogPostClassificationLevelWithBodyWithResponse request with arbitrary body returning *PutBlogPostClassificationLevelResponse
func (c *ClientWithResponses) PutBlogPostClassificationLevelWithBodyWithResponse(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutBlogPostClassificationLevelResponse, error) {
	rsp, err := c.PutBlogPostClassificationLevelWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutBlogPostClassificationLevelResponse(rsp)
}

func (c *ClientWithResponses) PutBlogPostClassificationLevelWithResponse(ctx context.Context, id int64, body PutBlogPostClassificationLevelJSONRequestBody, reqEditors ...RequestEditorFn) (*PutBlogPostClassificationLevelResponse, error) {
	rsp, err := c.PutBlogPostClassificationLevel(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutBlogPostClassificationLevelResponse(rsp)
}

// PostBlogPostClassificationLevelWithBodyWithResponse request with arbitrary body returning *PostBlogPostClassificationLevelResponse
func (c *ClientWithResponses) PostBlogPostClassificationLevelWithBodyWithResponse(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostBlogPostClassificationLevelResponse, error) {
	rsp, err := c.PostBlogPostClassificationLevelWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostBlogPostClassificationLevelResponse(rsp)
}

func (c *ClientWithResponses) PostBlogPostClassificationLevelWithResponse(ctx context.Context, id int64, body PostBlogPostClassificationLevelJSONRequestBody, reqEditors ...RequestEditorFn) (*PostBlogPostClassificationLevelResponse, error) {
	rsp, err := c.PostBlogPostClassificationLevel(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostBlogPostClassificationLevelResponse(rsp)
}

// GetCustomContentByTypeInBlogPostWithResponse request returning *GetCustomContentByTypeInBlogPostResponse
func (c *ClientWithResponses) GetCustomContentByTypeInBlogPostWithResponse(ctx context.Context, id int64, params *GetCustomContentByTypeInBlogPostParams, reqEditors ...RequestEditorFn) (*GetCustomContentByTypeInBlogPostResponse, error) {
	rsp, err := c.GetCustomContentByTypeInBlogPost(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCustomContentByTypeInBlogPostResponse(rsp)
}

// GetBlogPostFooterCommentsWithResponse request returning *GetBlogPostFooterCommentsResponse
func (c *ClientWithResponses) GetBlogPostFooterCommentsWithResponse(ctx context.Context, id int64, params *GetBlogPostFooterCommentsParams, reqEditors ...RequestEditorFn) (*GetBlogPostFooterCommentsResponse, error) {
	rsp, err := c.GetBlogPostFooterComments(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBlogPostFooterCommentsResponse(rsp)
}

// GetBlogPostInlineCommentsWithResponse request returning *GetBlogPostInlineCommentsResponse
func (c *ClientWithResponses) GetBlogPostInlineCommentsWithResponse(ctx context.Context, id int64, params *GetBlogPostInlineCommentsParams, reqEditors ...RequestEditorFn) (*GetBlogPostInlineCommentsResponse, error) {
	rsp, err := c.GetBlogPostInlineComments(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBlogPostInlineCommentsResponse(rsp)
}

// GetBlogPostLabelsWithResponse request returning *GetBlogPostLabelsResponse
func (c *ClientWithResponses) GetBlogPostLabelsWithResponse(ctx context.Context, id int64, params *GetBlogPostLabelsParams, reqEditors ...RequestEditorFn) (*GetBlogPostLabelsResponse, error) {
	rsp, err := c.GetBlogPostLabels(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBlogPostLabelsResponse(rsp)
}

// GetBlogPostLikeCountWithResponse request returning *GetBlogPostLikeCountResponse
func (c *ClientWithResponses) GetBlogPostLikeCountWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetBlogPostLikeCountResponse, error) {
	rsp, err := c.GetBlogPostLikeCount(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBlogPostLikeCountResponse(rsp)
}

// GetBlogPostLikeUsersWithResponse request returning *GetBlogPostLikeUsersResponse
func (c *ClientWithResponses) GetBlogPostLikeUsersWithResponse(ctx context.Context, id int64, params *GetBlogPostLikeUsersParams, reqEditors ...RequestEditorFn) (*GetBlogPostLikeUsersResponse, error) {
	rsp, err := c.GetBlogPostLikeUsers(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBlogPostLikeUsersResponse(rsp)
}

// GetBlogPostOperationsWithResponse request returning *GetBlogPostOperationsResponse
func (c *ClientWithResponses) GetBlogPostOperationsWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetBlogPostOperationsResponse, error) {
	rsp, err := c.GetBlogPostOperations(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBlogPostOperationsResponse(rsp)
}

// GetBlogPostVersionsWithResponse request returning *GetBlogPostVersionsResponse
func (c *ClientWithResponses) GetBlogPostVersionsWithResponse(ctx context.Context, id int64, params *GetBlogPostVersionsParams, reqEditors ...RequestEditorFn) (*GetBlogPostVersionsResponse, error) {
	rsp, err := c.GetBlogPostVersions(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBlogPostVersionsResponse(rsp)
}

// GetClassificationLevelsWithResponse request returning *GetClassificationLevelsResponse
func (c *ClientWithResponses) GetClassificationLevelsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetClassificationLevelsResponse, error) {
	rsp, err := c.GetClassificationLevels(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClassificationLevelsResponse(rsp)
}

// GetCommentContentPropertiesWithResponse request returning *GetCommentContentPropertiesResponse
func (c *ClientWithResponses) GetCommentContentPropertiesWithResponse(ctx context.Context, commentId int64, params *GetCommentContentPropertiesParams, reqEditors ...RequestEditorFn) (*GetCommentContentPropertiesResponse, error) {
	rsp, err := c.GetCommentContentProperties(ctx, commentId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCommentContentPropertiesResponse(rsp)
}

// CreateCommentPropertyWithBodyWithResponse request with arbitrary body returning *CreateCommentPropertyResponse
func (c *ClientWithResponses) CreateCommentPropertyWithBodyWithResponse(ctx context.Context, commentId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCommentPropertyResponse, error) {
	rsp, err := c.CreateCommentPropertyWithBody(ctx, commentId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCommentPropertyResponse(rsp)
}

func (c *ClientWithResponses) CreateCommentPropertyWithResponse(ctx context.Context, commentId int64, body CreateCommentPropertyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCommentPropertyResponse, error) {
	rsp, err := c.CreateCommentProperty(ctx, commentId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCommentPropertyResponse(rsp)
}

// DeleteCommentPropertyByIdWithResponse request returning *DeleteCommentPropertyByIdResponse
func (c *ClientWithResponses) DeleteCommentPropertyByIdWithResponse(ctx context.Context, commentId int64, propertyId int64, reqEditors ...RequestEditorFn) (*DeleteCommentPropertyByIdResponse, error) {
	rsp, err := c.DeleteCommentPropertyById(ctx, commentId, propertyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCommentPropertyByIdResponse(rsp)
}

// GetCommentContentPropertiesByIdWithResponse request returning *GetCommentContentPropertiesByIdResponse
func (c *ClientWithResponses) GetCommentContentPropertiesByIdWithResponse(ctx context.Context, commentId int64, propertyId int64, reqEditors ...RequestEditorFn) (*GetCommentContentPropertiesByIdResponse, error) {
	rsp, err := c.GetCommentContentPropertiesById(ctx, commentId, propertyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCommentContentPropertiesByIdResponse(rsp)
}

// UpdateCommentPropertyByIdWithBodyWithResponse request with arbitrary body returning *UpdateCommentPropertyByIdResponse
func (c *ClientWithResponses) UpdateCommentPropertyByIdWithBodyWithResponse(ctx context.Context, commentId int64, propertyId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCommentPropertyByIdResponse, error) {
	rsp, err := c.UpdateCommentPropertyByIdWithBody(ctx, commentId, propertyId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCommentPropertyByIdResponse(rsp)
}

func (c *ClientWithResponses) UpdateCommentPropertyByIdWithResponse(ctx context.Context, commentId int64, propertyId int64, body UpdateCommentPropertyByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCommentPropertyByIdResponse, error) {
	rsp, err := c.UpdateCommentPropertyById(ctx, commentId, propertyId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCommentPropertyByIdResponse(rsp)
}

// ConvertContentIdsToContentTypesWithBodyWithResponse request with arbitrary body returning *ConvertContentIdsToContentTypesResponse
func (c *ClientWithResponses) ConvertContentIdsToContentTypesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConvertContentIdsToContentTypesResponse, error) {
	rsp, err := c.ConvertContentIdsToContentTypesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConvertContentIdsToContentTypesResponse(rsp)
}

func (c *ClientWithResponses) ConvertContentIdsToContentTypesWithResponse(ctx context.Context, body ConvertContentIdsToContentTypesJSONRequestBody, reqEditors ...RequestEditorFn) (*ConvertContentIdsToContentTypesResponse, error) {
	rsp, err := c.ConvertContentIdsToContentTypes(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConvertContentIdsToContentTypesResponse(rsp)
}

// GetCustomContentByTypeWithResponse request returning *GetCustomContentByTypeResponse
func (c *ClientWithResponses) GetCustomContentByTypeWithResponse(ctx context.Context, params *GetCustomContentByTypeParams, reqEditors ...RequestEditorFn) (*GetCustomContentByTypeResponse, error) {
	rsp, err := c.GetCustomContentByType(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCustomContentByTypeResponse(rsp)
}

// CreateCustomContentWithBodyWithResponse request with arbitrary body returning *CreateCustomContentResponse
func (c *ClientWithResponses) CreateCustomContentWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCustomContentResponse, error) {
	rsp, err := c.CreateCustomContentWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCustomContentResponse(rsp)
}

func (c *ClientWithResponses) CreateCustomContentWithResponse(ctx context.Context, body CreateCustomContentJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCustomContentResponse, error) {
	rsp, err := c.CreateCustomContent(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCustomContentResponse(rsp)
}

// GetCustomContentContentPropertiesWithResponse request returning *GetCustomContentContentPropertiesResponse
func (c *ClientWithResponses) GetCustomContentContentPropertiesWithResponse(ctx context.Context, customContentId int64, params *GetCustomContentContentPropertiesParams, reqEditors ...RequestEditorFn) (*GetCustomContentContentPropertiesResponse, error) {
	rsp, err := c.GetCustomContentContentProperties(ctx, customContentId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCustomContentContentPropertiesResponse(rsp)
}

// CreateCustomContentPropertyWithBodyWithResponse request with arbitrary body returning *CreateCustomContentPropertyResponse
func (c *ClientWithResponses) CreateCustomContentPropertyWithBodyWithResponse(ctx context.Context, customContentId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCustomContentPropertyResponse, error) {
	rsp, err := c.CreateCustomContentPropertyWithBody(ctx, customContentId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCustomContentPropertyResponse(rsp)
}

func (c *ClientWithResponses) CreateCustomContentPropertyWithResponse(ctx context.Context, customContentId int64, body CreateCustomContentPropertyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCustomContentPropertyResponse, error) {
	rsp, err := c.CreateCustomContentProperty(ctx, customContentId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCustomContentPropertyResponse(rsp)
}

// DeleteCustomContentPropertyByIdWithResponse request returning *DeleteCustomContentPropertyByIdResponse
func (c *ClientWithResponses) DeleteCustomContentPropertyByIdWithResponse(ctx context.Context, customContentId int64, propertyId int64, reqEditors ...RequestEditorFn) (*DeleteCustomContentPropertyByIdResponse, error) {
	rsp, err := c.DeleteCustomContentPropertyById(ctx, customContentId, propertyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCustomContentPropertyByIdResponse(rsp)
}

// GetCustomContentContentPropertiesByIdWithResponse request returning *GetCustomContentContentPropertiesByIdResponse
func (c *ClientWithResponses) GetCustomContentContentPropertiesByIdWithResponse(ctx context.Context, customContentId int64, propertyId int64, reqEditors ...RequestEditorFn) (*GetCustomContentContentPropertiesByIdResponse, error) {
	rsp, err := c.GetCustomContentContentPropertiesById(ctx, customContentId, propertyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCustomContentContentPropertiesByIdResponse(rsp)
}

// UpdateCustomContentPropertyByIdWithBodyWithResponse request with arbitrary body returning *UpdateCustomContentPropertyByIdResponse
func (c *ClientWithResponses) UpdateCustomContentPropertyByIdWithBodyWithResponse(ctx context.Context, customContentId int64, propertyId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCustomContentPropertyByIdResponse, error) {
	rsp, err := c.UpdateCustomContentPropertyByIdWithBody(ctx, customContentId, propertyId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCustomContentPropertyByIdResponse(rsp)
}

func (c *ClientWithResponses) UpdateCustomContentPropertyByIdWithResponse(ctx context.Context, customContentId int64, propertyId int64, body UpdateCustomContentPropertyByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCustomContentPropertyByIdResponse, error) {
	rsp, err := c.UpdateCustomContentPropertyById(ctx, customContentId, propertyId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCustomContentPropertyByIdResponse(rsp)
}

// GetCustomContentVersionsWithResponse request returning *GetCustomContentVersionsResponse
func (c *ClientWithResponses) GetCustomContentVersionsWithResponse(ctx context.Context, customContentId int64, params *GetCustomContentVersionsParams, reqEditors ...RequestEditorFn) (*GetCustomContentVersionsResponse, error) {
	rsp, err := c.GetCustomContentVersions(ctx, customContentId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCustomContentVersionsResponse(rsp)
}

// GetCustomContentVersionDetailsWithResponse request returning *GetCustomContentVersionDetailsResponse
func (c *ClientWithResponses) GetCustomContentVersionDetailsWithResponse(ctx context.Context, customContentId int64, versionNumber int64, reqEditors ...RequestEditorFn) (*GetCustomContentVersionDetailsResponse, error) {
	rsp, err := c.GetCustomContentVersionDetails(ctx, customContentId, versionNumber, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCustomContentVersionDetailsResponse(rsp)
}

// DeleteCustomContentWithResponse request returning *DeleteCustomContentResponse
func (c *ClientWithResponses) DeleteCustomContentWithResponse(ctx context.Context, id int64, params *DeleteCustomContentParams, reqEditors ...RequestEditorFn) (*DeleteCustomContentResponse, error) {
	rsp, err := c.DeleteCustomContent(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCustomContentResponse(rsp)
}

// GetCustomContentByIdWithResponse request returning *GetCustomContentByIdResponse
func (c *ClientWithResponses) GetCustomContentByIdWithResponse(ctx context.Context, id int64, params *GetCustomContentByIdParams, reqEditors ...RequestEditorFn) (*GetCustomContentByIdResponse, error) {
	rsp, err := c.GetCustomContentById(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCustomContentByIdResponse(rsp)
}

// UpdateCustomContentWithBodyWithResponse request with arbitrary body returning *UpdateCustomContentResponse
func (c *ClientWithResponses) UpdateCustomContentWithBodyWithResponse(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCustomContentResponse, error) {
	rsp, err := c.UpdateCustomContentWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCustomContentResponse(rsp)
}

func (c *ClientWithResponses) UpdateCustomContentWithResponse(ctx context.Context, id int64, body UpdateCustomContentJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCustomContentResponse, error) {
	rsp, err := c.UpdateCustomContent(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCustomContentResponse(rsp)
}

// GetCustomContentAttachmentsWithResponse request returning *GetCustomContentAttachmentsResponse
func (c *ClientWithResponses) GetCustomContentAttachmentsWithResponse(ctx context.Context, id int64, params *GetCustomContentAttachmentsParams, reqEditors ...RequestEditorFn) (*GetCustomContentAttachmentsResponse, error) {
	rsp, err := c.GetCustomContentAttachments(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCustomContentAttachmentsResponse(rsp)
}

// GetChildCustomContentWithResponse request returning *GetChildCustomContentResponse
func (c *ClientWithResponses) GetChildCustomContentWithResponse(ctx context.Context, id int64, params *GetChildCustomContentParams, reqEditors ...RequestEditorFn) (*GetChildCustomContentResponse, error) {
	rsp, err := c.GetChildCustomContent(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetChildCustomContentResponse(rsp)
}

// GetCustomContentCommentsWithResponse request returning *GetCustomContentCommentsResponse
func (c *ClientWithResponses) GetCustomContentCommentsWithResponse(ctx context.Context, id int64, params *GetCustomContentCommentsParams, reqEditors ...RequestEditorFn) (*GetCustomContentCommentsResponse, error) {
	rsp, err := c.GetCustomContentComments(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCustomContentCommentsResponse(rsp)
}

// GetCustomContentLabelsWithResponse request returning *GetCustomContentLabelsResponse
func (c *ClientWithResponses) GetCustomContentLabelsWithResponse(ctx context.Context, id int64, params *GetCustomContentLabelsParams, reqEditors ...RequestEditorFn) (*GetCustomContentLabelsResponse, error) {
	rsp, err := c.GetCustomContentLabels(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCustomContentLabelsResponse(rsp)
}

// GetCustomContentOperationsWithResponse request returning *GetCustomContentOperationsResponse
func (c *ClientWithResponses) GetCustomContentOperationsWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetCustomContentOperationsResponse, error) {
	rsp, err := c.GetCustomContentOperations(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCustomContentOperationsResponse(rsp)
}

// GetDataPolicyMetadataWithResponse request returning *GetDataPolicyMetadataResponse
func (c *ClientWithResponses) GetDataPolicyMetadataWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDataPolicyMetadataResponse, error) {
	rsp, err := c.GetDataPolicyMetadata(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDataPolicyMetadataResponse(rsp)
}

// GetDataPolicySpacesWithResponse request returning *GetDataPolicySpacesResponse
func (c *ClientWithResponses) GetDataPolicySpacesWithResponse(ctx context.Context, params *GetDataPolicySpacesParams, reqEditors ...RequestEditorFn) (*GetDataPolicySpacesResponse, error) {
	rsp, err := c.GetDataPolicySpaces(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDataPolicySpacesResponse(rsp)
}

// CreateDatabaseWithBodyWithResponse request with arbitrary body returning *CreateDatabaseResponse
func (c *ClientWithResponses) CreateDatabaseWithBodyWithResponse(ctx context.Context, params *CreateDatabaseParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDatabaseResponse, error) {
	rsp, err := c.CreateDatabaseWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDatabaseResponse(rsp)
}

func (c *ClientWithResponses) CreateDatabaseWithResponse(ctx context.Context, params *CreateDatabaseParams, body CreateDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDatabaseResponse, error) {
	rsp, err := c.CreateDatabase(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDatabaseResponse(rsp)
}

// DeleteDatabasePropertyByIdWithResponse request returning *DeleteDatabasePropertyByIdResponse
func (c *ClientWithResponses) DeleteDatabasePropertyByIdWithResponse(ctx context.Context, databaseId int64, propertyId int64, reqEditors ...RequestEditorFn) (*DeleteDatabasePropertyByIdResponse, error) {
	rsp, err := c.DeleteDatabasePropertyById(ctx, databaseId, propertyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDatabasePropertyByIdResponse(rsp)
}

// GetDatabaseContentPropertiesByIdWithResponse request returning *GetDatabaseContentPropertiesByIdResponse
func (c *ClientWithResponses) GetDatabaseContentPropertiesByIdWithResponse(ctx context.Context, databaseId int64, propertyId int64, reqEditors ...RequestEditorFn) (*GetDatabaseContentPropertiesByIdResponse, error) {
	rsp, err := c.GetDatabaseContentPropertiesById(ctx, databaseId, propertyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDatabaseContentPropertiesByIdResponse(rsp)
}

// UpdateDatabasePropertyByIdWithBodyWithResponse request with arbitrary body returning *UpdateDatabasePropertyByIdResponse
func (c *ClientWithResponses) UpdateDatabasePropertyByIdWithBodyWithResponse(ctx context.Context, databaseId int64, propertyId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDatabasePropertyByIdResponse, error) {
	rsp, err := c.UpdateDatabasePropertyByIdWithBody(ctx, databaseId, propertyId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDatabasePropertyByIdResponse(rsp)
}

func (c *ClientWithResponses) UpdateDatabasePropertyByIdWithResponse(ctx context.Context, databaseId int64, propertyId int64, body UpdateDatabasePropertyByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDatabasePropertyByIdResponse, error) {
	rsp, err := c.UpdateDatabasePropertyById(ctx, databaseId, propertyId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDatabasePropertyByIdResponse(rsp)
}

// DeleteDatabaseWithResponse request returning *DeleteDatabaseResponse
func (c *ClientWithResponses) DeleteDatabaseWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*DeleteDatabaseResponse, error) {
	rsp, err := c.DeleteDatabase(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDatabaseResponse(rsp)
}

// GetDatabaseByIdWithResponse request returning *GetDatabaseByIdResponse
func (c *ClientWithResponses) GetDatabaseByIdWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetDatabaseByIdResponse, error) {
	rsp, err := c.GetDatabaseById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDatabaseByIdResponse(rsp)
}

// GetDatabaseAncestorsWithResponse request returning *GetDatabaseAncestorsResponse
func (c *ClientWithResponses) GetDatabaseAncestorsWithResponse(ctx context.Context, id int64, params *GetDatabaseAncestorsParams, reqEditors ...RequestEditorFn) (*GetDatabaseAncestorsResponse, error) {
	rsp, err := c.GetDatabaseAncestors(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDatabaseAncestorsResponse(rsp)
}

// GetDatabaseClassificationLevelWithResponse request returning *GetDatabaseClassificationLevelResponse
func (c *ClientWithResponses) GetDatabaseClassificationLevelWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetDatabaseClassificationLevelResponse, error) {
	rsp, err := c.GetDatabaseClassificationLevel(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDatabaseClassificationLevelResponse(rsp)
}

// PutDatabaseClassificationLevelWithBodyWithResponse request with arbitrary body returning *PutDatabaseClassificationLevelResponse
func (c *ClientWithResponses) PutDatabaseClassificationLevelWithBodyWithResponse(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutDatabaseClassificationLevelResponse, error) {
	rsp, err := c.PutDatabaseClassificationLevelWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutDatabaseClassificationLevelResponse(rsp)
}

func (c *ClientWithResponses) PutDatabaseClassificationLevelWithResponse(ctx context.Context, id int64, body PutDatabaseClassificationLevelJSONRequestBody, reqEditors ...RequestEditorFn) (*PutDatabaseClassificationLevelResponse, error) {
	rsp, err := c.PutDatabaseClassificationLevel(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutDatabaseClassificationLevelResponse(rsp)
}

// PostDatabaseClassificationLevelWithBodyWithResponse request with arbitrary body returning *PostDatabaseClassificationLevelResponse
func (c *ClientWithResponses) PostDatabaseClassificationLevelWithBodyWithResponse(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostDatabaseClassificationLevelResponse, error) {
	rsp, err := c.PostDatabaseClassificationLevelWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostDatabaseClassificationLevelResponse(rsp)
}

func (c *ClientWithResponses) PostDatabaseClassificationLevelWithResponse(ctx context.Context, id int64, body PostDatabaseClassificationLevelJSONRequestBody, reqEditors ...RequestEditorFn) (*PostDatabaseClassificationLevelResponse, error) {
	rsp, err := c.PostDatabaseClassificationLevel(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostDatabaseClassificationLevelResponse(rsp)
}

// GetDatabaseOperationsWithResponse request returning *GetDatabaseOperationsResponse
func (c *ClientWithResponses) GetDatabaseOperationsWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetDatabaseOperationsResponse, error) {
	rsp, err := c.GetDatabaseOperations(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDatabaseOperationsResponse(rsp)
}

// GetDatabaseContentPropertiesWithResponse request returning *GetDatabaseContentPropertiesResponse
func (c *ClientWithResponses) GetDatabaseContentPropertiesWithResponse(ctx context.Context, id int64, params *GetDatabaseContentPropertiesParams, reqEditors ...RequestEditorFn) (*GetDatabaseContentPropertiesResponse, error) {
	rsp, err := c.GetDatabaseContentProperties(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDatabaseContentPropertiesResponse(rsp)
}

// CreateDatabasePropertyWithBodyWithResponse request with arbitrary body returning *CreateDatabasePropertyResponse
func (c *ClientWithResponses) CreateDatabasePropertyWithBodyWithResponse(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDatabasePropertyResponse, error) {
	rsp, err := c.CreateDatabasePropertyWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDatabasePropertyResponse(rsp)
}

func (c *ClientWithResponses) CreateDatabasePropertyWithResponse(ctx context.Context, id int64, body CreateDatabasePropertyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDatabasePropertyResponse, error) {
	rsp, err := c.CreateDatabaseProperty(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDatabasePropertyResponse(rsp)
}

// CreateSmartLinkWithBodyWithResponse request with arbitrary body returning *CreateSmartLinkResponse
func (c *ClientWithResponses) CreateSmartLinkWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSmartLinkResponse, error) {
	rsp, err := c.CreateSmartLinkWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSmartLinkResponse(rsp)
}

func (c *ClientWithResponses) CreateSmartLinkWithResponse(ctx context.Context, body CreateSmartLinkJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSmartLinkResponse, error) {
	rsp, err := c.CreateSmartLink(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSmartLinkResponse(rsp)
}

// DeleteSmartLinkPropertyByIdWithResponse request returning *DeleteSmartLinkPropertyByIdResponse
func (c *ClientWithResponses) DeleteSmartLinkPropertyByIdWithResponse(ctx context.Context, embedId int64, propertyId int64, reqEditors ...RequestEditorFn) (*DeleteSmartLinkPropertyByIdResponse, error) {
	rsp, err := c.DeleteSmartLinkPropertyById(ctx, embedId, propertyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSmartLinkPropertyByIdResponse(rsp)
}

// GetSmartLinkContentPropertiesByIdWithResponse request returning *GetSmartLinkContentPropertiesByIdResponse
func (c *ClientWithResponses) GetSmartLinkContentPropertiesByIdWithResponse(ctx context.Context, embedId int64, propertyId int64, reqEditors ...RequestEditorFn) (*GetSmartLinkContentPropertiesByIdResponse, error) {
	rsp, err := c.GetSmartLinkContentPropertiesById(ctx, embedId, propertyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSmartLinkContentPropertiesByIdResponse(rsp)
}

// UpdateSmartLinkPropertyByIdWithBodyWithResponse request with arbitrary body returning *UpdateSmartLinkPropertyByIdResponse
func (c *ClientWithResponses) UpdateSmartLinkPropertyByIdWithBodyWithResponse(ctx context.Context, embedId int64, propertyId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSmartLinkPropertyByIdResponse, error) {
	rsp, err := c.UpdateSmartLinkPropertyByIdWithBody(ctx, embedId, propertyId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSmartLinkPropertyByIdResponse(rsp)
}

func (c *ClientWithResponses) UpdateSmartLinkPropertyByIdWithResponse(ctx context.Context, embedId int64, propertyId int64, body UpdateSmartLinkPropertyByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSmartLinkPropertyByIdResponse, error) {
	rsp, err := c.UpdateSmartLinkPropertyById(ctx, embedId, propertyId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSmartLinkPropertyByIdResponse(rsp)
}

// DeleteSmartLinkWithResponse request returning *DeleteSmartLinkResponse
func (c *ClientWithResponses) DeleteSmartLinkWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*DeleteSmartLinkResponse, error) {
	rsp, err := c.DeleteSmartLink(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSmartLinkResponse(rsp)
}

// GetSmartLinkByIdWithResponse request returning *GetSmartLinkByIdResponse
func (c *ClientWithResponses) GetSmartLinkByIdWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetSmartLinkByIdResponse, error) {
	rsp, err := c.GetSmartLinkById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSmartLinkByIdResponse(rsp)
}

// GetSmartLinkAncestorsWithResponse request returning *GetSmartLinkAncestorsResponse
func (c *ClientWithResponses) GetSmartLinkAncestorsWithResponse(ctx context.Context, id int64, params *GetSmartLinkAncestorsParams, reqEditors ...RequestEditorFn) (*GetSmartLinkAncestorsResponse, error) {
	rsp, err := c.GetSmartLinkAncestors(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSmartLinkAncestorsResponse(rsp)
}

// GetSmartLinkOperationsWithResponse request returning *GetSmartLinkOperationsResponse
func (c *ClientWithResponses) GetSmartLinkOperationsWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetSmartLinkOperationsResponse, error) {
	rsp, err := c.GetSmartLinkOperations(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSmartLinkOperationsResponse(rsp)
}

// GetSmartLinkContentPropertiesWithResponse request returning *GetSmartLinkContentPropertiesResponse
func (c *ClientWithResponses) GetSmartLinkContentPropertiesWithResponse(ctx context.Context, id int64, params *GetSmartLinkContentPropertiesParams, reqEditors ...RequestEditorFn) (*GetSmartLinkContentPropertiesResponse, error) {
	rsp, err := c.GetSmartLinkContentProperties(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSmartLinkContentPropertiesResponse(rsp)
}

// CreateSmartLinkPropertyWithBodyWithResponse request with arbitrary body returning *CreateSmartLinkPropertyResponse
func (c *ClientWithResponses) CreateSmartLinkPropertyWithBodyWithResponse(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSmartLinkPropertyResponse, error) {
	rsp, err := c.CreateSmartLinkPropertyWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSmartLinkPropertyResponse(rsp)
}

func (c *ClientWithResponses) CreateSmartLinkPropertyWithResponse(ctx context.Context, id int64, body CreateSmartLinkPropertyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSmartLinkPropertyResponse, error) {
	rsp, err := c.CreateSmartLinkProperty(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSmartLinkPropertyResponse(rsp)
}

// CreateFolderWithBodyWithResponse request with arbitrary body returning *CreateFolderResponse
func (c *ClientWithResponses) CreateFolderWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFolderResponse, error) {
	rsp, err := c.CreateFolderWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFolderResponse(rsp)
}

func (c *ClientWithResponses) CreateFolderWithResponse(ctx context.Context, body CreateFolderJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFolderResponse, error) {
	rsp, err := c.CreateFolder(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFolderResponse(rsp)
}

// DeleteFolderPropertyByIdWithResponse request returning *DeleteFolderPropertyByIdResponse
func (c *ClientWithResponses) DeleteFolderPropertyByIdWithResponse(ctx context.Context, folderId int64, propertyId int64, reqEditors ...RequestEditorFn) (*DeleteFolderPropertyByIdResponse, error) {
	rsp, err := c.DeleteFolderPropertyById(ctx, folderId, propertyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteFolderPropertyByIdResponse(rsp)
}

// GetFolderContentPropertiesByIdWithResponse request returning *GetFolderContentPropertiesByIdResponse
func (c *ClientWithResponses) GetFolderContentPropertiesByIdWithResponse(ctx context.Context, folderId int64, propertyId int64, reqEditors ...RequestEditorFn) (*GetFolderContentPropertiesByIdResponse, error) {
	rsp, err := c.GetFolderContentPropertiesById(ctx, folderId, propertyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFolderContentPropertiesByIdResponse(rsp)
}

// UpdateFolderPropertyByIdWithBodyWithResponse request with arbitrary body returning *UpdateFolderPropertyByIdResponse
func (c *ClientWithResponses) UpdateFolderPropertyByIdWithBodyWithResponse(ctx context.Context, folderId int64, propertyId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateFolderPropertyByIdResponse, error) {
	rsp, err := c.UpdateFolderPropertyByIdWithBody(ctx, folderId, propertyId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateFolderPropertyByIdResponse(rsp)
}

func (c *ClientWithResponses) UpdateFolderPropertyByIdWithResponse(ctx context.Context, folderId int64, propertyId int64, body UpdateFolderPropertyByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateFolderPropertyByIdResponse, error) {
	rsp, err := c.UpdateFolderPropertyById(ctx, folderId, propertyId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateFolderPropertyByIdResponse(rsp)
}

// DeleteFolderWithResponse request returning *DeleteFolderResponse
func (c *ClientWithResponses) DeleteFolderWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*DeleteFolderResponse, error) {
	rsp, err := c.DeleteFolder(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteFolderResponse(rsp)
}

// GetFolderByIdWithResponse request returning *GetFolderByIdResponse
func (c *ClientWithResponses) GetFolderByIdWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetFolderByIdResponse, error) {
	rsp, err := c.GetFolderById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFolderByIdResponse(rsp)
}

// GetFolderAncestorsWithResponse request returning *GetFolderAncestorsResponse
func (c *ClientWithResponses) GetFolderAncestorsWithResponse(ctx context.Context, id int64, params *GetFolderAncestorsParams, reqEditors ...RequestEditorFn) (*GetFolderAncestorsResponse, error) {
	rsp, err := c.GetFolderAncestors(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFolderAncestorsResponse(rsp)
}

// GetFolderOperationsWithResponse request returning *GetFolderOperationsResponse
func (c *ClientWithResponses) GetFolderOperationsWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetFolderOperationsResponse, error) {
	rsp, err := c.GetFolderOperations(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFolderOperationsResponse(rsp)
}

// GetFolderContentPropertiesWithResponse request returning *GetFolderContentPropertiesResponse
func (c *ClientWithResponses) GetFolderContentPropertiesWithResponse(ctx context.Context, id int64, params *GetFolderContentPropertiesParams, reqEditors ...RequestEditorFn) (*GetFolderContentPropertiesResponse, error) {
	rsp, err := c.GetFolderContentProperties(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFolderContentPropertiesResponse(rsp)
}

// CreateFolderPropertyWithBodyWithResponse request with arbitrary body returning *CreateFolderPropertyResponse
func (c *ClientWithResponses) CreateFolderPropertyWithBodyWithResponse(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFolderPropertyResponse, error) {
	rsp, err := c.CreateFolderPropertyWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFolderPropertyResponse(rsp)
}

func (c *ClientWithResponses) CreateFolderPropertyWithResponse(ctx context.Context, id int64, body CreateFolderPropertyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFolderPropertyResponse, error) {
	rsp, err := c.CreateFolderProperty(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFolderPropertyResponse(rsp)
}

// GetFooterCommentsWithResponse request returning *GetFooterCommentsResponse
func (c *ClientWithResponses) GetFooterCommentsWithResponse(ctx context.Context, params *GetFooterCommentsParams, reqEditors ...RequestEditorFn) (*GetFooterCommentsResponse, error) {
	rsp, err := c.GetFooterComments(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFooterCommentsResponse(rsp)
}

// CreateFooterCommentWithBodyWithResponse request with arbitrary body returning *CreateFooterCommentResponse
func (c *ClientWithResponses) CreateFooterCommentWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFooterCommentResponse, error) {
	rsp, err := c.CreateFooterCommentWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFooterCommentResponse(rsp)
}

func (c *ClientWithResponses) CreateFooterCommentWithResponse(ctx context.Context, body CreateFooterCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFooterCommentResponse, error) {
	rsp, err := c.CreateFooterComment(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFooterCommentResponse(rsp)
}

// DeleteFooterCommentWithResponse request returning *DeleteFooterCommentResponse
func (c *ClientWithResponses) DeleteFooterCommentWithResponse(ctx context.Context, commentId int64, reqEditors ...RequestEditorFn) (*DeleteFooterCommentResponse, error) {
	rsp, err := c.DeleteFooterComment(ctx, commentId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteFooterCommentResponse(rsp)
}

// GetFooterCommentByIdWithResponse request returning *GetFooterCommentByIdResponse
func (c *ClientWithResponses) GetFooterCommentByIdWithResponse(ctx context.Context, commentId int64, params *GetFooterCommentByIdParams, reqEditors ...RequestEditorFn) (*GetFooterCommentByIdResponse, error) {
	rsp, err := c.GetFooterCommentById(ctx, commentId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFooterCommentByIdResponse(rsp)
}

// UpdateFooterCommentWithBodyWithResponse request with arbitrary body returning *UpdateFooterCommentResponse
func (c *ClientWithResponses) UpdateFooterCommentWithBodyWithResponse(ctx context.Context, commentId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateFooterCommentResponse, error) {
	rsp, err := c.UpdateFooterCommentWithBody(ctx, commentId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateFooterCommentResponse(rsp)
}

func (c *ClientWithResponses) UpdateFooterCommentWithResponse(ctx context.Context, commentId int64, body UpdateFooterCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateFooterCommentResponse, error) {
	rsp, err := c.UpdateFooterComment(ctx, commentId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateFooterCommentResponse(rsp)
}

// GetFooterCommentChildrenWithResponse request returning *GetFooterCommentChildrenResponse
func (c *ClientWithResponses) GetFooterCommentChildrenWithResponse(ctx context.Context, id int64, params *GetFooterCommentChildrenParams, reqEditors ...RequestEditorFn) (*GetFooterCommentChildrenResponse, error) {
	rsp, err := c.GetFooterCommentChildren(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFooterCommentChildrenResponse(rsp)
}

// GetFooterLikeCountWithResponse request returning *GetFooterLikeCountResponse
func (c *ClientWithResponses) GetFooterLikeCountWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetFooterLikeCountResponse, error) {
	rsp, err := c.GetFooterLikeCount(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFooterLikeCountResponse(rsp)
}

// GetFooterLikeUsersWithResponse request returning *GetFooterLikeUsersResponse
func (c *ClientWithResponses) GetFooterLikeUsersWithResponse(ctx context.Context, id int64, params *GetFooterLikeUsersParams, reqEditors ...RequestEditorFn) (*GetFooterLikeUsersResponse, error) {
	rsp, err := c.GetFooterLikeUsers(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFooterLikeUsersResponse(rsp)
}

// GetFooterCommentOperationsWithResponse request returning *GetFooterCommentOperationsResponse
func (c *ClientWithResponses) GetFooterCommentOperationsWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetFooterCommentOperationsResponse, error) {
	rsp, err := c.GetFooterCommentOperations(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFooterCommentOperationsResponse(rsp)
}

// GetFooterCommentVersionsWithResponse request returning *GetFooterCommentVersionsResponse
func (c *ClientWithResponses) GetFooterCommentVersionsWithResponse(ctx context.Context, id int64, params *GetFooterCommentVersionsParams, reqEditors ...RequestEditorFn) (*GetFooterCommentVersionsResponse, error) {
	rsp, err := c.GetFooterCommentVersions(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFooterCommentVersionsResponse(rsp)
}

// GetFooterCommentVersionDetailsWithResponse request returning *GetFooterCommentVersionDetailsResponse
func (c *ClientWithResponses) GetFooterCommentVersionDetailsWithResponse(ctx context.Context, id int64, versionNumber int64, reqEditors ...RequestEditorFn) (*GetFooterCommentVersionDetailsResponse, error) {
	rsp, err := c.GetFooterCommentVersionDetails(ctx, id, versionNumber, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFooterCommentVersionDetailsResponse(rsp)
}

// GetInlineCommentsWithResponse request returning *GetInlineCommentsResponse
func (c *ClientWithResponses) GetInlineCommentsWithResponse(ctx context.Context, params *GetInlineCommentsParams, reqEditors ...RequestEditorFn) (*GetInlineCommentsResponse, error) {
	rsp, err := c.GetInlineComments(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInlineCommentsResponse(rsp)
}

// CreateInlineCommentWithBodyWithResponse request with arbitrary body returning *CreateInlineCommentResponse
func (c *ClientWithResponses) CreateInlineCommentWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateInlineCommentResponse, error) {
	rsp, err := c.CreateInlineCommentWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateInlineCommentResponse(rsp)
}

func (c *ClientWithResponses) CreateInlineCommentWithResponse(ctx context.Context, body CreateInlineCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateInlineCommentResponse, error) {
	rsp, err := c.CreateInlineComment(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateInlineCommentResponse(rsp)
}

// DeleteInlineCommentWithResponse request returning *DeleteInlineCommentResponse
func (c *ClientWithResponses) DeleteInlineCommentWithResponse(ctx context.Context, commentId int64, reqEditors ...RequestEditorFn) (*DeleteInlineCommentResponse, error) {
	rsp, err := c.DeleteInlineComment(ctx, commentId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteInlineCommentResponse(rsp)
}

// GetInlineCommentByIdWithResponse request returning *GetInlineCommentByIdResponse
func (c *ClientWithResponses) GetInlineCommentByIdWithResponse(ctx context.Context, commentId int64, params *GetInlineCommentByIdParams, reqEditors ...RequestEditorFn) (*GetInlineCommentByIdResponse, error) {
	rsp, err := c.GetInlineCommentById(ctx, commentId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInlineCommentByIdResponse(rsp)
}

// UpdateInlineCommentWithBodyWithResponse request with arbitrary body returning *UpdateInlineCommentResponse
func (c *ClientWithResponses) UpdateInlineCommentWithBodyWithResponse(ctx context.Context, commentId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateInlineCommentResponse, error) {
	rsp, err := c.UpdateInlineCommentWithBody(ctx, commentId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateInlineCommentResponse(rsp)
}

func (c *ClientWithResponses) UpdateInlineCommentWithResponse(ctx context.Context, commentId int64, body UpdateInlineCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateInlineCommentResponse, error) {
	rsp, err := c.UpdateInlineComment(ctx, commentId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateInlineCommentResponse(rsp)
}

// GetInlineCommentChildrenWithResponse request returning *GetInlineCommentChildrenResponse
func (c *ClientWithResponses) GetInlineCommentChildrenWithResponse(ctx context.Context, id int64, params *GetInlineCommentChildrenParams, reqEditors ...RequestEditorFn) (*GetInlineCommentChildrenResponse, error) {
	rsp, err := c.GetInlineCommentChildren(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInlineCommentChildrenResponse(rsp)
}

// GetInlineLikeCountWithResponse request returning *GetInlineLikeCountResponse
func (c *ClientWithResponses) GetInlineLikeCountWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetInlineLikeCountResponse, error) {
	rsp, err := c.GetInlineLikeCount(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInlineLikeCountResponse(rsp)
}

// GetInlineLikeUsersWithResponse request returning *GetInlineLikeUsersResponse
func (c *ClientWithResponses) GetInlineLikeUsersWithResponse(ctx context.Context, id int64, params *GetInlineLikeUsersParams, reqEditors ...RequestEditorFn) (*GetInlineLikeUsersResponse, error) {
	rsp, err := c.GetInlineLikeUsers(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInlineLikeUsersResponse(rsp)
}

// GetInlineCommentOperationsWithResponse request returning *GetInlineCommentOperationsResponse
func (c *ClientWithResponses) GetInlineCommentOperationsWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetInlineCommentOperationsResponse, error) {
	rsp, err := c.GetInlineCommentOperations(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInlineCommentOperationsResponse(rsp)
}

// GetInlineCommentVersionsWithResponse request returning *GetInlineCommentVersionsResponse
func (c *ClientWithResponses) GetInlineCommentVersionsWithResponse(ctx context.Context, id int64, params *GetInlineCommentVersionsParams, reqEditors ...RequestEditorFn) (*GetInlineCommentVersionsResponse, error) {
	rsp, err := c.GetInlineCommentVersions(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInlineCommentVersionsResponse(rsp)
}

// GetInlineCommentVersionDetailsWithResponse request returning *GetInlineCommentVersionDetailsResponse
func (c *ClientWithResponses) GetInlineCommentVersionDetailsWithResponse(ctx context.Context, id int64, versionNumber int64, reqEditors ...RequestEditorFn) (*GetInlineCommentVersionDetailsResponse, error) {
	rsp, err := c.GetInlineCommentVersionDetails(ctx, id, versionNumber, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInlineCommentVersionDetailsResponse(rsp)
}

// GetLabelsWithResponse request returning *GetLabelsResponse
func (c *ClientWithResponses) GetLabelsWithResponse(ctx context.Context, params *GetLabelsParams, reqEditors ...RequestEditorFn) (*GetLabelsResponse, error) {
	rsp, err := c.GetLabels(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLabelsResponse(rsp)
}

// GetLabelAttachmentsWithResponse request returning *GetLabelAttachmentsResponse
func (c *ClientWithResponses) GetLabelAttachmentsWithResponse(ctx context.Context, id int64, params *GetLabelAttachmentsParams, reqEditors ...RequestEditorFn) (*GetLabelAttachmentsResponse, error) {
	rsp, err := c.GetLabelAttachments(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLabelAttachmentsResponse(rsp)
}

// GetLabelBlogPostsWithResponse request returning *GetLabelBlogPostsResponse
func (c *ClientWithResponses) GetLabelBlogPostsWithResponse(ctx context.Context, id int64, params *GetLabelBlogPostsParams, reqEditors ...RequestEditorFn) (*GetLabelBlogPostsResponse, error) {
	rsp, err := c.GetLabelBlogPosts(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLabelBlogPostsResponse(rsp)
}

// GetLabelPagesWithResponse request returning *GetLabelPagesResponse
func (c *ClientWithResponses) GetLabelPagesWithResponse(ctx context.Context, id int64, params *GetLabelPagesParams, reqEditors ...RequestEditorFn) (*GetLabelPagesResponse, error) {
	rsp, err := c.GetLabelPages(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLabelPagesResponse(rsp)
}

// GetPagesWithResponse request returning *GetPagesResponse
func (c *ClientWithResponses) GetPagesWithResponse(ctx context.Context, params *GetPagesParams, reqEditors ...RequestEditorFn) (*GetPagesResponse, error) {
	rsp, err := c.GetPages(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPagesResponse(rsp)
}

// CreatePageWithBodyWithResponse request with arbitrary body returning *CreatePageResponse
func (c *ClientWithResponses) CreatePageWithBodyWithResponse(ctx context.Context, params *CreatePageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePageResponse, error) {
	rsp, err := c.CreatePageWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePageResponse(rsp)
}

func (c *ClientWithResponses) CreatePageWithResponse(ctx context.Context, params *CreatePageParams, body CreatePageJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePageResponse, error) {
	rsp, err := c.CreatePage(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePageResponse(rsp)
}

// DeletePageWithResponse request returning *DeletePageResponse
func (c *ClientWithResponses) DeletePageWithResponse(ctx context.Context, id int64, params *DeletePageParams, reqEditors ...RequestEditorFn) (*DeletePageResponse, error) {
	rsp, err := c.DeletePage(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePageResponse(rsp)
}

// GetPageByIdWithResponse request returning *GetPageByIdResponse
func (c *ClientWithResponses) GetPageByIdWithResponse(ctx context.Context, id int64, params *GetPageByIdParams, reqEditors ...RequestEditorFn) (*GetPageByIdResponse, error) {
	rsp, err := c.GetPageById(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPageByIdResponse(rsp)
}

// UpdatePageWithBodyWithResponse request with arbitrary body returning *UpdatePageResponse
func (c *ClientWithResponses) UpdatePageWithBodyWithResponse(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePageResponse, error) {
	rsp, err := c.UpdatePageWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePageResponse(rsp)
}

func (c *ClientWithResponses) UpdatePageWithResponse(ctx context.Context, id int64, body UpdatePageJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePageResponse, error) {
	rsp, err := c.UpdatePage(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePageResponse(rsp)
}

// GetPageAncestorsWithResponse request returning *GetPageAncestorsResponse
func (c *ClientWithResponses) GetPageAncestorsWithResponse(ctx context.Context, id int64, params *GetPageAncestorsParams, reqEditors ...RequestEditorFn) (*GetPageAncestorsResponse, error) {
	rsp, err := c.GetPageAncestors(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPageAncestorsResponse(rsp)
}

// GetPageAttachmentsWithResponse request returning *GetPageAttachmentsResponse
func (c *ClientWithResponses) GetPageAttachmentsWithResponse(ctx context.Context, id int64, params *GetPageAttachmentsParams, reqEditors ...RequestEditorFn) (*GetPageAttachmentsResponse, error) {
	rsp, err := c.GetPageAttachments(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPageAttachmentsResponse(rsp)
}

// GetChildPagesWithResponse request returning *GetChildPagesResponse
func (c *ClientWithResponses) GetChildPagesWithResponse(ctx context.Context, id int64, params *GetChildPagesParams, reqEditors ...RequestEditorFn) (*GetChildPagesResponse, error) {
	rsp, err := c.GetChildPages(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetChildPagesResponse(rsp)
}

// GetPageClassificationLevelWithResponse request returning *GetPageClassificationLevelResponse
func (c *ClientWithResponses) GetPageClassificationLevelWithResponse(ctx context.Context, id int64, params *GetPageClassificationLevelParams, reqEditors ...RequestEditorFn) (*GetPageClassificationLevelResponse, error) {
	rsp, err := c.GetPageClassificationLevel(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPageClassificationLevelResponse(rsp)
}

// PutPageClassificationLevelWithBodyWithResponse request with arbitrary body returning *PutPageClassificationLevelResponse
func (c *ClientWithResponses) PutPageClassificationLevelWithBodyWithResponse(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutPageClassificationLevelResponse, error) {
	rsp, err := c.PutPageClassificationLevelWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutPageClassificationLevelResponse(rsp)
}

func (c *ClientWithResponses) PutPageClassificationLevelWithResponse(ctx context.Context, id int64, body PutPageClassificationLevelJSONRequestBody, reqEditors ...RequestEditorFn) (*PutPageClassificationLevelResponse, error) {
	rsp, err := c.PutPageClassificationLevel(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutPageClassificationLevelResponse(rsp)
}

// PostPageClassificationLevelWithBodyWithResponse request with arbitrary body returning *PostPageClassificationLevelResponse
func (c *ClientWithResponses) PostPageClassificationLevelWithBodyWithResponse(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostPageClassificationLevelResponse, error) {
	rsp, err := c.PostPageClassificationLevelWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostPageClassificationLevelResponse(rsp)
}

func (c *ClientWithResponses) PostPageClassificationLevelWithResponse(ctx context.Context, id int64, body PostPageClassificationLevelJSONRequestBody, reqEditors ...RequestEditorFn) (*PostPageClassificationLevelResponse, error) {
	rsp, err := c.PostPageClassificationLevel(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostPageClassificationLevelResponse(rsp)
}

// GetCustomContentByTypeInPageWithResponse request returning *GetCustomContentByTypeInPageResponse
func (c *ClientWithResponses) GetCustomContentByTypeInPageWithResponse(ctx context.Context, id int64, params *GetCustomContentByTypeInPageParams, reqEditors ...RequestEditorFn) (*GetCustomContentByTypeInPageResponse, error) {
	rsp, err := c.GetCustomContentByTypeInPage(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCustomContentByTypeInPageResponse(rsp)
}

// GetPageFooterCommentsWithResponse request returning *GetPageFooterCommentsResponse
func (c *ClientWithResponses) GetPageFooterCommentsWithResponse(ctx context.Context, id int64, params *GetPageFooterCommentsParams, reqEditors ...RequestEditorFn) (*GetPageFooterCommentsResponse, error) {
	rsp, err := c.GetPageFooterComments(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPageFooterCommentsResponse(rsp)
}

// GetPageInlineCommentsWithResponse request returning *GetPageInlineCommentsResponse
func (c *ClientWithResponses) GetPageInlineCommentsWithResponse(ctx context.Context, id int64, params *GetPageInlineCommentsParams, reqEditors ...RequestEditorFn) (*GetPageInlineCommentsResponse, error) {
	rsp, err := c.GetPageInlineComments(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPageInlineCommentsResponse(rsp)
}

// GetPageLabelsWithResponse request returning *GetPageLabelsResponse
func (c *ClientWithResponses) GetPageLabelsWithResponse(ctx context.Context, id int64, params *GetPageLabelsParams, reqEditors ...RequestEditorFn) (*GetPageLabelsResponse, error) {
	rsp, err := c.GetPageLabels(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPageLabelsResponse(rsp)
}

// GetPageLikeCountWithResponse request returning *GetPageLikeCountResponse
func (c *ClientWithResponses) GetPageLikeCountWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetPageLikeCountResponse, error) {
	rsp, err := c.GetPageLikeCount(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPageLikeCountResponse(rsp)
}

// GetPageLikeUsersWithResponse request returning *GetPageLikeUsersResponse
func (c *ClientWithResponses) GetPageLikeUsersWithResponse(ctx context.Context, id int64, params *GetPageLikeUsersParams, reqEditors ...RequestEditorFn) (*GetPageLikeUsersResponse, error) {
	rsp, err := c.GetPageLikeUsers(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPageLikeUsersResponse(rsp)
}

// GetPageOperationsWithResponse request returning *GetPageOperationsResponse
func (c *ClientWithResponses) GetPageOperationsWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetPageOperationsResponse, error) {
	rsp, err := c.GetPageOperations(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPageOperationsResponse(rsp)
}

// GetPageVersionsWithResponse request returning *GetPageVersionsResponse
func (c *ClientWithResponses) GetPageVersionsWithResponse(ctx context.Context, id int64, params *GetPageVersionsParams, reqEditors ...RequestEditorFn) (*GetPageVersionsResponse, error) {
	rsp, err := c.GetPageVersions(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPageVersionsResponse(rsp)
}

// GetPageContentPropertiesWithResponse request returning *GetPageContentPropertiesResponse
func (c *ClientWithResponses) GetPageContentPropertiesWithResponse(ctx context.Context, pageId int64, params *GetPageContentPropertiesParams, reqEditors ...RequestEditorFn) (*GetPageContentPropertiesResponse, error) {
	rsp, err := c.GetPageContentProperties(ctx, pageId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPageContentPropertiesResponse(rsp)
}

// CreatePagePropertyWithBodyWithResponse request with arbitrary body returning *CreatePagePropertyResponse
func (c *ClientWithResponses) CreatePagePropertyWithBodyWithResponse(ctx context.Context, pageId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePagePropertyResponse, error) {
	rsp, err := c.CreatePagePropertyWithBody(ctx, pageId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePagePropertyResponse(rsp)
}

func (c *ClientWithResponses) CreatePagePropertyWithResponse(ctx context.Context, pageId int64, body CreatePagePropertyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePagePropertyResponse, error) {
	rsp, err := c.CreatePageProperty(ctx, pageId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePagePropertyResponse(rsp)
}

// DeletePagePropertyByIdWithResponse request returning *DeletePagePropertyByIdResponse
func (c *ClientWithResponses) DeletePagePropertyByIdWithResponse(ctx context.Context, pageId int64, propertyId int64, reqEditors ...RequestEditorFn) (*DeletePagePropertyByIdResponse, error) {
	rsp, err := c.DeletePagePropertyById(ctx, pageId, propertyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePagePropertyByIdResponse(rsp)
}

// GetPageContentPropertiesByIdWithResponse request returning *GetPageContentPropertiesByIdResponse
func (c *ClientWithResponses) GetPageContentPropertiesByIdWithResponse(ctx context.Context, pageId int64, propertyId int64, reqEditors ...RequestEditorFn) (*GetPageContentPropertiesByIdResponse, error) {
	rsp, err := c.GetPageContentPropertiesById(ctx, pageId, propertyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPageContentPropertiesByIdResponse(rsp)
}

// UpdatePagePropertyByIdWithBodyWithResponse request with arbitrary body returning *UpdatePagePropertyByIdResponse
func (c *ClientWithResponses) UpdatePagePropertyByIdWithBodyWithResponse(ctx context.Context, pageId int64, propertyId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePagePropertyByIdResponse, error) {
	rsp, err := c.UpdatePagePropertyByIdWithBody(ctx, pageId, propertyId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePagePropertyByIdResponse(rsp)
}

func (c *ClientWithResponses) UpdatePagePropertyByIdWithResponse(ctx context.Context, pageId int64, propertyId int64, body UpdatePagePropertyByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePagePropertyByIdResponse, error) {
	rsp, err := c.UpdatePagePropertyById(ctx, pageId, propertyId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePagePropertyByIdResponse(rsp)
}

// GetPageVersionDetailsWithResponse request returning *GetPageVersionDetailsResponse
func (c *ClientWithResponses) GetPageVersionDetailsWithResponse(ctx context.Context, pageId int64, versionNumber int64, reqEditors ...RequestEditorFn) (*GetPageVersionDetailsResponse, error) {
	rsp, err := c.GetPageVersionDetails(ctx, pageId, versionNumber, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPageVersionDetailsResponse(rsp)
}

// GetSpacesWithResponse request returning *GetSpacesResponse
func (c *ClientWithResponses) GetSpacesWithResponse(ctx context.Context, params *GetSpacesParams, reqEditors ...RequestEditorFn) (*GetSpacesResponse, error) {
	rsp, err := c.GetSpaces(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSpacesResponse(rsp)
}

// GetSpaceByIdWithResponse request returning *GetSpaceByIdResponse
func (c *ClientWithResponses) GetSpaceByIdWithResponse(ctx context.Context, id int64, params *GetSpaceByIdParams, reqEditors ...RequestEditorFn) (*GetSpaceByIdResponse, error) {
	rsp, err := c.GetSpaceById(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSpaceByIdResponse(rsp)
}

// GetBlogPostsInSpaceWithResponse request returning *GetBlogPostsInSpaceResponse
func (c *ClientWithResponses) GetBlogPostsInSpaceWithResponse(ctx context.Context, id int64, params *GetBlogPostsInSpaceParams, reqEditors ...RequestEditorFn) (*GetBlogPostsInSpaceResponse, error) {
	rsp, err := c.GetBlogPostsInSpace(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBlogPostsInSpaceResponse(rsp)
}

// DeleteSpaceDefaultClassificationLevelWithResponse request returning *DeleteSpaceDefaultClassificationLevelResponse
func (c *ClientWithResponses) DeleteSpaceDefaultClassificationLevelWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*DeleteSpaceDefaultClassificationLevelResponse, error) {
	rsp, err := c.DeleteSpaceDefaultClassificationLevel(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSpaceDefaultClassificationLevelResponse(rsp)
}

// GetSpaceDefaultClassificationLevelWithResponse request returning *GetSpaceDefaultClassificationLevelResponse
func (c *ClientWithResponses) GetSpaceDefaultClassificationLevelWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetSpaceDefaultClassificationLevelResponse, error) {
	rsp, err := c.GetSpaceDefaultClassificationLevel(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSpaceDefaultClassificationLevelResponse(rsp)
}

// PutSpaceDefaultClassificationLevelWithBodyWithResponse request with arbitrary body returning *PutSpaceDefaultClassificationLevelResponse
func (c *ClientWithResponses) PutSpaceDefaultClassificationLevelWithBodyWithResponse(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutSpaceDefaultClassificationLevelResponse, error) {
	rsp, err := c.PutSpaceDefaultClassificationLevelWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutSpaceDefaultClassificationLevelResponse(rsp)
}

func (c *ClientWithResponses) PutSpaceDefaultClassificationLevelWithResponse(ctx context.Context, id int64, body PutSpaceDefaultClassificationLevelJSONRequestBody, reqEditors ...RequestEditorFn) (*PutSpaceDefaultClassificationLevelResponse, error) {
	rsp, err := c.PutSpaceDefaultClassificationLevel(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutSpaceDefaultClassificationLevelResponse(rsp)
}

// GetSpaceContentLabelsWithResponse request returning *GetSpaceContentLabelsResponse
func (c *ClientWithResponses) GetSpaceContentLabelsWithResponse(ctx context.Context, id int64, params *GetSpaceContentLabelsParams, reqEditors ...RequestEditorFn) (*GetSpaceContentLabelsResponse, error) {
	rsp, err := c.GetSpaceContentLabels(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSpaceContentLabelsResponse(rsp)
}

// GetCustomContentByTypeInSpaceWithResponse request returning *GetCustomContentByTypeInSpaceResponse
func (c *ClientWithResponses) GetCustomContentByTypeInSpaceWithResponse(ctx context.Context, id int64, params *GetCustomContentByTypeInSpaceParams, reqEditors ...RequestEditorFn) (*GetCustomContentByTypeInSpaceResponse, error) {
	rsp, err := c.GetCustomContentByTypeInSpace(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCustomContentByTypeInSpaceResponse(rsp)
}

// GetSpaceLabelsWithResponse request returning *GetSpaceLabelsResponse
func (c *ClientWithResponses) GetSpaceLabelsWithResponse(ctx context.Context, id int64, params *GetSpaceLabelsParams, reqEditors ...RequestEditorFn) (*GetSpaceLabelsResponse, error) {
	rsp, err := c.GetSpaceLabels(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSpaceLabelsResponse(rsp)
}

// GetSpaceOperationsWithResponse request returning *GetSpaceOperationsResponse
func (c *ClientWithResponses) GetSpaceOperationsWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetSpaceOperationsResponse, error) {
	rsp, err := c.GetSpaceOperations(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSpaceOperationsResponse(rsp)
}

// GetPagesInSpaceWithResponse request returning *GetPagesInSpaceResponse
func (c *ClientWithResponses) GetPagesInSpaceWithResponse(ctx context.Context, id int64, params *GetPagesInSpaceParams, reqEditors ...RequestEditorFn) (*GetPagesInSpaceResponse, error) {
	rsp, err := c.GetPagesInSpace(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPagesInSpaceResponse(rsp)
}

// GetSpacePermissionsWithResponse request returning *GetSpacePermissionsResponse
func (c *ClientWithResponses) GetSpacePermissionsWithResponse(ctx context.Context, id int64, params *GetSpacePermissionsParams, reqEditors ...RequestEditorFn) (*GetSpacePermissionsResponse, error) {
	rsp, err := c.GetSpacePermissions(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSpacePermissionsResponse(rsp)
}

// GetSpacePropertiesWithResponse request returning *GetSpacePropertiesResponse
func (c *ClientWithResponses) GetSpacePropertiesWithResponse(ctx context.Context, spaceId int64, params *GetSpacePropertiesParams, reqEditors ...RequestEditorFn) (*GetSpacePropertiesResponse, error) {
	rsp, err := c.GetSpaceProperties(ctx, spaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSpacePropertiesResponse(rsp)
}

// CreateSpacePropertyWithBodyWithResponse request with arbitrary body returning *CreateSpacePropertyResponse
func (c *ClientWithResponses) CreateSpacePropertyWithBodyWithResponse(ctx context.Context, spaceId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSpacePropertyResponse, error) {
	rsp, err := c.CreateSpacePropertyWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSpacePropertyResponse(rsp)
}

func (c *ClientWithResponses) CreateSpacePropertyWithResponse(ctx context.Context, spaceId int64, body CreateSpacePropertyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSpacePropertyResponse, error) {
	rsp, err := c.CreateSpaceProperty(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSpacePropertyResponse(rsp)
}

// DeleteSpacePropertyByIdWithResponse request returning *DeleteSpacePropertyByIdResponse
func (c *ClientWithResponses) DeleteSpacePropertyByIdWithResponse(ctx context.Context, spaceId int64, propertyId int64, reqEditors ...RequestEditorFn) (*DeleteSpacePropertyByIdResponse, error) {
	rsp, err := c.DeleteSpacePropertyById(ctx, spaceId, propertyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSpacePropertyByIdResponse(rsp)
}

// GetSpacePropertyByIdWithResponse request returning *GetSpacePropertyByIdResponse
func (c *ClientWithResponses) GetSpacePropertyByIdWithResponse(ctx context.Context, spaceId int64, propertyId int64, reqEditors ...RequestEditorFn) (*GetSpacePropertyByIdResponse, error) {
	rsp, err := c.GetSpacePropertyById(ctx, spaceId, propertyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSpacePropertyByIdResponse(rsp)
}

// UpdateSpacePropertyByIdWithBodyWithResponse request with arbitrary body returning *UpdateSpacePropertyByIdResponse
func (c *ClientWithResponses) UpdateSpacePropertyByIdWithBodyWithResponse(ctx context.Context, spaceId int64, propertyId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSpacePropertyByIdResponse, error) {
	rsp, err := c.UpdateSpacePropertyByIdWithBody(ctx, spaceId, propertyId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSpacePropertyByIdResponse(rsp)
}

func (c *ClientWithResponses) UpdateSpacePropertyByIdWithResponse(ctx context.Context, spaceId int64, propertyId int64, body UpdateSpacePropertyByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSpacePropertyByIdResponse, error) {
	rsp, err := c.UpdateSpacePropertyById(ctx, spaceId, propertyId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSpacePropertyByIdResponse(rsp)
}

// GetTasksWithResponse request returning *GetTasksResponse
func (c *ClientWithResponses) GetTasksWithResponse(ctx context.Context, params *GetTasksParams, reqEditors ...RequestEditorFn) (*GetTasksResponse, error) {
	rsp, err := c.GetTasks(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTasksResponse(rsp)
}

// GetTaskByIdWithResponse request returning *GetTaskByIdResponse
func (c *ClientWithResponses) GetTaskByIdWithResponse(ctx context.Context, id int64, params *GetTaskByIdParams, reqEditors ...RequestEditorFn) (*GetTaskByIdResponse, error) {
	rsp, err := c.GetTaskById(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTaskByIdResponse(rsp)
}

// UpdateTaskWithBodyWithResponse request with arbitrary body returning *UpdateTaskResponse
func (c *ClientWithResponses) UpdateTaskWithBodyWithResponse(ctx context.Context, id int64, params *UpdateTaskParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTaskResponse, error) {
	rsp, err := c.UpdateTaskWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTaskResponse(rsp)
}

func (c *ClientWithResponses) UpdateTaskWithResponse(ctx context.Context, id int64, params *UpdateTaskParams, body UpdateTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTaskResponse, error) {
	rsp, err := c.UpdateTask(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTaskResponse(rsp)
}

// CheckAccessByEmailWithBodyWithResponse request with arbitrary body returning *CheckAccessByEmailResponse
func (c *ClientWithResponses) CheckAccessByEmailWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CheckAccessByEmailResponse, error) {
	rsp, err := c.CheckAccessByEmailWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCheckAccessByEmailResponse(rsp)
}

func (c *ClientWithResponses) CheckAccessByEmailWithResponse(ctx context.Context, body CheckAccessByEmailJSONRequestBody, reqEditors ...RequestEditorFn) (*CheckAccessByEmailResponse, error) {
	rsp, err := c.CheckAccessByEmail(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCheckAccessByEmailResponse(rsp)
}

// InviteByEmailWithBodyWithResponse request with arbitrary body returning *InviteByEmailResponse
func (c *ClientWithResponses) InviteByEmailWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InviteByEmailResponse, error) {
	rsp, err := c.InviteByEmailWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInviteByEmailResponse(rsp)
}

func (c *ClientWithResponses) InviteByEmailWithResponse(ctx context.Context, body InviteByEmailJSONRequestBody, reqEditors ...RequestEditorFn) (*InviteByEmailResponse, error) {
	rsp, err := c.InviteByEmail(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInviteByEmailResponse(rsp)
}

// CreateBulkUserLookupWithBodyWithResponse request with arbitrary body returning *CreateBulkUserLookupResponse
func (c *ClientWithResponses) CreateBulkUserLookupWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBulkUserLookupResponse, error) {
	rsp, err := c.CreateBulkUserLookupWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBulkUserLookupResponse(rsp)
}

func (c *ClientWithResponses) CreateBulkUserLookupWithResponse(ctx context.Context, body CreateBulkUserLookupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBulkUserLookupResponse, error) {
	rsp, err := c.CreateBulkUserLookup(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBulkUserLookupResponse(rsp)
}

// CreateWhiteboardWithBodyWithResponse request with arbitrary body returning *CreateWhiteboardResponse
func (c *ClientWithResponses) CreateWhiteboardWithBodyWithResponse(ctx context.Context, params *CreateWhiteboardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateWhiteboardResponse, error) {
	rsp, err := c.CreateWhiteboardWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateWhiteboardResponse(rsp)
}

func (c *ClientWithResponses) CreateWhiteboardWithResponse(ctx context.Context, params *CreateWhiteboardParams, body CreateWhiteboardJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateWhiteboardResponse, error) {
	rsp, err := c.CreateWhiteboard(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateWhiteboardResponse(rsp)
}

// DeleteWhiteboardWithResponse request returning *DeleteWhiteboardResponse
func (c *ClientWithResponses) DeleteWhiteboardWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*DeleteWhiteboardResponse, error) {
	rsp, err := c.DeleteWhiteboard(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteWhiteboardResponse(rsp)
}

// GetWhiteboardByIdWithResponse request returning *GetWhiteboardByIdResponse
func (c *ClientWithResponses) GetWhiteboardByIdWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetWhiteboardByIdResponse, error) {
	rsp, err := c.GetWhiteboardById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWhiteboardByIdResponse(rsp)
}

// GetWhiteboardAncestorsWithResponse request returning *GetWhiteboardAncestorsResponse
func (c *ClientWithResponses) GetWhiteboardAncestorsWithResponse(ctx context.Context, id int64, params *GetWhiteboardAncestorsParams, reqEditors ...RequestEditorFn) (*GetWhiteboardAncestorsResponse, error) {
	rsp, err := c.GetWhiteboardAncestors(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWhiteboardAncestorsResponse(rsp)
}

// GetWhiteboardClassificationLevelWithResponse request returning *GetWhiteboardClassificationLevelResponse
func (c *ClientWithResponses) GetWhiteboardClassificationLevelWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetWhiteboardClassificationLevelResponse, error) {
	rsp, err := c.GetWhiteboardClassificationLevel(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWhiteboardClassificationLevelResponse(rsp)
}

// PutWhiteboardClassificationLevelWithBodyWithResponse request with arbitrary body returning *PutWhiteboardClassificationLevelResponse
func (c *ClientWithResponses) PutWhiteboardClassificationLevelWithBodyWithResponse(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutWhiteboardClassificationLevelResponse, error) {
	rsp, err := c.PutWhiteboardClassificationLevelWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutWhiteboardClassificationLevelResponse(rsp)
}

func (c *ClientWithResponses) PutWhiteboardClassificationLevelWithResponse(ctx context.Context, id int64, body PutWhiteboardClassificationLevelJSONRequestBody, reqEditors ...RequestEditorFn) (*PutWhiteboardClassificationLevelResponse, error) {
	rsp, err := c.PutWhiteboardClassificationLevel(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutWhiteboardClassificationLevelResponse(rsp)
}

// PostWhiteboardClassificationLevelWithBodyWithResponse request with arbitrary body returning *PostWhiteboardClassificationLevelResponse
func (c *ClientWithResponses) PostWhiteboardClassificationLevelWithBodyWithResponse(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostWhiteboardClassificationLevelResponse, error) {
	rsp, err := c.PostWhiteboardClassificationLevelWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostWhiteboardClassificationLevelResponse(rsp)
}

func (c *ClientWithResponses) PostWhiteboardClassificationLevelWithResponse(ctx context.Context, id int64, body PostWhiteboardClassificationLevelJSONRequestBody, reqEditors ...RequestEditorFn) (*PostWhiteboardClassificationLevelResponse, error) {
	rsp, err := c.PostWhiteboardClassificationLevel(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostWhiteboardClassificationLevelResponse(rsp)
}

// GetWhiteboardOperationsWithResponse request returning *GetWhiteboardOperationsResponse
func (c *ClientWithResponses) GetWhiteboardOperationsWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetWhiteboardOperationsResponse, error) {
	rsp, err := c.GetWhiteboardOperations(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWhiteboardOperationsResponse(rsp)
}

// GetWhiteboardContentPropertiesWithResponse request returning *GetWhiteboardContentPropertiesResponse
func (c *ClientWithResponses) GetWhiteboardContentPropertiesWithResponse(ctx context.Context, id int64, params *GetWhiteboardContentPropertiesParams, reqEditors ...RequestEditorFn) (*GetWhiteboardContentPropertiesResponse, error) {
	rsp, err := c.GetWhiteboardContentProperties(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWhiteboardContentPropertiesResponse(rsp)
}

// CreateWhiteboardPropertyWithBodyWithResponse request with arbitrary body returning *CreateWhiteboardPropertyResponse
func (c *ClientWithResponses) CreateWhiteboardPropertyWithBodyWithResponse(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateWhiteboardPropertyResponse, error) {
	rsp, err := c.CreateWhiteboardPropertyWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateWhiteboardPropertyResponse(rsp)
}

func (c *ClientWithResponses) CreateWhiteboardPropertyWithResponse(ctx context.Context, id int64, body CreateWhiteboardPropertyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateWhiteboardPropertyResponse, error) {
	rsp, err := c.CreateWhiteboardProperty(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateWhiteboardPropertyResponse(rsp)
}

// DeleteWhiteboardPropertyByIdWithResponse request returning *DeleteWhiteboardPropertyByIdResponse
func (c *ClientWithResponses) DeleteWhiteboardPropertyByIdWithResponse(ctx context.Context, whiteboardId int64, propertyId int64, reqEditors ...RequestEditorFn) (*DeleteWhiteboardPropertyByIdResponse, error) {
	rsp, err := c.DeleteWhiteboardPropertyById(ctx, whiteboardId, propertyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteWhiteboardPropertyByIdResponse(rsp)
}

// GetWhiteboardContentPropertiesByIdWithResponse request returning *GetWhiteboardContentPropertiesByIdResponse
func (c *ClientWithResponses) GetWhiteboardContentPropertiesByIdWithResponse(ctx context.Context, whiteboardId int64, propertyId int64, reqEditors ...RequestEditorFn) (*GetWhiteboardContentPropertiesByIdResponse, error) {
	rsp, err := c.GetWhiteboardContentPropertiesById(ctx, whiteboardId, propertyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWhiteboardContentPropertiesByIdResponse(rsp)
}

// UpdateWhiteboardPropertyByIdWithBodyWithResponse request with arbitrary body returning *UpdateWhiteboardPropertyByIdResponse
func (c *ClientWithResponses) UpdateWhiteboardPropertyByIdWithBodyWithResponse(ctx context.Context, whiteboardId int64, propertyId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateWhiteboardPropertyByIdResponse, error) {
	rsp, err := c.UpdateWhiteboardPropertyByIdWithBody(ctx, whiteboardId, propertyId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateWhiteboardPropertyByIdResponse(rsp)
}

func (c *ClientWithResponses) UpdateWhiteboardPropertyByIdWithResponse(ctx context.Context, whiteboardId int64, propertyId int64, body UpdateWhiteboardPropertyByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateWhiteboardPropertyByIdResponse, error) {
	rsp, err := c.UpdateWhiteboardPropertyById(ctx, whiteboardId, propertyId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateWhiteboardPropertyByIdResponse(rsp)
}

// ParseGetAttachmentsResponse parses an HTTP response from a GetAttachmentsWithResponse call
func ParseGetAttachmentsResponse(rsp *http.Response) (*GetAttachmentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAttachmentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Links   *MultiEntityLinks `json:"_links,omitempty"`
			Results *[]AttachmentBulk `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAttachmentContentPropertiesResponse parses an HTTP response from a GetAttachmentContentPropertiesWithResponse call
func ParseGetAttachmentContentPropertiesResponse(rsp *http.Response) (*GetAttachmentContentPropertiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAttachmentContentPropertiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Links   *MultiEntityLinks  `json:"_links,omitempty"`
			Results *[]ContentProperty `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateAttachmentPropertyResponse parses an HTTP response from a CreateAttachmentPropertyWithResponse call
func ParseCreateAttachmentPropertyResponse(rsp *http.Response) (*CreateAttachmentPropertyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAttachmentPropertyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ContentProperty
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteAttachmentPropertyByIdResponse parses an HTTP response from a DeleteAttachmentPropertyByIdWithResponse call
func ParseDeleteAttachmentPropertyByIdResponse(rsp *http.Response) (*DeleteAttachmentPropertyByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAttachmentPropertyByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetAttachmentContentPropertiesByIdResponse parses an HTTP response from a GetAttachmentContentPropertiesByIdWithResponse call
func ParseGetAttachmentContentPropertiesByIdResponse(rsp *http.Response) (*GetAttachmentContentPropertiesByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAttachmentContentPropertiesByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ContentProperty
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateAttachmentPropertyByIdResponse parses an HTTP response from a UpdateAttachmentPropertyByIdWithResponse call
func ParseUpdateAttachmentPropertyByIdResponse(rsp *http.Response) (*UpdateAttachmentPropertyByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAttachmentPropertyByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ContentProperty
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAttachmentVersionDetailsResponse parses an HTTP response from a GetAttachmentVersionDetailsWithResponse call
func ParseGetAttachmentVersionDetailsResponse(rsp *http.Response) (*GetAttachmentVersionDetailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAttachmentVersionDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DetailedVersion
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteAttachmentResponse parses an HTTP response from a DeleteAttachmentWithResponse call
func ParseDeleteAttachmentResponse(rsp *http.Response) (*DeleteAttachmentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAttachmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetAttachmentByIdResponse parses an HTTP response from a GetAttachmentByIdWithResponse call
func ParseGetAttachmentByIdResponse(rsp *http.Response) (*GetAttachmentByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAttachmentByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Links *struct {
				// Base Base url of the Confluence site.
				Base *string `json:"base,omitempty"`
			} `json:"_links,omitempty"`

			// BlogPostId ID of the containing blog post.
			//
			// Note: This is only returned if the attachment has a container that is a blog post.
			BlogPostId *string `json:"blogPostId,omitempty"`

			// Comment Comment for the attachment.
			Comment *string `json:"comment,omitempty"`

			// CreatedAt Date and time when the attachment was created. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
			CreatedAt *time.Time `json:"createdAt,omitempty"`

			// CustomContentId ID of the containing custom content.
			//
			// Note: This is only returned if the attachment has a container that is custom content.
			CustomContentId *string `json:"customContentId,omitempty"`

			// DownloadLink Download link of the attachment.
			DownloadLink *string `json:"downloadLink,omitempty"`

			// FileId File ID of the attachment. This is the ID referenced in `atlas_doc_format` bodies and is distinct from the attachment ID.
			FileId *string `json:"fileId,omitempty"`

			// FileSize File size of the attachment.
			FileSize *int64 `json:"fileSize,omitempty"`

			// Id ID of the attachment.
			Id     *string `json:"id,omitempty"`
			Labels *struct {
				Links   *OptionalFieldLinks `json:"_links,omitempty"`
				Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
				Results *[]Label            `json:"results,omitempty"`
			} `json:"labels,omitempty"`

			// MediaType Media Type for the attachment.
			MediaType *string `json:"mediaType,omitempty"`

			// MediaTypeDescription Media Type description for the attachment.
			MediaTypeDescription *string `json:"mediaTypeDescription,omitempty"`
			Operations           *struct {
				Links   *OptionalFieldLinks `json:"_links,omitempty"`
				Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
				Results *[]Operation        `json:"results,omitempty"`
			} `json:"operations,omitempty"`

			// PageId ID of the containing page.
			//
			// Note: This is only returned if the attachment has a container that is a page.
			PageId     *string `json:"pageId,omitempty"`
			Properties *struct {
				Links   *OptionalFieldLinks `json:"_links,omitempty"`
				Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
				Results *[]ContentProperty  `json:"results,omitempty"`
			} `json:"properties,omitempty"`

			// Status The status of the content.
			Status *ContentStatus `json:"status,omitempty"`

			// Title Title of the comment.
			Title    *string  `json:"title,omitempty"`
			Version  *Version `json:"version,omitempty"`
			Versions *struct {
				Links   *OptionalFieldLinks `json:"_links,omitempty"`
				Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
				Results *[]Version          `json:"results,omitempty"`
			} `json:"versions,omitempty"`

			// WebuiLink WebUI link of the attachment.
			WebuiLink *string `json:"webuiLink,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAttachmentCommentsResponse parses an HTTP response from a GetAttachmentCommentsWithResponse call
func ParseGetAttachmentCommentsResponse(rsp *http.Response) (*GetAttachmentCommentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAttachmentCommentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Links   *MultiEntityLinks         `json:"_links,omitempty"`
			Results *[]AttachmentCommentModel `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAttachmentLabelsResponse parses an HTTP response from a GetAttachmentLabelsWithResponse call
func ParseGetAttachmentLabelsResponse(rsp *http.Response) (*GetAttachmentLabelsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAttachmentLabelsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Links   *MultiEntityLinks `json:"_links,omitempty"`
			Results *[]Label          `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAttachmentOperationsResponse parses an HTTP response from a GetAttachmentOperationsWithResponse call
func ParseGetAttachmentOperationsResponse(rsp *http.Response) (*GetAttachmentOperationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAttachmentOperationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PermittedOperationsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAttachmentVersionsResponse parses an HTTP response from a GetAttachmentVersionsWithResponse call
func ParseGetAttachmentVersionsResponse(rsp *http.Response) (*GetAttachmentVersionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAttachmentVersionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Links   *MultiEntityLinks    `json:"_links,omitempty"`
			Results *[]AttachmentVersion `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetBlogPostsResponse parses an HTTP response from a GetBlogPostsWithResponse call
func ParseGetBlogPostsResponse(rsp *http.Response) (*GetBlogPostsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBlogPostsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Links   *MultiEntityLinks `json:"_links,omitempty"`
			Results *[]BlogPostBulk   `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateBlogPostResponse parses an HTTP response from a CreateBlogPostWithResponse call
func ParseCreateBlogPostResponse(rsp *http.Response) (*CreateBlogPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateBlogPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Links *struct {
				// Base Base url of the Confluence site.
				Base *string `json:"base,omitempty"`
			} `json:"_links,omitempty"`

			// AuthorId The account ID of the user who created this blog post originally.
			AuthorId *string `json:"authorId,omitempty"`

			// Body Contains fields for each representation type requested.
			Body *BodySingle `json:"body,omitempty"`

			// CreatedAt Date and time when the blog post was created. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
			CreatedAt *time.Time `json:"createdAt,omitempty"`

			// Id ID of the blog post.
			Id *string `json:"id,omitempty"`

			// IsFavoritedByCurrentUser Whether the blog post has been favorited by the current user.
			IsFavoritedByCurrentUser *bool `json:"isFavoritedByCurrentUser,omitempty"`
			Labels                   *struct {
				Links   *OptionalFieldLinks `json:"_links,omitempty"`
				Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
				Results *[]Label            `json:"results,omitempty"`
			} `json:"labels,omitempty"`
			Likes *struct {
				Links   *OptionalFieldLinks `json:"_links,omitempty"`
				Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
				Results *[]Like             `json:"results,omitempty"`
			} `json:"likes,omitempty"`
			Operations *struct {
				Links   *OptionalFieldLinks `json:"_links,omitempty"`
				Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
				Results *[]Operation        `json:"results,omitempty"`
			} `json:"operations,omitempty"`
			Properties *struct {
				Links   *OptionalFieldLinks `json:"_links,omitempty"`
				Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
				Results *[]ContentProperty  `json:"results,omitempty"`
			} `json:"properties,omitempty"`

			// SpaceId ID of the space the blog post is in.
			SpaceId *string `json:"spaceId,omitempty"`

			// Status The status of the content.
			Status *BlogPostContentStatus `json:"status,omitempty"`

			// Title Title of the blog post.
			Title    *string  `json:"title,omitempty"`
			Version  *Version `json:"version,omitempty"`
			Versions *struct {
				Links   *OptionalFieldLinks `json:"_links,omitempty"`
				Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
				Results *[]Version          `json:"results,omitempty"`
			} `json:"versions,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetBlogpostContentPropertiesResponse parses an HTTP response from a GetBlogpostContentPropertiesWithResponse call
func ParseGetBlogpostContentPropertiesResponse(rsp *http.Response) (*GetBlogpostContentPropertiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBlogpostContentPropertiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Links   *MultiEntityLinks  `json:"_links,omitempty"`
			Results *[]ContentProperty `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateBlogpostPropertyResponse parses an HTTP response from a CreateBlogpostPropertyWithResponse call
func ParseCreateBlogpostPropertyResponse(rsp *http.Response) (*CreateBlogpostPropertyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateBlogpostPropertyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ContentProperty
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteBlogpostPropertyByIdResponse parses an HTTP response from a DeleteBlogpostPropertyByIdWithResponse call
func ParseDeleteBlogpostPropertyByIdResponse(rsp *http.Response) (*DeleteBlogpostPropertyByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteBlogpostPropertyByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetBlogpostContentPropertiesByIdResponse parses an HTTP response from a GetBlogpostContentPropertiesByIdWithResponse call
func ParseGetBlogpostContentPropertiesByIdResponse(rsp *http.Response) (*GetBlogpostContentPropertiesByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBlogpostContentPropertiesByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ContentProperty
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateBlogpostPropertyByIdResponse parses an HTTP response from a UpdateBlogpostPropertyByIdWithResponse call
func ParseUpdateBlogpostPropertyByIdResponse(rsp *http.Response) (*UpdateBlogpostPropertyByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateBlogpostPropertyByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ContentProperty
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetBlogPostVersionDetailsResponse parses an HTTP response from a GetBlogPostVersionDetailsWithResponse call
func ParseGetBlogPostVersionDetailsResponse(rsp *http.Response) (*GetBlogPostVersionDetailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBlogPostVersionDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DetailedVersion
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteBlogPostResponse parses an HTTP response from a DeleteBlogPostWithResponse call
func ParseDeleteBlogPostResponse(rsp *http.Response) (*DeleteBlogPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteBlogPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetBlogPostByIdResponse parses an HTTP response from a GetBlogPostByIdWithResponse call
func ParseGetBlogPostByIdResponse(rsp *http.Response) (*GetBlogPostByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBlogPostByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Links *struct {
				// Base Base url of the Confluence site.
				Base *string `json:"base,omitempty"`
			} `json:"_links,omitempty"`

			// AuthorId The account ID of the user who created this blog post originally.
			AuthorId *string `json:"authorId,omitempty"`

			// Body Contains fields for each representation type requested.
			Body *BodySingle `json:"body,omitempty"`

			// CreatedAt Date and time when the blog post was created. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
			CreatedAt *time.Time `json:"createdAt,omitempty"`

			// Id ID of the blog post.
			Id *string `json:"id,omitempty"`

			// IsFavoritedByCurrentUser Whether the blog post has been favorited by the current user.
			IsFavoritedByCurrentUser *bool `json:"isFavoritedByCurrentUser,omitempty"`
			Labels                   *struct {
				Links   *OptionalFieldLinks `json:"_links,omitempty"`
				Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
				Results *[]Label            `json:"results,omitempty"`
			} `json:"labels,omitempty"`
			Likes *struct {
				Links   *OptionalFieldLinks `json:"_links,omitempty"`
				Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
				Results *[]Like             `json:"results,omitempty"`
			} `json:"likes,omitempty"`
			Operations *struct {
				Links   *OptionalFieldLinks `json:"_links,omitempty"`
				Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
				Results *[]Operation        `json:"results,omitempty"`
			} `json:"operations,omitempty"`
			Properties *struct {
				Links   *OptionalFieldLinks `json:"_links,omitempty"`
				Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
				Results *[]ContentProperty  `json:"results,omitempty"`
			} `json:"properties,omitempty"`

			// SpaceId ID of the space the blog post is in.
			SpaceId *string `json:"spaceId,omitempty"`

			// Status The status of the content.
			Status *BlogPostContentStatus `json:"status,omitempty"`

			// Title Title of the blog post.
			Title    *string  `json:"title,omitempty"`
			Version  *Version `json:"version,omitempty"`
			Versions *struct {
				Links   *OptionalFieldLinks `json:"_links,omitempty"`
				Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
				Results *[]Version          `json:"results,omitempty"`
			} `json:"versions,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateBlogPostResponse parses an HTTP response from a UpdateBlogPostWithResponse call
func ParseUpdateBlogPostResponse(rsp *http.Response) (*UpdateBlogPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateBlogPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Links *struct {
				// Base Base url of the Confluence site.
				Base *string `json:"base,omitempty"`
			} `json:"_links,omitempty"`

			// AuthorId The account ID of the user who created this blog post originally.
			AuthorId *string `json:"authorId,omitempty"`

			// Body Contains fields for each representation type requested.
			Body *BodySingle `json:"body,omitempty"`

			// CreatedAt Date and time when the blog post was created. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
			CreatedAt *time.Time `json:"createdAt,omitempty"`

			// Id ID of the blog post.
			Id *string `json:"id,omitempty"`

			// IsFavoritedByCurrentUser Whether the blog post has been favorited by the current user.
			IsFavoritedByCurrentUser *bool `json:"isFavoritedByCurrentUser,omitempty"`
			Labels                   *struct {
				Links   *OptionalFieldLinks `json:"_links,omitempty"`
				Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
				Results *[]Label            `json:"results,omitempty"`
			} `json:"labels,omitempty"`
			Likes *struct {
				Links   *OptionalFieldLinks `json:"_links,omitempty"`
				Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
				Results *[]Like             `json:"results,omitempty"`
			} `json:"likes,omitempty"`
			Operations *struct {
				Links   *OptionalFieldLinks `json:"_links,omitempty"`
				Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
				Results *[]Operation        `json:"results,omitempty"`
			} `json:"operations,omitempty"`
			Properties *struct {
				Links   *OptionalFieldLinks `json:"_links,omitempty"`
				Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
				Results *[]ContentProperty  `json:"results,omitempty"`
			} `json:"properties,omitempty"`

			// SpaceId ID of the space the blog post is in.
			SpaceId *string `json:"spaceId,omitempty"`

			// Status The status of the content.
			Status *BlogPostContentStatus `json:"status,omitempty"`

			// Title Title of the blog post.
			Title    *string  `json:"title,omitempty"`
			Version  *Version `json:"version,omitempty"`
			Versions *struct {
				Links   *OptionalFieldLinks `json:"_links,omitempty"`
				Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
				Results *[]Version          `json:"results,omitempty"`
			} `json:"versions,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetBlogpostAttachmentsResponse parses an HTTP response from a GetBlogpostAttachmentsWithResponse call
func ParseGetBlogpostAttachmentsResponse(rsp *http.Response) (*GetBlogpostAttachmentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBlogpostAttachmentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Links   *MultiEntityLinks `json:"_links,omitempty"`
			Results *[]AttachmentBulk `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetBlogPostClassificationLevelResponse parses an HTTP response from a GetBlogPostClassificationLevelWithResponse call
func ParseGetBlogPostClassificationLevelResponse(rsp *http.Response) (*GetBlogPostClassificationLevelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBlogPostClassificationLevelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ClassificationLevel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePutBlogPostClassificationLevelResponse parses an HTTP response from a PutBlogPostClassificationLevelWithResponse call
func ParsePutBlogPostClassificationLevelResponse(rsp *http.Response) (*PutBlogPostClassificationLevelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutBlogPostClassificationLevelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePostBlogPostClassificationLevelResponse parses an HTTP response from a PostBlogPostClassificationLevelWithResponse call
func ParsePostBlogPostClassificationLevelResponse(rsp *http.Response) (*PostBlogPostClassificationLevelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostBlogPostClassificationLevelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetCustomContentByTypeInBlogPostResponse parses an HTTP response from a GetCustomContentByTypeInBlogPostWithResponse call
func ParseGetCustomContentByTypeInBlogPostResponse(rsp *http.Response) (*GetCustomContentByTypeInBlogPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCustomContentByTypeInBlogPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Links   *MultiEntityLinks    `json:"_links,omitempty"`
			Results *[]CustomContentBulk `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetBlogPostFooterCommentsResponse parses an HTTP response from a GetBlogPostFooterCommentsWithResponse call
func ParseGetBlogPostFooterCommentsResponse(rsp *http.Response) (*GetBlogPostFooterCommentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBlogPostFooterCommentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Links   *MultiEntityLinks       `json:"_links,omitempty"`
			Results *[]BlogPostCommentModel `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetBlogPostInlineCommentsResponse parses an HTTP response from a GetBlogPostInlineCommentsWithResponse call
func ParseGetBlogPostInlineCommentsResponse(rsp *http.Response) (*GetBlogPostInlineCommentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBlogPostInlineCommentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Links   *MultiEntityLinks             `json:"_links,omitempty"`
			Results *[]BlogPostInlineCommentModel `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetBlogPostLabelsResponse parses an HTTP response from a GetBlogPostLabelsWithResponse call
func ParseGetBlogPostLabelsResponse(rsp *http.Response) (*GetBlogPostLabelsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBlogPostLabelsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Links   *MultiEntityLinks `json:"_links,omitempty"`
			Results *[]Label          `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetBlogPostLikeCountResponse parses an HTTP response from a GetBlogPostLikeCountWithResponse call
func ParseGetBlogPostLikeCountResponse(rsp *http.Response) (*GetBlogPostLikeCountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBlogPostLikeCountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count The count number
			Count *int64 `json:"count,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetBlogPostLikeUsersResponse parses an HTTP response from a GetBlogPostLikeUsersWithResponse call
func ParseGetBlogPostLikeUsersResponse(rsp *http.Response) (*GetBlogPostLikeUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBlogPostLikeUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Links   *MultiEntityLinks `json:"_links,omitempty"`
			Results *[]Like           `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetBlogPostOperationsResponse parses an HTTP response from a GetBlogPostOperationsWithResponse call
func ParseGetBlogPostOperationsResponse(rsp *http.Response) (*GetBlogPostOperationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBlogPostOperationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PermittedOperationsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetBlogPostVersionsResponse parses an HTTP response from a GetBlogPostVersionsWithResponse call
func ParseGetBlogPostVersionsResponse(rsp *http.Response) (*GetBlogPostVersionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBlogPostVersionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Links   *MultiEntityLinks  `json:"_links,omitempty"`
			Results *[]BlogPostVersion `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetClassificationLevelsResponse parses an HTTP response from a GetClassificationLevelsWithResponse call
func ParseGetClassificationLevelsResponse(rsp *http.Response) (*GetClassificationLevelsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClassificationLevelsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ClassificationLevel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetCommentContentPropertiesResponse parses an HTTP response from a GetCommentContentPropertiesWithResponse call
func ParseGetCommentContentPropertiesResponse(rsp *http.Response) (*GetCommentContentPropertiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCommentContentPropertiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Links   *MultiEntityLinks  `json:"_links,omitempty"`
			Results *[]ContentProperty `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateCommentPropertyResponse parses an HTTP response from a CreateCommentPropertyWithResponse call
func ParseCreateCommentPropertyResponse(rsp *http.Response) (*CreateCommentPropertyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateCommentPropertyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ContentProperty
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteCommentPropertyByIdResponse parses an HTTP response from a DeleteCommentPropertyByIdWithResponse call
func ParseDeleteCommentPropertyByIdResponse(rsp *http.Response) (*DeleteCommentPropertyByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCommentPropertyByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetCommentContentPropertiesByIdResponse parses an HTTP response from a GetCommentContentPropertiesByIdWithResponse call
func ParseGetCommentContentPropertiesByIdResponse(rsp *http.Response) (*GetCommentContentPropertiesByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCommentContentPropertiesByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ContentProperty
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateCommentPropertyByIdResponse parses an HTTP response from a UpdateCommentPropertyByIdWithResponse call
func ParseUpdateCommentPropertyByIdResponse(rsp *http.Response) (*UpdateCommentPropertyByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateCommentPropertyByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ContentProperty
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseConvertContentIdsToContentTypesResponse parses an HTTP response from a ConvertContentIdsToContentTypesWithResponse call
func ParseConvertContentIdsToContentTypesResponse(rsp *http.Response) (*ConvertContentIdsToContentTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ConvertContentIdsToContentTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ContentIdToContentTypeResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetCustomContentByTypeResponse parses an HTTP response from a GetCustomContentByTypeWithResponse call
func ParseGetCustomContentByTypeResponse(rsp *http.Response) (*GetCustomContentByTypeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCustomContentByTypeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Links   *MultiEntityLinks    `json:"_links,omitempty"`
			Results *[]CustomContentBulk `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateCustomContentResponse parses an HTTP response from a CreateCustomContentWithResponse call
func ParseCreateCustomContentResponse(rsp *http.Response) (*CreateCustomContentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateCustomContentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Links *struct {
				// Base Base url of the Confluence site.
				Base *string `json:"base,omitempty"`
			} `json:"_links,omitempty"`

			// AuthorId The account ID of the user who created this custom content originally.
			AuthorId *string `json:"authorId,omitempty"`

			// BlogPostId ID of the containing blog post.
			//
			// Note: This is only returned if the custom content has a container that is a blog post.
			BlogPostId *string `json:"blogPostId,omitempty"`

			// Body Contains fields for each representation type requested.
			Body *CustomContentBodySingle `json:"body,omitempty"`

			// CreatedAt Date and time when the custom content was created. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
			CreatedAt *time.Time `json:"createdAt,omitempty"`

			// CustomContentId ID of the containing custom content.
			//
			// Note: This is only returned if the custom content has a container that is custom content.
			CustomContentId *string `json:"customContentId,omitempty"`

			// Id ID of the custom content.
			Id     *string `json:"id,omitempty"`
			Labels *struct {
				Links   *OptionalFieldLinks `json:"_links,omitempty"`
				Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
				Results *[]Label            `json:"results,omitempty"`
			} `json:"labels,omitempty"`
			Operations *struct {
				Links   *OptionalFieldLinks `json:"_links,omitempty"`
				Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
				Results *[]Operation        `json:"results,omitempty"`
			} `json:"operations,omitempty"`

			// PageId ID of the containing page.
			//
			// Note: This is only returned if the custom content has a container that is a page.
			PageId     *string `json:"pageId,omitempty"`
			Properties *struct {
				Links   *OptionalFieldLinks `json:"_links,omitempty"`
				Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
				Results *[]ContentProperty  `json:"results,omitempty"`
			} `json:"properties,omitempty"`

			// SpaceId ID of the space the custom content is in.
			//
			// Note: This is always returned, regardless of if the custom content has a container that is a space.
			SpaceId *string `json:"spaceId,omitempty"`

			// Status The status of the content.
			Status *ContentStatus `json:"status,omitempty"`

			// Title Title of the custom content.
			Title *string `json:"title,omitempty"`

			// Type The type of custom content.
			Type     *string  `json:"type,omitempty"`
			Version  *Version `json:"version,omitempty"`
			Versions *struct {
				Links   *OptionalFieldLinks `json:"_links,omitempty"`
				Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
				Results *[]Version          `json:"results,omitempty"`
			} `json:"versions,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseGetCustomContentContentPropertiesResponse parses an HTTP response from a GetCustomContentContentPropertiesWithResponse call
func ParseGetCustomContentContentPropertiesResponse(rsp *http.Response) (*GetCustomContentContentPropertiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCustomContentContentPropertiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Links   *MultiEntityLinks  `json:"_links,omitempty"`
			Results *[]ContentProperty `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateCustomContentPropertyResponse parses an HTTP response from a CreateCustomContentPropertyWithResponse call
func ParseCreateCustomContentPropertyResponse(rsp *http.Response) (*CreateCustomContentPropertyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateCustomContentPropertyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ContentProperty
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteCustomContentPropertyByIdResponse parses an HTTP response from a DeleteCustomContentPropertyByIdWithResponse call
func ParseDeleteCustomContentPropertyByIdResponse(rsp *http.Response) (*DeleteCustomContentPropertyByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCustomContentPropertyByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetCustomContentContentPropertiesByIdResponse parses an HTTP response from a GetCustomContentContentPropertiesByIdWithResponse call
func ParseGetCustomContentContentPropertiesByIdResponse(rsp *http.Response) (*GetCustomContentContentPropertiesByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCustomContentContentPropertiesByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ContentProperty
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateCustomContentPropertyByIdResponse parses an HTTP response from a UpdateCustomContentPropertyByIdWithResponse call
func ParseUpdateCustomContentPropertyByIdResponse(rsp *http.Response) (*UpdateCustomContentPropertyByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateCustomContentPropertyByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ContentProperty
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetCustomContentVersionsResponse parses an HTTP response from a GetCustomContentVersionsWithResponse call
func ParseGetCustomContentVersionsResponse(rsp *http.Response) (*GetCustomContentVersionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCustomContentVersionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Links   *MultiEntityLinks       `json:"_links,omitempty"`
			Results *[]CustomContentVersion `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetCustomContentVersionDetailsResponse parses an HTTP response from a GetCustomContentVersionDetailsWithResponse call
func ParseGetCustomContentVersionDetailsResponse(rsp *http.Response) (*GetCustomContentVersionDetailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCustomContentVersionDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DetailedVersion
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteCustomContentResponse parses an HTTP response from a DeleteCustomContentWithResponse call
func ParseDeleteCustomContentResponse(rsp *http.Response) (*DeleteCustomContentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCustomContentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetCustomContentByIdResponse parses an HTTP response from a GetCustomContentByIdWithResponse call
func ParseGetCustomContentByIdResponse(rsp *http.Response) (*GetCustomContentByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCustomContentByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Links *struct {
				// Base Base url of the Confluence site.
				Base *string `json:"base,omitempty"`
			} `json:"_links,omitempty"`

			// AuthorId The account ID of the user who created this custom content originally.
			AuthorId *string `json:"authorId,omitempty"`

			// BlogPostId ID of the containing blog post.
			//
			// Note: This is only returned if the custom content has a container that is a blog post.
			BlogPostId *string `json:"blogPostId,omitempty"`

			// Body Contains fields for each representation type requested.
			Body *CustomContentBodySingle `json:"body,omitempty"`

			// CreatedAt Date and time when the custom content was created. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
			CreatedAt *time.Time `json:"createdAt,omitempty"`

			// CustomContentId ID of the containing custom content.
			//
			// Note: This is only returned if the custom content has a container that is custom content.
			CustomContentId *string `json:"customContentId,omitempty"`

			// Id ID of the custom content.
			Id     *string `json:"id,omitempty"`
			Labels *struct {
				Links   *OptionalFieldLinks `json:"_links,omitempty"`
				Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
				Results *[]Label            `json:"results,omitempty"`
			} `json:"labels,omitempty"`
			Operations *struct {
				Links   *OptionalFieldLinks `json:"_links,omitempty"`
				Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
				Results *[]Operation        `json:"results,omitempty"`
			} `json:"operations,omitempty"`

			// PageId ID of the containing page.
			//
			// Note: This is only returned if the custom content has a container that is a page.
			PageId     *string `json:"pageId,omitempty"`
			Properties *struct {
				Links   *OptionalFieldLinks `json:"_links,omitempty"`
				Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
				Results *[]ContentProperty  `json:"results,omitempty"`
			} `json:"properties,omitempty"`

			// SpaceId ID of the space the custom content is in.
			//
			// Note: This is always returned, regardless of if the custom content has a container that is a space.
			SpaceId *string `json:"spaceId,omitempty"`

			// Status The status of the content.
			Status *ContentStatus `json:"status,omitempty"`

			// Title Title of the custom content.
			Title *string `json:"title,omitempty"`

			// Type The type of custom content.
			Type     *string  `json:"type,omitempty"`
			Version  *Version `json:"version,omitempty"`
			Versions *struct {
				Links   *OptionalFieldLinks `json:"_links,omitempty"`
				Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
				Results *[]Version          `json:"results,omitempty"`
			} `json:"versions,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateCustomContentResponse parses an HTTP response from a UpdateCustomContentWithResponse call
func ParseUpdateCustomContentResponse(rsp *http.Response) (*UpdateCustomContentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateCustomContentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Links *struct {
				// Base Base url of the Confluence site.
				Base *string `json:"base,omitempty"`
			} `json:"_links,omitempty"`

			// AuthorId The account ID of the user who created this custom content originally.
			AuthorId *string `json:"authorId,omitempty"`

			// BlogPostId ID of the containing blog post.
			//
			// Note: This is only returned if the custom content has a container that is a blog post.
			BlogPostId *string `json:"blogPostId,omitempty"`

			// Body Contains fields for each representation type requested.
			Body *CustomContentBodySingle `json:"body,omitempty"`

			// CreatedAt Date and time when the custom content was created. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
			CreatedAt *time.Time `json:"createdAt,omitempty"`

			// CustomContentId ID of the containing custom content.
			//
			// Note: This is only returned if the custom content has a container that is custom content.
			CustomContentId *string `json:"customContentId,omitempty"`

			// Id ID of the custom content.
			Id     *string `json:"id,omitempty"`
			Labels *struct {
				Links   *OptionalFieldLinks `json:"_links,omitempty"`
				Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
				Results *[]Label            `json:"results,omitempty"`
			} `json:"labels,omitempty"`
			Operations *struct {
				Links   *OptionalFieldLinks `json:"_links,omitempty"`
				Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
				Results *[]Operation        `json:"results,omitempty"`
			} `json:"operations,omitempty"`

			// PageId ID of the containing page.
			//
			// Note: This is only returned if the custom content has a container that is a page.
			PageId     *string `json:"pageId,omitempty"`
			Properties *struct {
				Links   *OptionalFieldLinks `json:"_links,omitempty"`
				Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
				Results *[]ContentProperty  `json:"results,omitempty"`
			} `json:"properties,omitempty"`

			// SpaceId ID of the space the custom content is in.
			//
			// Note: This is always returned, regardless of if the custom content has a container that is a space.
			SpaceId *string `json:"spaceId,omitempty"`

			// Status The status of the content.
			Status *ContentStatus `json:"status,omitempty"`

			// Title Title of the custom content.
			Title *string `json:"title,omitempty"`

			// Type The type of custom content.
			Type     *string  `json:"type,omitempty"`
			Version  *Version `json:"version,omitempty"`
			Versions *struct {
				Links   *OptionalFieldLinks `json:"_links,omitempty"`
				Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
				Results *[]Version          `json:"results,omitempty"`
			} `json:"versions,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetCustomContentAttachmentsResponse parses an HTTP response from a GetCustomContentAttachmentsWithResponse call
func ParseGetCustomContentAttachmentsResponse(rsp *http.Response) (*GetCustomContentAttachmentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCustomContentAttachmentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Links   *MultiEntityLinks `json:"_links,omitempty"`
			Results *[]AttachmentBulk `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetChildCustomContentResponse parses an HTTP response from a GetChildCustomContentWithResponse call
func ParseGetChildCustomContentResponse(rsp *http.Response) (*GetChildCustomContentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetChildCustomContentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Links   *MultiEntityLinks     `json:"_links,omitempty"`
			Results *[]ChildCustomContent `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetCustomContentCommentsResponse parses an HTTP response from a GetCustomContentCommentsWithResponse call
func ParseGetCustomContentCommentsResponse(rsp *http.Response) (*GetCustomContentCommentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCustomContentCommentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Links   *MultiEntityLinks            `json:"_links,omitempty"`
			Results *[]CustomContentCommentModel `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetCustomContentLabelsResponse parses an HTTP response from a GetCustomContentLabelsWithResponse call
func ParseGetCustomContentLabelsResponse(rsp *http.Response) (*GetCustomContentLabelsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCustomContentLabelsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Links   *MultiEntityLinks `json:"_links,omitempty"`
			Results *[]Label          `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetCustomContentOperationsResponse parses an HTTP response from a GetCustomContentOperationsWithResponse call
func ParseGetCustomContentOperationsResponse(rsp *http.Response) (*GetCustomContentOperationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCustomContentOperationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PermittedOperationsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetDataPolicyMetadataResponse parses an HTTP response from a GetDataPolicyMetadataWithResponse call
func ParseGetDataPolicyMetadataResponse(rsp *http.Response) (*GetDataPolicyMetadataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDataPolicyMetadataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DataPolicyMetadata
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetDataPolicySpacesResponse parses an HTTP response from a GetDataPolicySpacesWithResponse call
func ParseGetDataPolicySpacesResponse(rsp *http.Response) (*GetDataPolicySpacesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDataPolicySpacesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Links   *MultiEntityLinks  `json:"_links,omitempty"`
			Results *[]DataPolicySpace `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateDatabaseResponse parses an HTTP response from a CreateDatabaseWithResponse call
func ParseCreateDatabaseResponse(rsp *http.Response) (*CreateDatabaseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateDatabaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Links *struct {
				// Base Base url of the Confluence site.
				Base *string `json:"base,omitempty"`
			} `json:"_links,omitempty"`

			// AuthorId The account ID of the user who created this database originally.
			AuthorId *string `json:"authorId,omitempty"`

			// CreatedAt Date and time when the database was created. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
			CreatedAt *time.Time `json:"createdAt,omitempty"`

			// Id ID of the database.
			Id *string `json:"id,omitempty"`

			// OwnerId The account ID of the user who owns this database.
			OwnerId *string `json:"ownerId,omitempty"`

			// ParentId ID of the parent content, or null if there is no parent content.
			ParentId *string `json:"parentId,omitempty"`

			// ParentType Content type of the parent, or null if there is no parent.
			ParentType *ParentContentType `json:"parentType,omitempty"`

			// Position Position of the database within the given parent page tree.
			Position *int32 `json:"position"`

			// Status The status of the content.
			Status *ContentStatus `json:"status,omitempty"`

			// Title Title of the database.
			Title *string `json:"title,omitempty"`

			// Type The content type of the object.
			Type    *string  `json:"type,omitempty"`
			Version *Version `json:"version,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteDatabasePropertyByIdResponse parses an HTTP response from a DeleteDatabasePropertyByIdWithResponse call
func ParseDeleteDatabasePropertyByIdResponse(rsp *http.Response) (*DeleteDatabasePropertyByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDatabasePropertyByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetDatabaseContentPropertiesByIdResponse parses an HTTP response from a GetDatabaseContentPropertiesByIdWithResponse call
func ParseGetDatabaseContentPropertiesByIdResponse(rsp *http.Response) (*GetDatabaseContentPropertiesByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDatabaseContentPropertiesByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ContentProperty
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateDatabasePropertyByIdResponse parses an HTTP response from a UpdateDatabasePropertyByIdWithResponse call
func ParseUpdateDatabasePropertyByIdResponse(rsp *http.Response) (*UpdateDatabasePropertyByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateDatabasePropertyByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ContentProperty
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteDatabaseResponse parses an HTTP response from a DeleteDatabaseWithResponse call
func ParseDeleteDatabaseResponse(rsp *http.Response) (*DeleteDatabaseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDatabaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetDatabaseByIdResponse parses an HTTP response from a GetDatabaseByIdWithResponse call
func ParseGetDatabaseByIdResponse(rsp *http.Response) (*GetDatabaseByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDatabaseByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Links *struct {
				// Base Base url of the Confluence site.
				Base *string `json:"base,omitempty"`
			} `json:"_links,omitempty"`

			// AuthorId The account ID of the user who created this database originally.
			AuthorId *string `json:"authorId,omitempty"`

			// CreatedAt Date and time when the database was created. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
			CreatedAt *time.Time `json:"createdAt,omitempty"`

			// Id ID of the database.
			Id *string `json:"id,omitempty"`

			// OwnerId The account ID of the user who owns this database.
			OwnerId *string `json:"ownerId,omitempty"`

			// ParentId ID of the parent content, or null if there is no parent content.
			ParentId *string `json:"parentId,omitempty"`

			// ParentType Content type of the parent, or null if there is no parent.
			ParentType *ParentContentType `json:"parentType,omitempty"`

			// Position Position of the database within the given parent page tree.
			Position *int32 `json:"position"`

			// Status The status of the content.
			Status *ContentStatus `json:"status,omitempty"`

			// Title Title of the database.
			Title *string `json:"title,omitempty"`

			// Type The content type of the object.
			Type    *string  `json:"type,omitempty"`
			Version *Version `json:"version,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetDatabaseAncestorsResponse parses an HTTP response from a GetDatabaseAncestorsWithResponse call
func ParseGetDatabaseAncestorsResponse(rsp *http.Response) (*GetDatabaseAncestorsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDatabaseAncestorsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Results *[]Ancestor `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetDatabaseClassificationLevelResponse parses an HTTP response from a GetDatabaseClassificationLevelWithResponse call
func ParseGetDatabaseClassificationLevelResponse(rsp *http.Response) (*GetDatabaseClassificationLevelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDatabaseClassificationLevelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ClassificationLevel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePutDatabaseClassificationLevelResponse parses an HTTP response from a PutDatabaseClassificationLevelWithResponse call
func ParsePutDatabaseClassificationLevelResponse(rsp *http.Response) (*PutDatabaseClassificationLevelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutDatabaseClassificationLevelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePostDatabaseClassificationLevelResponse parses an HTTP response from a PostDatabaseClassificationLevelWithResponse call
func ParsePostDatabaseClassificationLevelResponse(rsp *http.Response) (*PostDatabaseClassificationLevelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostDatabaseClassificationLevelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetDatabaseOperationsResponse parses an HTTP response from a GetDatabaseOperationsWithResponse call
func ParseGetDatabaseOperationsResponse(rsp *http.Response) (*GetDatabaseOperationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDatabaseOperationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PermittedOperationsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetDatabaseContentPropertiesResponse parses an HTTP response from a GetDatabaseContentPropertiesWithResponse call
func ParseGetDatabaseContentPropertiesResponse(rsp *http.Response) (*GetDatabaseContentPropertiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDatabaseContentPropertiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Links   *MultiEntityLinks  `json:"_links,omitempty"`
			Results *[]ContentProperty `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateDatabasePropertyResponse parses an HTTP response from a CreateDatabasePropertyWithResponse call
func ParseCreateDatabasePropertyResponse(rsp *http.Response) (*CreateDatabasePropertyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateDatabasePropertyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ContentProperty
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateSmartLinkResponse parses an HTTP response from a CreateSmartLinkWithResponse call
func ParseCreateSmartLinkResponse(rsp *http.Response) (*CreateSmartLinkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSmartLinkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Links *struct {
				// Base Base url of the Confluence site.
				Base *string `json:"base,omitempty"`
			} `json:"_links,omitempty"`

			// AuthorId The account ID of the user who created this Smart Link in the content tree originally.
			AuthorId *string `json:"authorId,omitempty"`

			// CreatedAt Date and time when the Smart Link in the content tree was created. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
			CreatedAt *time.Time `json:"createdAt,omitempty"`

			// EmbedUrl The embedded URL of the Smart Link. If the Smart Link does not have an embedded URL, this property will not be included in the response.
			EmbedUrl *string `json:"embedUrl,omitempty"`

			// Id ID of the Smart Link in the content tree.
			Id *string `json:"id,omitempty"`

			// OwnerId The account ID of the user who owns this Smart Link in the content tree.
			OwnerId *string `json:"ownerId,omitempty"`

			// ParentId ID of the parent content, or null if there is no parent content.
			ParentId *string `json:"parentId,omitempty"`

			// ParentType Content type of the parent, or null if there is no parent.
			ParentType *ParentContentType `json:"parentType,omitempty"`

			// Position Position of the Smart Link within the given parent page tree.
			Position *int32 `json:"position"`

			// Status The status of the content.
			Status *ContentStatus `json:"status,omitempty"`

			// Title Title of the Smart Link in the content tree.
			Title *string `json:"title,omitempty"`

			// Type The content type of the object.
			Type    *string  `json:"type,omitempty"`
			Version *Version `json:"version,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteSmartLinkPropertyByIdResponse parses an HTTP response from a DeleteSmartLinkPropertyByIdWithResponse call
func ParseDeleteSmartLinkPropertyByIdResponse(rsp *http.Response) (*DeleteSmartLinkPropertyByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSmartLinkPropertyByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetSmartLinkContentPropertiesByIdResponse parses an HTTP response from a GetSmartLinkContentPropertiesByIdWithResponse call
func ParseGetSmartLinkContentPropertiesByIdResponse(rsp *http.Response) (*GetSmartLinkContentPropertiesByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSmartLinkContentPropertiesByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ContentProperty
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateSmartLinkPropertyByIdResponse parses an HTTP response from a UpdateSmartLinkPropertyByIdWithResponse call
func ParseUpdateSmartLinkPropertyByIdResponse(rsp *http.Response) (*UpdateSmartLinkPropertyByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateSmartLinkPropertyByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ContentProperty
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteSmartLinkResponse parses an HTTP response from a DeleteSmartLinkWithResponse call
func ParseDeleteSmartLinkResponse(rsp *http.Response) (*DeleteSmartLinkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSmartLinkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetSmartLinkByIdResponse parses an HTTP response from a GetSmartLinkByIdWithResponse call
func ParseGetSmartLinkByIdResponse(rsp *http.Response) (*GetSmartLinkByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSmartLinkByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Links *struct {
				// Base Base url of the Confluence site.
				Base *string `json:"base,omitempty"`
			} `json:"_links,omitempty"`

			// AuthorId The account ID of the user who created this Smart Link in the content tree originally.
			AuthorId *string `json:"authorId,omitempty"`

			// CreatedAt Date and time when the Smart Link in the content tree was created. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
			CreatedAt *time.Time `json:"createdAt,omitempty"`

			// EmbedUrl The embedded URL of the Smart Link. If the Smart Link does not have an embedded URL, this property will not be included in the response.
			EmbedUrl *string `json:"embedUrl,omitempty"`

			// Id ID of the Smart Link in the content tree.
			Id *string `json:"id,omitempty"`

			// OwnerId The account ID of the user who owns this Smart Link in the content tree.
			OwnerId *string `json:"ownerId,omitempty"`

			// ParentId ID of the parent content, or null if there is no parent content.
			ParentId *string `json:"parentId,omitempty"`

			// ParentType Content type of the parent, or null if there is no parent.
			ParentType *ParentContentType `json:"parentType,omitempty"`

			// Position Position of the Smart Link within the given parent page tree.
			Position *int32 `json:"position"`

			// Status The status of the content.
			Status *ContentStatus `json:"status,omitempty"`

			// Title Title of the Smart Link in the content tree.
			Title *string `json:"title,omitempty"`

			// Type The content type of the object.
			Type    *string  `json:"type,omitempty"`
			Version *Version `json:"version,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSmartLinkAncestorsResponse parses an HTTP response from a GetSmartLinkAncestorsWithResponse call
func ParseGetSmartLinkAncestorsResponse(rsp *http.Response) (*GetSmartLinkAncestorsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSmartLinkAncestorsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Results *[]Ancestor `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSmartLinkOperationsResponse parses an HTTP response from a GetSmartLinkOperationsWithResponse call
func ParseGetSmartLinkOperationsResponse(rsp *http.Response) (*GetSmartLinkOperationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSmartLinkOperationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PermittedOperationsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSmartLinkContentPropertiesResponse parses an HTTP response from a GetSmartLinkContentPropertiesWithResponse call
func ParseGetSmartLinkContentPropertiesResponse(rsp *http.Response) (*GetSmartLinkContentPropertiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSmartLinkContentPropertiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Links   *MultiEntityLinks  `json:"_links,omitempty"`
			Results *[]ContentProperty `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateSmartLinkPropertyResponse parses an HTTP response from a CreateSmartLinkPropertyWithResponse call
func ParseCreateSmartLinkPropertyResponse(rsp *http.Response) (*CreateSmartLinkPropertyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSmartLinkPropertyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ContentProperty
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateFolderResponse parses an HTTP response from a CreateFolderWithResponse call
func ParseCreateFolderResponse(rsp *http.Response) (*CreateFolderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateFolderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Links *struct {
				// Base Base url of the Confluence site.
				Base *string `json:"base,omitempty"`
			} `json:"_links,omitempty"`

			// AuthorId The account ID of the user who created this folder.
			AuthorId *string `json:"authorId,omitempty"`

			// CreatedAt Date and time when the folder was created. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
			CreatedAt *time.Time `json:"createdAt,omitempty"`

			// Id ID of the folder.
			Id *string `json:"id,omitempty"`

			// OwnerId The account ID of the user who owns this folder.
			OwnerId *string `json:"ownerId,omitempty"`

			// ParentId ID of the parent content, or null if there is no parent content.
			ParentId *string `json:"parentId,omitempty"`

			// ParentType Content type of the parent, or null if there is no parent.
			ParentType *ParentContentType `json:"parentType,omitempty"`

			// Position Position of the folder within the given parent page tree.
			Position *int32 `json:"position"`

			// Status The status of the content.
			Status *ContentStatus `json:"status,omitempty"`

			// Title Title of the folder.
			Title *string `json:"title,omitempty"`

			// Type The content type of the object.
			Type    *string  `json:"type,omitempty"`
			Version *Version `json:"version,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteFolderPropertyByIdResponse parses an HTTP response from a DeleteFolderPropertyByIdWithResponse call
func ParseDeleteFolderPropertyByIdResponse(rsp *http.Response) (*DeleteFolderPropertyByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteFolderPropertyByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetFolderContentPropertiesByIdResponse parses an HTTP response from a GetFolderContentPropertiesByIdWithResponse call
func ParseGetFolderContentPropertiesByIdResponse(rsp *http.Response) (*GetFolderContentPropertiesByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFolderContentPropertiesByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ContentProperty
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateFolderPropertyByIdResponse parses an HTTP response from a UpdateFolderPropertyByIdWithResponse call
func ParseUpdateFolderPropertyByIdResponse(rsp *http.Response) (*UpdateFolderPropertyByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateFolderPropertyByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ContentProperty
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteFolderResponse parses an HTTP response from a DeleteFolderWithResponse call
func ParseDeleteFolderResponse(rsp *http.Response) (*DeleteFolderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteFolderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetFolderByIdResponse parses an HTTP response from a GetFolderByIdWithResponse call
func ParseGetFolderByIdResponse(rsp *http.Response) (*GetFolderByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFolderByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Links *struct {
				// Base Base url of the Confluence site.
				Base *string `json:"base,omitempty"`
			} `json:"_links,omitempty"`

			// AuthorId The account ID of the user who created this folder.
			AuthorId *string `json:"authorId,omitempty"`

			// CreatedAt Date and time when the folder was created. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
			CreatedAt *time.Time `json:"createdAt,omitempty"`

			// Id ID of the folder.
			Id *string `json:"id,omitempty"`

			// OwnerId The account ID of the user who owns this folder.
			OwnerId *string `json:"ownerId,omitempty"`

			// ParentId ID of the parent content, or null if there is no parent content.
			ParentId *string `json:"parentId,omitempty"`

			// ParentType Content type of the parent, or null if there is no parent.
			ParentType *ParentContentType `json:"parentType,omitempty"`

			// Position Position of the folder within the given parent page tree.
			Position *int32 `json:"position"`

			// Status The status of the content.
			Status *ContentStatus `json:"status,omitempty"`

			// Title Title of the folder.
			Title *string `json:"title,omitempty"`

			// Type The content type of the object.
			Type    *string  `json:"type,omitempty"`
			Version *Version `json:"version,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetFolderAncestorsResponse parses an HTTP response from a GetFolderAncestorsWithResponse call
func ParseGetFolderAncestorsResponse(rsp *http.Response) (*GetFolderAncestorsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFolderAncestorsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Results *[]Ancestor `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetFolderOperationsResponse parses an HTTP response from a GetFolderOperationsWithResponse call
func ParseGetFolderOperationsResponse(rsp *http.Response) (*GetFolderOperationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFolderOperationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PermittedOperationsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetFolderContentPropertiesResponse parses an HTTP response from a GetFolderContentPropertiesWithResponse call
func ParseGetFolderContentPropertiesResponse(rsp *http.Response) (*GetFolderContentPropertiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFolderContentPropertiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Links   *MultiEntityLinks  `json:"_links,omitempty"`
			Results *[]ContentProperty `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateFolderPropertyResponse parses an HTTP response from a CreateFolderPropertyWithResponse call
func ParseCreateFolderPropertyResponse(rsp *http.Response) (*CreateFolderPropertyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateFolderPropertyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ContentProperty
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetFooterCommentsResponse parses an HTTP response from a GetFooterCommentsWithResponse call
func ParseGetFooterCommentsResponse(rsp *http.Response) (*GetFooterCommentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFooterCommentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Links   *MultiEntityLinks     `json:"_links,omitempty"`
			Results *[]FooterCommentModel `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateFooterCommentResponse parses an HTTP response from a CreateFooterCommentWithResponse call
func ParseCreateFooterCommentResponse(rsp *http.Response) (*CreateFooterCommentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateFooterCommentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Links *struct {
				// Base Base url of the Confluence site.
				Base *string `json:"base,omitempty"`
			} `json:"_links,omitempty"`

			// AttachmentId ID of the attachment containing the comment if the comment is on an attachment.
			AttachmentId *string `json:"attachmentId,omitempty"`

			// BlogPostId ID of the blog post containing the comment if the comment is on a blog post.
			BlogPostId *string `json:"blogPostId,omitempty"`

			// Body Contains fields for each representation type requested.
			Body *BodySingle `json:"body,omitempty"`

			// CustomContentId ID of the custom content containing the comment if the comment is on a custom content.
			CustomContentId *string `json:"customContentId,omitempty"`

			// Id ID of the comment.
			Id    *string `json:"id,omitempty"`
			Likes *struct {
				Links   *OptionalFieldLinks `json:"_links,omitempty"`
				Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
				Results *[]Like             `json:"results,omitempty"`
			} `json:"likes,omitempty"`
			Operations *struct {
				Links   *OptionalFieldLinks `json:"_links,omitempty"`
				Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
				Results *[]Operation        `json:"results,omitempty"`
			} `json:"operations,omitempty"`

			// PageId ID of the page containing the comment if the comment is on a page.
			PageId *string `json:"pageId,omitempty"`

			// ParentCommentId ID of the parent comment if the comment is a reply.
			ParentCommentId *string `json:"parentCommentId,omitempty"`
			Properties      *struct {
				Links   *OptionalFieldLinks `json:"_links,omitempty"`
				Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
				Results *[]ContentProperty  `json:"results,omitempty"`
			} `json:"properties,omitempty"`

			// Status The status of the content.
			Status *ContentStatus `json:"status,omitempty"`

			// Title Title of the comment.
			Title    *string  `json:"title,omitempty"`
			Version  *Version `json:"version,omitempty"`
			Versions *struct {
				Links   *OptionalFieldLinks `json:"_links,omitempty"`
				Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
				Results *[]Version          `json:"results,omitempty"`
			} `json:"versions,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseDeleteFooterCommentResponse parses an HTTP response from a DeleteFooterCommentWithResponse call
func ParseDeleteFooterCommentResponse(rsp *http.Response) (*DeleteFooterCommentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteFooterCommentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetFooterCommentByIdResponse parses an HTTP response from a GetFooterCommentByIdWithResponse call
func ParseGetFooterCommentByIdResponse(rsp *http.Response) (*GetFooterCommentByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFooterCommentByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Links *struct {
				// Base Base url of the Confluence site.
				Base *string `json:"base,omitempty"`
			} `json:"_links,omitempty"`

			// AttachmentId ID of the attachment containing the comment if the comment is on an attachment.
			AttachmentId *string `json:"attachmentId,omitempty"`

			// BlogPostId ID of the blog post containing the comment if the comment is on a blog post.
			BlogPostId *string `json:"blogPostId,omitempty"`

			// Body Contains fields for each representation type requested.
			Body *BodySingle `json:"body,omitempty"`

			// CustomContentId ID of the custom content containing the comment if the comment is on a custom content.
			CustomContentId *string `json:"customContentId,omitempty"`

			// Id ID of the comment.
			Id    *string `json:"id,omitempty"`
			Likes *struct {
				Links   *OptionalFieldLinks `json:"_links,omitempty"`
				Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
				Results *[]Like             `json:"results,omitempty"`
			} `json:"likes,omitempty"`
			Operations *struct {
				Links   *OptionalFieldLinks `json:"_links,omitempty"`
				Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
				Results *[]Operation        `json:"results,omitempty"`
			} `json:"operations,omitempty"`

			// PageId ID of the page containing the comment if the comment is on a page.
			PageId *string `json:"pageId,omitempty"`

			// ParentCommentId ID of the parent comment if the comment is a reply.
			ParentCommentId *string `json:"parentCommentId,omitempty"`
			Properties      *struct {
				Links   *OptionalFieldLinks `json:"_links,omitempty"`
				Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
				Results *[]ContentProperty  `json:"results,omitempty"`
			} `json:"properties,omitempty"`

			// Status The status of the content.
			Status *ContentStatus `json:"status,omitempty"`

			// Title Title of the comment.
			Title    *string  `json:"title,omitempty"`
			Version  *Version `json:"version,omitempty"`
			Versions *struct {
				Links   *OptionalFieldLinks `json:"_links,omitempty"`
				Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
				Results *[]Version          `json:"results,omitempty"`
			} `json:"versions,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateFooterCommentResponse parses an HTTP response from a UpdateFooterCommentWithResponse call
func ParseUpdateFooterCommentResponse(rsp *http.Response) (*UpdateFooterCommentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateFooterCommentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FooterCommentModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetFooterCommentChildrenResponse parses an HTTP response from a GetFooterCommentChildrenWithResponse call
func ParseGetFooterCommentChildrenResponse(rsp *http.Response) (*GetFooterCommentChildrenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFooterCommentChildrenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Links   *MultiEntityLinks       `json:"_links,omitempty"`
			Results *[]ChildrenCommentModel `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetFooterLikeCountResponse parses an HTTP response from a GetFooterLikeCountWithResponse call
func ParseGetFooterLikeCountResponse(rsp *http.Response) (*GetFooterLikeCountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFooterLikeCountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count The count number
			Count *int64 `json:"count,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetFooterLikeUsersResponse parses an HTTP response from a GetFooterLikeUsersWithResponse call
func ParseGetFooterLikeUsersResponse(rsp *http.Response) (*GetFooterLikeUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFooterLikeUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Links   *MultiEntityLinks `json:"_links,omitempty"`
			Results *[]Like           `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetFooterCommentOperationsResponse parses an HTTP response from a GetFooterCommentOperationsWithResponse call
func ParseGetFooterCommentOperationsResponse(rsp *http.Response) (*GetFooterCommentOperationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFooterCommentOperationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PermittedOperationsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetFooterCommentVersionsResponse parses an HTTP response from a GetFooterCommentVersionsWithResponse call
func ParseGetFooterCommentVersionsResponse(rsp *http.Response) (*GetFooterCommentVersionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFooterCommentVersionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Links   *MultiEntityLinks `json:"_links,omitempty"`
			Results *[]CommentVersion `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetFooterCommentVersionDetailsResponse parses an HTTP response from a GetFooterCommentVersionDetailsWithResponse call
func ParseGetFooterCommentVersionDetailsResponse(rsp *http.Response) (*GetFooterCommentVersionDetailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFooterCommentVersionDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DetailedVersion
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetInlineCommentsResponse parses an HTTP response from a GetInlineCommentsWithResponse call
func ParseGetInlineCommentsResponse(rsp *http.Response) (*GetInlineCommentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInlineCommentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Links   *MultiEntityLinks     `json:"_links,omitempty"`
			Results *[]InlineCommentModel `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateInlineCommentResponse parses an HTTP response from a CreateInlineCommentWithResponse call
func ParseCreateInlineCommentResponse(rsp *http.Response) (*CreateInlineCommentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateInlineCommentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Links *struct {
				// Base Base url of the Confluence site.
				Base *string `json:"base,omitempty"`
			} `json:"_links,omitempty"`

			// BlogPostId ID of the blog post containing the comment if the comment is on a blog post.
			BlogPostId *string `json:"blogPostId,omitempty"`

			// Body Contains fields for each representation type requested.
			Body *BodySingle `json:"body,omitempty"`

			// Id ID of the comment.
			Id    *string `json:"id,omitempty"`
			Likes *struct {
				Links   *OptionalFieldLinks `json:"_links,omitempty"`
				Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
				Results *[]Like             `json:"results,omitempty"`
			} `json:"likes,omitempty"`
			Operations *struct {
				Links   *OptionalFieldLinks `json:"_links,omitempty"`
				Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
				Results *[]Operation        `json:"results,omitempty"`
			} `json:"operations,omitempty"`

			// PageId ID of the page containing the comment if the comment is on a page.
			PageId *string `json:"pageId,omitempty"`

			// ParentCommentId ID of the parent comment if the comment is a reply.
			ParentCommentId *string `json:"parentCommentId,omitempty"`
			Properties      *struct {
				Links *OptionalFieldLinks `json:"_links,omitempty"`

				// InlineMarkerRef Property value used to reference the highlighted element in DOM.
				InlineMarkerRef *string `json:"inlineMarkerRef,omitempty"`

				// InlineOriginalSelection Text that is highlighted.
				InlineOriginalSelection *string            `json:"inlineOriginalSelection,omitempty"`
				Meta                    *OptionalFieldMeta `json:"meta,omitempty"`
				Results                 *[]ContentProperty `json:"results,omitempty"`
			} `json:"properties,omitempty"`

			// ResolutionLastModifiedAt Timestamp of the last modification to the comment's resolution status. Null until comment is resolved or reopened.
			ResolutionLastModifiedAt *time.Time `json:"resolutionLastModifiedAt,omitempty"`

			// ResolutionLastModifierId Atlassian Account ID of last person who modified the resolve state of the comment. Null until comment is resolved or reopened.
			ResolutionLastModifierId *string `json:"resolutionLastModifierId,omitempty"`

			// ResolutionStatus Inline comment resolution status
			ResolutionStatus *InlineCommentResolutionStatus `json:"resolutionStatus,omitempty"`

			// Status The status of the content.
			Status *ContentStatus `json:"status,omitempty"`

			// Title Title of the comment.
			Title    *string  `json:"title,omitempty"`
			Version  *Version `json:"version,omitempty"`
			Versions *struct {
				Links   *OptionalFieldLinks `json:"_links,omitempty"`
				Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
				Results *[]Version          `json:"results,omitempty"`
			} `json:"versions,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseDeleteInlineCommentResponse parses an HTTP response from a DeleteInlineCommentWithResponse call
func ParseDeleteInlineCommentResponse(rsp *http.Response) (*DeleteInlineCommentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteInlineCommentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetInlineCommentByIdResponse parses an HTTP response from a GetInlineCommentByIdWithResponse call
func ParseGetInlineCommentByIdResponse(rsp *http.Response) (*GetInlineCommentByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInlineCommentByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Links *struct {
				// Base Base url of the Confluence site.
				Base *string `json:"base,omitempty"`
			} `json:"_links,omitempty"`

			// BlogPostId ID of the blog post containing the comment if the comment is on a blog post.
			BlogPostId *string `json:"blogPostId,omitempty"`

			// Body Contains fields for each representation type requested.
			Body *BodySingle `json:"body,omitempty"`

			// Id ID of the comment.
			Id    *string `json:"id,omitempty"`
			Likes *struct {
				Links   *OptionalFieldLinks `json:"_links,omitempty"`
				Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
				Results *[]Like             `json:"results,omitempty"`
			} `json:"likes,omitempty"`
			Operations *struct {
				Links   *OptionalFieldLinks `json:"_links,omitempty"`
				Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
				Results *[]Operation        `json:"results,omitempty"`
			} `json:"operations,omitempty"`

			// PageId ID of the page containing the comment if the comment is on a page.
			PageId *string `json:"pageId,omitempty"`

			// ParentCommentId ID of the parent comment if the comment is a reply.
			ParentCommentId *string `json:"parentCommentId,omitempty"`
			Properties      *struct {
				Links *OptionalFieldLinks `json:"_links,omitempty"`

				// InlineMarkerRef Property value used to reference the highlighted element in DOM.
				InlineMarkerRef *string `json:"inlineMarkerRef,omitempty"`

				// InlineOriginalSelection Text that is highlighted.
				InlineOriginalSelection *string            `json:"inlineOriginalSelection,omitempty"`
				Meta                    *OptionalFieldMeta `json:"meta,omitempty"`
				Results                 *[]ContentProperty `json:"results,omitempty"`
			} `json:"properties,omitempty"`

			// ResolutionLastModifiedAt Timestamp of the last modification to the comment's resolution status. Null until comment is resolved or reopened.
			ResolutionLastModifiedAt *time.Time `json:"resolutionLastModifiedAt,omitempty"`

			// ResolutionLastModifierId Atlassian Account ID of last person who modified the resolve state of the comment. Null until comment is resolved or reopened.
			ResolutionLastModifierId *string `json:"resolutionLastModifierId,omitempty"`

			// ResolutionStatus Inline comment resolution status
			ResolutionStatus *InlineCommentResolutionStatus `json:"resolutionStatus,omitempty"`

			// Status The status of the content.
			Status *ContentStatus `json:"status,omitempty"`

			// Title Title of the comment.
			Title    *string  `json:"title,omitempty"`
			Version  *Version `json:"version,omitempty"`
			Versions *struct {
				Links   *OptionalFieldLinks `json:"_links,omitempty"`
				Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
				Results *[]Version          `json:"results,omitempty"`
			} `json:"versions,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateInlineCommentResponse parses an HTTP response from a UpdateInlineCommentWithResponse call
func ParseUpdateInlineCommentResponse(rsp *http.Response) (*UpdateInlineCommentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateInlineCommentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Links *struct {
				// Base Base url of the Confluence site.
				Base *string `json:"base,omitempty"`
			} `json:"_links,omitempty"`

			// BlogPostId ID of the blog post containing the comment if the comment is on a blog post.
			BlogPostId *string `json:"blogPostId,omitempty"`

			// Body Contains fields for each representation type requested.
			Body *BodySingle `json:"body,omitempty"`

			// Id ID of the comment.
			Id    *string `json:"id,omitempty"`
			Likes *struct {
				Links   *OptionalFieldLinks `json:"_links,omitempty"`
				Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
				Results *[]Like             `json:"results,omitempty"`
			} `json:"likes,omitempty"`
			Operations *struct {
				Links   *OptionalFieldLinks `json:"_links,omitempty"`
				Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
				Results *[]Operation        `json:"results,omitempty"`
			} `json:"operations,omitempty"`

			// PageId ID of the page containing the comment if the comment is on a page.
			PageId *string `json:"pageId,omitempty"`

			// ParentCommentId ID of the parent comment if the comment is a reply.
			ParentCommentId *string `json:"parentCommentId,omitempty"`
			Properties      *struct {
				Links *OptionalFieldLinks `json:"_links,omitempty"`

				// InlineMarkerRef Property value used to reference the highlighted element in DOM.
				InlineMarkerRef *string `json:"inlineMarkerRef,omitempty"`

				// InlineOriginalSelection Text that is highlighted.
				InlineOriginalSelection *string            `json:"inlineOriginalSelection,omitempty"`
				Meta                    *OptionalFieldMeta `json:"meta,omitempty"`
				Results                 *[]ContentProperty `json:"results,omitempty"`
			} `json:"properties,omitempty"`

			// ResolutionLastModifiedAt Timestamp of the last modification to the comment's resolution status. Null until comment is resolved or reopened.
			ResolutionLastModifiedAt *time.Time `json:"resolutionLastModifiedAt,omitempty"`

			// ResolutionLastModifierId Atlassian Account ID of last person who modified the resolve state of the comment. Null until comment is resolved or reopened.
			ResolutionLastModifierId *string `json:"resolutionLastModifierId,omitempty"`

			// ResolutionStatus Inline comment resolution status
			ResolutionStatus *InlineCommentResolutionStatus `json:"resolutionStatus,omitempty"`

			// Status The status of the content.
			Status *ContentStatus `json:"status,omitempty"`

			// Title Title of the comment.
			Title    *string  `json:"title,omitempty"`
			Version  *Version `json:"version,omitempty"`
			Versions *struct {
				Links   *OptionalFieldLinks `json:"_links,omitempty"`
				Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
				Results *[]Version          `json:"results,omitempty"`
			} `json:"versions,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetInlineCommentChildrenResponse parses an HTTP response from a GetInlineCommentChildrenWithResponse call
func ParseGetInlineCommentChildrenResponse(rsp *http.Response) (*GetInlineCommentChildrenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInlineCommentChildrenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Links   *MultiEntityLinks             `json:"_links,omitempty"`
			Results *[]InlineCommentChildrenModel `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetInlineLikeCountResponse parses an HTTP response from a GetInlineLikeCountWithResponse call
func ParseGetInlineLikeCountResponse(rsp *http.Response) (*GetInlineLikeCountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInlineLikeCountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count The count number
			Count *int64 `json:"count,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetInlineLikeUsersResponse parses an HTTP response from a GetInlineLikeUsersWithResponse call
func ParseGetInlineLikeUsersResponse(rsp *http.Response) (*GetInlineLikeUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInlineLikeUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Links   *MultiEntityLinks `json:"_links,omitempty"`
			Results *[]Like           `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetInlineCommentOperationsResponse parses an HTTP response from a GetInlineCommentOperationsWithResponse call
func ParseGetInlineCommentOperationsResponse(rsp *http.Response) (*GetInlineCommentOperationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInlineCommentOperationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PermittedOperationsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetInlineCommentVersionsResponse parses an HTTP response from a GetInlineCommentVersionsWithResponse call
func ParseGetInlineCommentVersionsResponse(rsp *http.Response) (*GetInlineCommentVersionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInlineCommentVersionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Links   *MultiEntityLinks `json:"_links,omitempty"`
			Results *[]CommentVersion `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetInlineCommentVersionDetailsResponse parses an HTTP response from a GetInlineCommentVersionDetailsWithResponse call
func ParseGetInlineCommentVersionDetailsResponse(rsp *http.Response) (*GetInlineCommentVersionDetailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInlineCommentVersionDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DetailedVersion
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetLabelsResponse parses an HTTP response from a GetLabelsWithResponse call
func ParseGetLabelsResponse(rsp *http.Response) (*GetLabelsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLabelsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Links   *MultiEntityLinks `json:"_links,omitempty"`
			Results *[]Label          `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetLabelAttachmentsResponse parses an HTTP response from a GetLabelAttachmentsWithResponse call
func ParseGetLabelAttachmentsResponse(rsp *http.Response) (*GetLabelAttachmentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLabelAttachmentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Links   *MultiEntityLinks `json:"_links,omitempty"`
			Results *[]AttachmentBulk `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetLabelBlogPostsResponse parses an HTTP response from a GetLabelBlogPostsWithResponse call
func ParseGetLabelBlogPostsResponse(rsp *http.Response) (*GetLabelBlogPostsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLabelBlogPostsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Links   *MultiEntityLinks `json:"_links,omitempty"`
			Results *[]BlogPostBulk   `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetLabelPagesResponse parses an HTTP response from a GetLabelPagesWithResponse call
func ParseGetLabelPagesResponse(rsp *http.Response) (*GetLabelPagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLabelPagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Links   *MultiEntityLinks `json:"_links,omitempty"`
			Results *[]PageBulk       `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPagesResponse parses an HTTP response from a GetPagesWithResponse call
func ParseGetPagesResponse(rsp *http.Response) (*GetPagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Links   *MultiEntityLinks `json:"_links,omitempty"`
			Results *[]PageBulk       `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreatePageResponse parses an HTTP response from a CreatePageWithResponse call
func ParseCreatePageResponse(rsp *http.Response) (*CreatePageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Links *struct {
				// Base Base url of the Confluence site.
				Base *string `json:"base,omitempty"`
			} `json:"_links,omitempty"`

			// AuthorId The account ID of the user who created this page originally.
			AuthorId *string `json:"authorId,omitempty"`

			// Body Contains fields for each representation type requested.
			Body *BodySingle `json:"body,omitempty"`

			// CreatedAt Date and time when the page was created. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
			CreatedAt *time.Time `json:"createdAt,omitempty"`

			// Id ID of the page.
			Id *string `json:"id,omitempty"`

			// IsFavoritedByCurrentUser Whether the page has been favorited by the current user.
			IsFavoritedByCurrentUser *bool `json:"isFavoritedByCurrentUser,omitempty"`
			Labels                   *struct {
				Links   *OptionalFieldLinks `json:"_links,omitempty"`
				Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
				Results *[]Label            `json:"results,omitempty"`
			} `json:"labels,omitempty"`

			// LastOwnerId The account ID of the user who owned this page previously, or null if there is no previous owner.
			LastOwnerId *string `json:"lastOwnerId"`
			Likes       *struct {
				Links   *OptionalFieldLinks `json:"_links,omitempty"`
				Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
				Results *[]Like             `json:"results,omitempty"`
			} `json:"likes,omitempty"`
			Operations *struct {
				Links   *OptionalFieldLinks `json:"_links,omitempty"`
				Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
				Results *[]Operation        `json:"results,omitempty"`
			} `json:"operations,omitempty"`

			// OwnerId The account ID of the user who owns this page.
			OwnerId *string `json:"ownerId"`

			// ParentId ID of the parent page, or null if there is no parent page.
			ParentId *string `json:"parentId,omitempty"`

			// ParentType Content type of the parent, or null if there is no parent.
			ParentType *ParentContentType `json:"parentType,omitempty"`

			// Position Position of child page within the given parent page tree.
			Position   *int32 `json:"position"`
			Properties *struct {
				Links   *OptionalFieldLinks `json:"_links,omitempty"`
				Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
				Results *[]ContentProperty  `json:"results,omitempty"`
			} `json:"properties,omitempty"`

			// SpaceId ID of the space the page is in.
			SpaceId *string `json:"spaceId,omitempty"`

			// Status The status of the content.
			Status *ContentStatus `json:"status,omitempty"`

			// Title Title of the page.
			Title    *string  `json:"title,omitempty"`
			Version  *Version `json:"version,omitempty"`
			Versions *struct {
				Links   *OptionalFieldLinks `json:"_links,omitempty"`
				Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
				Results *[]Version          `json:"results,omitempty"`
			} `json:"versions,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeletePageResponse parses an HTTP response from a DeletePageWithResponse call
func ParseDeletePageResponse(rsp *http.Response) (*DeletePageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPageByIdResponse parses an HTTP response from a GetPageByIdWithResponse call
func ParseGetPageByIdResponse(rsp *http.Response) (*GetPageByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPageByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Links *struct {
				// Base Base url of the Confluence site.
				Base *string `json:"base,omitempty"`
			} `json:"_links,omitempty"`

			// AuthorId The account ID of the user who created this page originally.
			AuthorId *string `json:"authorId,omitempty"`

			// Body Contains fields for each representation type requested.
			Body *BodySingle `json:"body,omitempty"`

			// CreatedAt Date and time when the page was created. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
			CreatedAt *time.Time `json:"createdAt,omitempty"`

			// Id ID of the page.
			Id *string `json:"id,omitempty"`

			// IsFavoritedByCurrentUser Whether the page has been favorited by the current user.
			IsFavoritedByCurrentUser *bool `json:"isFavoritedByCurrentUser,omitempty"`
			Labels                   *struct {
				Links   *OptionalFieldLinks `json:"_links,omitempty"`
				Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
				Results *[]Label            `json:"results,omitempty"`
			} `json:"labels,omitempty"`

			// LastOwnerId The account ID of the user who owned this page previously, or null if there is no previous owner.
			LastOwnerId *string `json:"lastOwnerId"`
			Likes       *struct {
				Links   *OptionalFieldLinks `json:"_links,omitempty"`
				Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
				Results *[]Like             `json:"results,omitempty"`
			} `json:"likes,omitempty"`
			Operations *struct {
				Links   *OptionalFieldLinks `json:"_links,omitempty"`
				Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
				Results *[]Operation        `json:"results,omitempty"`
			} `json:"operations,omitempty"`

			// OwnerId The account ID of the user who owns this page.
			OwnerId *string `json:"ownerId"`

			// ParentId ID of the parent page, or null if there is no parent page.
			ParentId *string `json:"parentId,omitempty"`

			// ParentType Content type of the parent, or null if there is no parent.
			ParentType *ParentContentType `json:"parentType,omitempty"`

			// Position Position of child page within the given parent page tree.
			Position   *int32 `json:"position"`
			Properties *struct {
				Links   *OptionalFieldLinks `json:"_links,omitempty"`
				Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
				Results *[]ContentProperty  `json:"results,omitempty"`
			} `json:"properties,omitempty"`

			// SpaceId ID of the space the page is in.
			SpaceId *string `json:"spaceId,omitempty"`

			// Status The status of the content.
			Status *ContentStatus `json:"status,omitempty"`

			// Title Title of the page.
			Title    *string  `json:"title,omitempty"`
			Version  *Version `json:"version,omitempty"`
			Versions *struct {
				Links   *OptionalFieldLinks `json:"_links,omitempty"`
				Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
				Results *[]Version          `json:"results,omitempty"`
			} `json:"versions,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdatePageResponse parses an HTTP response from a UpdatePageWithResponse call
func ParseUpdatePageResponse(rsp *http.Response) (*UpdatePageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdatePageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Links *struct {
				// Base Base url of the Confluence site.
				Base *string `json:"base,omitempty"`
			} `json:"_links,omitempty"`

			// AuthorId The account ID of the user who created this page originally.
			AuthorId *string `json:"authorId,omitempty"`

			// Body Contains fields for each representation type requested.
			Body *BodySingle `json:"body,omitempty"`

			// CreatedAt Date and time when the page was created. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
			CreatedAt *time.Time `json:"createdAt,omitempty"`

			// Id ID of the page.
			Id *string `json:"id,omitempty"`

			// IsFavoritedByCurrentUser Whether the page has been favorited by the current user.
			IsFavoritedByCurrentUser *bool `json:"isFavoritedByCurrentUser,omitempty"`
			Labels                   *struct {
				Links   *OptionalFieldLinks `json:"_links,omitempty"`
				Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
				Results *[]Label            `json:"results,omitempty"`
			} `json:"labels,omitempty"`

			// LastOwnerId The account ID of the user who owned this page previously, or null if there is no previous owner.
			LastOwnerId *string `json:"lastOwnerId"`
			Likes       *struct {
				Links   *OptionalFieldLinks `json:"_links,omitempty"`
				Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
				Results *[]Like             `json:"results,omitempty"`
			} `json:"likes,omitempty"`
			Operations *struct {
				Links   *OptionalFieldLinks `json:"_links,omitempty"`
				Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
				Results *[]Operation        `json:"results,omitempty"`
			} `json:"operations,omitempty"`

			// OwnerId The account ID of the user who owns this page.
			OwnerId *string `json:"ownerId"`

			// ParentId ID of the parent page, or null if there is no parent page.
			ParentId *string `json:"parentId,omitempty"`

			// ParentType Content type of the parent, or null if there is no parent.
			ParentType *ParentContentType `json:"parentType,omitempty"`

			// Position Position of child page within the given parent page tree.
			Position   *int32 `json:"position"`
			Properties *struct {
				Links   *OptionalFieldLinks `json:"_links,omitempty"`
				Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
				Results *[]ContentProperty  `json:"results,omitempty"`
			} `json:"properties,omitempty"`

			// SpaceId ID of the space the page is in.
			SpaceId *string `json:"spaceId,omitempty"`

			// Status The status of the content.
			Status *ContentStatus `json:"status,omitempty"`

			// Title Title of the page.
			Title    *string  `json:"title,omitempty"`
			Version  *Version `json:"version,omitempty"`
			Versions *struct {
				Links   *OptionalFieldLinks `json:"_links,omitempty"`
				Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
				Results *[]Version          `json:"results,omitempty"`
			} `json:"versions,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPageAncestorsResponse parses an HTTP response from a GetPageAncestorsWithResponse call
func ParseGetPageAncestorsResponse(rsp *http.Response) (*GetPageAncestorsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPageAncestorsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Links   *MultiEntityLinks `json:"_links,omitempty"`
			Results *[]Ancestor       `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPageAttachmentsResponse parses an HTTP response from a GetPageAttachmentsWithResponse call
func ParseGetPageAttachmentsResponse(rsp *http.Response) (*GetPageAttachmentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPageAttachmentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Links   *MultiEntityLinks `json:"_links,omitempty"`
			Results *[]AttachmentBulk `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetChildPagesResponse parses an HTTP response from a GetChildPagesWithResponse call
func ParseGetChildPagesResponse(rsp *http.Response) (*GetChildPagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetChildPagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Links   *MultiEntityLinks `json:"_links,omitempty"`
			Results *[]ChildPage      `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPageClassificationLevelResponse parses an HTTP response from a GetPageClassificationLevelWithResponse call
func ParseGetPageClassificationLevelResponse(rsp *http.Response) (*GetPageClassificationLevelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPageClassificationLevelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ClassificationLevel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePutPageClassificationLevelResponse parses an HTTP response from a PutPageClassificationLevelWithResponse call
func ParsePutPageClassificationLevelResponse(rsp *http.Response) (*PutPageClassificationLevelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutPageClassificationLevelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePostPageClassificationLevelResponse parses an HTTP response from a PostPageClassificationLevelWithResponse call
func ParsePostPageClassificationLevelResponse(rsp *http.Response) (*PostPageClassificationLevelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostPageClassificationLevelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetCustomContentByTypeInPageResponse parses an HTTP response from a GetCustomContentByTypeInPageWithResponse call
func ParseGetCustomContentByTypeInPageResponse(rsp *http.Response) (*GetCustomContentByTypeInPageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCustomContentByTypeInPageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Links   *MultiEntityLinks    `json:"_links,omitempty"`
			Results *[]CustomContentBulk `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPageFooterCommentsResponse parses an HTTP response from a GetPageFooterCommentsWithResponse call
func ParseGetPageFooterCommentsResponse(rsp *http.Response) (*GetPageFooterCommentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPageFooterCommentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Links   *MultiEntityLinks   `json:"_links,omitempty"`
			Results *[]PageCommentModel `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPageInlineCommentsResponse parses an HTTP response from a GetPageInlineCommentsWithResponse call
func ParseGetPageInlineCommentsResponse(rsp *http.Response) (*GetPageInlineCommentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPageInlineCommentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Links   *MultiEntityLinks         `json:"_links,omitempty"`
			Results *[]PageInlineCommentModel `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPageLabelsResponse parses an HTTP response from a GetPageLabelsWithResponse call
func ParseGetPageLabelsResponse(rsp *http.Response) (*GetPageLabelsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPageLabelsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Links   *MultiEntityLinks `json:"_links,omitempty"`
			Results *[]Label          `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPageLikeCountResponse parses an HTTP response from a GetPageLikeCountWithResponse call
func ParseGetPageLikeCountResponse(rsp *http.Response) (*GetPageLikeCountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPageLikeCountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count The count number
			Count *int64 `json:"count,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPageLikeUsersResponse parses an HTTP response from a GetPageLikeUsersWithResponse call
func ParseGetPageLikeUsersResponse(rsp *http.Response) (*GetPageLikeUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPageLikeUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Links   *MultiEntityLinks `json:"_links,omitempty"`
			Results *[]Like           `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPageOperationsResponse parses an HTTP response from a GetPageOperationsWithResponse call
func ParseGetPageOperationsResponse(rsp *http.Response) (*GetPageOperationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPageOperationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PermittedOperationsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPageVersionsResponse parses an HTTP response from a GetPageVersionsWithResponse call
func ParseGetPageVersionsResponse(rsp *http.Response) (*GetPageVersionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPageVersionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Links   *MultiEntityLinks `json:"_links,omitempty"`
			Results *[]PageVersion    `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPageContentPropertiesResponse parses an HTTP response from a GetPageContentPropertiesWithResponse call
func ParseGetPageContentPropertiesResponse(rsp *http.Response) (*GetPageContentPropertiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPageContentPropertiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Links   *MultiEntityLinks  `json:"_links,omitempty"`
			Results *[]ContentProperty `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreatePagePropertyResponse parses an HTTP response from a CreatePagePropertyWithResponse call
func ParseCreatePagePropertyResponse(rsp *http.Response) (*CreatePagePropertyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePagePropertyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ContentProperty
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeletePagePropertyByIdResponse parses an HTTP response from a DeletePagePropertyByIdWithResponse call
func ParseDeletePagePropertyByIdResponse(rsp *http.Response) (*DeletePagePropertyByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePagePropertyByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPageContentPropertiesByIdResponse parses an HTTP response from a GetPageContentPropertiesByIdWithResponse call
func ParseGetPageContentPropertiesByIdResponse(rsp *http.Response) (*GetPageContentPropertiesByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPageContentPropertiesByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ContentProperty
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdatePagePropertyByIdResponse parses an HTTP response from a UpdatePagePropertyByIdWithResponse call
func ParseUpdatePagePropertyByIdResponse(rsp *http.Response) (*UpdatePagePropertyByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdatePagePropertyByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ContentProperty
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPageVersionDetailsResponse parses an HTTP response from a GetPageVersionDetailsWithResponse call
func ParseGetPageVersionDetailsResponse(rsp *http.Response) (*GetPageVersionDetailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPageVersionDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DetailedVersion
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSpacesResponse parses an HTTP response from a GetSpacesWithResponse call
func ParseGetSpacesResponse(rsp *http.Response) (*GetSpacesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSpacesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Links   *MultiEntityLinks `json:"_links,omitempty"`
			Results *[]SpaceBulk      `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSpaceByIdResponse parses an HTTP response from a GetSpaceByIdWithResponse call
func ParseGetSpaceByIdResponse(rsp *http.Response) (*GetSpaceByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSpaceByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Links *struct {
				// Base Base url of the Confluence site.
				Base *string `json:"base,omitempty"`
			} `json:"_links,omitempty"`

			// AuthorId The account ID of the user who created this space originally.
			AuthorId *string `json:"authorId,omitempty"`

			// CreatedAt Date and time when the space was created. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
			CreatedAt *time.Time `json:"createdAt,omitempty"`

			// Description Contains fields for each representation type requested.
			Description *SpaceDescription `json:"description,omitempty"`

			// HomepageId ID of the space's homepage.
			HomepageId *string `json:"homepageId,omitempty"`

			// Icon The icon of the space
			Icon *SpaceIcon `json:"icon,omitempty"`

			// Id ID of the space.
			Id *string `json:"id,omitempty"`

			// Key Key of the space.
			Key    *string `json:"key,omitempty"`
			Labels *struct {
				Links   *OptionalFieldLinks `json:"_links,omitempty"`
				Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
				Results *[]Label            `json:"results,omitempty"`
			} `json:"labels,omitempty"`

			// Name Name of the space.
			Name       *string `json:"name,omitempty"`
			Operations *struct {
				Links   *OptionalFieldLinks `json:"_links,omitempty"`
				Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
				Results *[]Operation        `json:"results,omitempty"`
			} `json:"operations,omitempty"`
			Permissions *struct {
				Links   *OptionalFieldLinks `json:"_links,omitempty"`
				Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
				Results *[]SpacePermission  `json:"results,omitempty"`
			} `json:"permissions,omitempty"`
			Properties *struct {
				Links   *OptionalFieldLinks `json:"_links,omitempty"`
				Meta    *OptionalFieldMeta  `json:"meta,omitempty"`
				Results *[]SpaceProperty    `json:"results,omitempty"`
			} `json:"properties,omitempty"`

			// Status The status of the space.
			Status *SpaceStatus `json:"status,omitempty"`

			// Type The type of space.
			Type *SpaceType `json:"type,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetBlogPostsInSpaceResponse parses an HTTP response from a GetBlogPostsInSpaceWithResponse call
func ParseGetBlogPostsInSpaceResponse(rsp *http.Response) (*GetBlogPostsInSpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBlogPostsInSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Links   *MultiEntityLinks `json:"_links,omitempty"`
			Results *[]BlogPostBulk   `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteSpaceDefaultClassificationLevelResponse parses an HTTP response from a DeleteSpaceDefaultClassificationLevelWithResponse call
func ParseDeleteSpaceDefaultClassificationLevelResponse(rsp *http.Response) (*DeleteSpaceDefaultClassificationLevelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSpaceDefaultClassificationLevelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetSpaceDefaultClassificationLevelResponse parses an HTTP response from a GetSpaceDefaultClassificationLevelWithResponse call
func ParseGetSpaceDefaultClassificationLevelResponse(rsp *http.Response) (*GetSpaceDefaultClassificationLevelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSpaceDefaultClassificationLevelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ClassificationLevel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePutSpaceDefaultClassificationLevelResponse parses an HTTP response from a PutSpaceDefaultClassificationLevelWithResponse call
func ParsePutSpaceDefaultClassificationLevelResponse(rsp *http.Response) (*PutSpaceDefaultClassificationLevelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutSpaceDefaultClassificationLevelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetSpaceContentLabelsResponse parses an HTTP response from a GetSpaceContentLabelsWithResponse call
func ParseGetSpaceContentLabelsResponse(rsp *http.Response) (*GetSpaceContentLabelsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSpaceContentLabelsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Links   *MultiEntityLinks `json:"_links,omitempty"`
			Results *[]Label          `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetCustomContentByTypeInSpaceResponse parses an HTTP response from a GetCustomContentByTypeInSpaceWithResponse call
func ParseGetCustomContentByTypeInSpaceResponse(rsp *http.Response) (*GetCustomContentByTypeInSpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCustomContentByTypeInSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Links   *MultiEntityLinks    `json:"_links,omitempty"`
			Results *[]CustomContentBulk `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSpaceLabelsResponse parses an HTTP response from a GetSpaceLabelsWithResponse call
func ParseGetSpaceLabelsResponse(rsp *http.Response) (*GetSpaceLabelsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSpaceLabelsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Links   *MultiEntityLinks `json:"_links,omitempty"`
			Results *[]Label          `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSpaceOperationsResponse parses an HTTP response from a GetSpaceOperationsWithResponse call
func ParseGetSpaceOperationsResponse(rsp *http.Response) (*GetSpaceOperationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSpaceOperationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PermittedOperationsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPagesInSpaceResponse parses an HTTP response from a GetPagesInSpaceWithResponse call
func ParseGetPagesInSpaceResponse(rsp *http.Response) (*GetPagesInSpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPagesInSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Links   *MultiEntityLinks `json:"_links,omitempty"`
			Results *[]PageBulk       `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSpacePermissionsResponse parses an HTTP response from a GetSpacePermissionsWithResponse call
func ParseGetSpacePermissionsResponse(rsp *http.Response) (*GetSpacePermissionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSpacePermissionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Links   *MultiEntityLinks  `json:"_links,omitempty"`
			Results *[]SpacePermission `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSpacePropertiesResponse parses an HTTP response from a GetSpacePropertiesWithResponse call
func ParseGetSpacePropertiesResponse(rsp *http.Response) (*GetSpacePropertiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSpacePropertiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Links   *MultiEntityLinks `json:"_links,omitempty"`
			Results *[]SpaceProperty  `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateSpacePropertyResponse parses an HTTP response from a CreateSpacePropertyWithResponse call
func ParseCreateSpacePropertyResponse(rsp *http.Response) (*CreateSpacePropertyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSpacePropertyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SpaceProperty
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseDeleteSpacePropertyByIdResponse parses an HTTP response from a DeleteSpacePropertyByIdWithResponse call
func ParseDeleteSpacePropertyByIdResponse(rsp *http.Response) (*DeleteSpacePropertyByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSpacePropertyByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetSpacePropertyByIdResponse parses an HTTP response from a GetSpacePropertyByIdWithResponse call
func ParseGetSpacePropertyByIdResponse(rsp *http.Response) (*GetSpacePropertyByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSpacePropertyByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SpaceProperty
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateSpacePropertyByIdResponse parses an HTTP response from a UpdateSpacePropertyByIdWithResponse call
func ParseUpdateSpacePropertyByIdResponse(rsp *http.Response) (*UpdateSpacePropertyByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateSpacePropertyByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SpaceProperty
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetTasksResponse parses an HTTP response from a GetTasksWithResponse call
func ParseGetTasksResponse(rsp *http.Response) (*GetTasksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTasksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Links   *MultiEntityLinks `json:"_links,omitempty"`
			Results *[]Task           `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetTaskByIdResponse parses an HTTP response from a GetTaskByIdWithResponse call
func ParseGetTaskByIdResponse(rsp *http.Response) (*GetTaskByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTaskByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Task
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateTaskResponse parses an HTTP response from a UpdateTaskWithResponse call
func ParseUpdateTaskResponse(rsp *http.Response) (*UpdateTaskResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateTaskResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Task
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCheckAccessByEmailResponse parses an HTTP response from a CheckAccessByEmailWithResponse call
func ParseCheckAccessByEmailResponse(rsp *http.Response) (*CheckAccessByEmailResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CheckAccessByEmailResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// EmailsWithoutAccess List of emails that do not have access to site.
			EmailsWithoutAccess *[]string `json:"emailsWithoutAccess,omitempty"`

			// InvalidEmails List of invalid emails provided in the request.
			InvalidEmails *[]string `json:"invalidEmails,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseInviteByEmailResponse parses an HTTP response from a InviteByEmailWithResponse call
func ParseInviteByEmailResponse(rsp *http.Response) (*InviteByEmailResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InviteByEmailResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateBulkUserLookupResponse parses an HTTP response from a CreateBulkUserLookupWithResponse call
func ParseCreateBulkUserLookupResponse(rsp *http.Response) (*CreateBulkUserLookupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateBulkUserLookupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Links   *MultiEntityLinks `json:"_links,omitempty"`
			Results *[]User           `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateWhiteboardResponse parses an HTTP response from a CreateWhiteboardWithResponse call
func ParseCreateWhiteboardResponse(rsp *http.Response) (*CreateWhiteboardResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateWhiteboardResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Links *struct {
				// Base Base url of the Confluence site.
				Base *string `json:"base,omitempty"`
			} `json:"_links,omitempty"`

			// AuthorId The account ID of the user who created this whiteboard originally.
			AuthorId *string `json:"authorId,omitempty"`

			// CreatedAt Date and time when the whiteboard was created. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
			CreatedAt *time.Time `json:"createdAt,omitempty"`

			// Id ID of the whiteboard.
			Id *string `json:"id,omitempty"`

			// OwnerId The account ID of the user who owns this whiteboard.
			OwnerId *string `json:"ownerId,omitempty"`

			// ParentId ID of the parent content, or null if there is no parent content.
			ParentId *string `json:"parentId,omitempty"`

			// ParentType Content type of the parent, or null if there is no parent.
			ParentType *ParentContentType `json:"parentType,omitempty"`

			// Position Position of the whiteboard within the given parent page tree.
			Position *int32 `json:"position"`

			// Status The status of the content.
			Status *ContentStatus `json:"status,omitempty"`

			// Title Title of the whiteboard.
			Title *string `json:"title,omitempty"`

			// Type The content type of the object.
			Type    *string  `json:"type,omitempty"`
			Version *Version `json:"version,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteWhiteboardResponse parses an HTTP response from a DeleteWhiteboardWithResponse call
func ParseDeleteWhiteboardResponse(rsp *http.Response) (*DeleteWhiteboardResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteWhiteboardResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetWhiteboardByIdResponse parses an HTTP response from a GetWhiteboardByIdWithResponse call
func ParseGetWhiteboardByIdResponse(rsp *http.Response) (*GetWhiteboardByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWhiteboardByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Links *struct {
				// Base Base url of the Confluence site.
				Base *string `json:"base,omitempty"`
			} `json:"_links,omitempty"`

			// AuthorId The account ID of the user who created this whiteboard originally.
			AuthorId *string `json:"authorId,omitempty"`

			// CreatedAt Date and time when the whiteboard was created. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
			CreatedAt *time.Time `json:"createdAt,omitempty"`

			// Id ID of the whiteboard.
			Id *string `json:"id,omitempty"`

			// OwnerId The account ID of the user who owns this whiteboard.
			OwnerId *string `json:"ownerId,omitempty"`

			// ParentId ID of the parent content, or null if there is no parent content.
			ParentId *string `json:"parentId,omitempty"`

			// ParentType Content type of the parent, or null if there is no parent.
			ParentType *ParentContentType `json:"parentType,omitempty"`

			// Position Position of the whiteboard within the given parent page tree.
			Position *int32 `json:"position"`

			// Status The status of the content.
			Status *ContentStatus `json:"status,omitempty"`

			// Title Title of the whiteboard.
			Title *string `json:"title,omitempty"`

			// Type The content type of the object.
			Type    *string  `json:"type,omitempty"`
			Version *Version `json:"version,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetWhiteboardAncestorsResponse parses an HTTP response from a GetWhiteboardAncestorsWithResponse call
func ParseGetWhiteboardAncestorsResponse(rsp *http.Response) (*GetWhiteboardAncestorsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWhiteboardAncestorsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Results *[]Ancestor `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetWhiteboardClassificationLevelResponse parses an HTTP response from a GetWhiteboardClassificationLevelWithResponse call
func ParseGetWhiteboardClassificationLevelResponse(rsp *http.Response) (*GetWhiteboardClassificationLevelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWhiteboardClassificationLevelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ClassificationLevel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePutWhiteboardClassificationLevelResponse parses an HTTP response from a PutWhiteboardClassificationLevelWithResponse call
func ParsePutWhiteboardClassificationLevelResponse(rsp *http.Response) (*PutWhiteboardClassificationLevelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutWhiteboardClassificationLevelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePostWhiteboardClassificationLevelResponse parses an HTTP response from a PostWhiteboardClassificationLevelWithResponse call
func ParsePostWhiteboardClassificationLevelResponse(rsp *http.Response) (*PostWhiteboardClassificationLevelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostWhiteboardClassificationLevelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetWhiteboardOperationsResponse parses an HTTP response from a GetWhiteboardOperationsWithResponse call
func ParseGetWhiteboardOperationsResponse(rsp *http.Response) (*GetWhiteboardOperationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWhiteboardOperationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PermittedOperationsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetWhiteboardContentPropertiesResponse parses an HTTP response from a GetWhiteboardContentPropertiesWithResponse call
func ParseGetWhiteboardContentPropertiesResponse(rsp *http.Response) (*GetWhiteboardContentPropertiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWhiteboardContentPropertiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Links   *MultiEntityLinks  `json:"_links,omitempty"`
			Results *[]ContentProperty `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateWhiteboardPropertyResponse parses an HTTP response from a CreateWhiteboardPropertyWithResponse call
func ParseCreateWhiteboardPropertyResponse(rsp *http.Response) (*CreateWhiteboardPropertyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateWhiteboardPropertyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ContentProperty
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteWhiteboardPropertyByIdResponse parses an HTTP response from a DeleteWhiteboardPropertyByIdWithResponse call
func ParseDeleteWhiteboardPropertyByIdResponse(rsp *http.Response) (*DeleteWhiteboardPropertyByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteWhiteboardPropertyByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetWhiteboardContentPropertiesByIdResponse parses an HTTP response from a GetWhiteboardContentPropertiesByIdWithResponse call
func ParseGetWhiteboardContentPropertiesByIdResponse(rsp *http.Response) (*GetWhiteboardContentPropertiesByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWhiteboardContentPropertiesByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ContentProperty
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateWhiteboardPropertyByIdResponse parses an HTTP response from a UpdateWhiteboardPropertyByIdWithResponse call
func ParseUpdateWhiteboardPropertyByIdResponse(rsp *http.Response) (*UpdateWhiteboardPropertyByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateWhiteboardPropertyByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ContentProperty
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}
