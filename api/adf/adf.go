// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package adf

import "encoding/json"
import "fmt"
import "reflect"
import "regexp"
import "strings"
import "github.com/go-viper/mapstructure/v2"

type AlignmentMark struct {
	// Attrs corresponds to the JSON schema field "attrs".
	Attrs AlignmentMarkAttrs `json:"attrs" yaml:"attrs" mapstructure:"attrs"`

	// Type corresponds to the JSON schema field "type".
	Type AlignmentMarkType `json:"type" yaml:"type" mapstructure:"type"`
}

type AlignmentMarkAttrs struct {
	// Align corresponds to the JSON schema field "align".
	Align AlignmentMarkAttrsAlign `json:"align" yaml:"align" mapstructure:"align"`
}

type AlignmentMarkAttrsAlign string

const AlignmentMarkAttrsAlignCenter AlignmentMarkAttrsAlign = "center"
const AlignmentMarkAttrsAlignEnd AlignmentMarkAttrsAlign = "end"

var enumValues_AlignmentMarkAttrsAlign = []interface{}{
	"center",
	"end",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AlignmentMarkAttrsAlign) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_AlignmentMarkAttrsAlign {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_AlignmentMarkAttrsAlign, v)
	}
	*j = AlignmentMarkAttrsAlign(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AlignmentMarkAttrs) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["align"]; raw != nil && !ok {
		return fmt.Errorf("field align in AlignmentMarkAttrs: required")
	}
	type Plain AlignmentMarkAttrs
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = AlignmentMarkAttrs(plain)
	return nil
}

type AlignmentMarkType string

const AlignmentMarkTypeAlignment AlignmentMarkType = "alignment"

var enumValues_AlignmentMarkType = []interface{}{
	"alignment",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AlignmentMarkType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_AlignmentMarkType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_AlignmentMarkType, v)
	}
	*j = AlignmentMarkType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AlignmentMark) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["attrs"]; raw != nil && !ok {
		return fmt.Errorf("field attrs in AlignmentMark: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in AlignmentMark: required")
	}
	type Plain AlignmentMark
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = AlignmentMark(plain)
	return nil
}

type AnnotationMark struct {
	// Attrs corresponds to the JSON schema field "attrs".
	Attrs AnnotationMarkAttrs `json:"attrs" yaml:"attrs" mapstructure:"attrs"`

	// Type corresponds to the JSON schema field "type".
	Type AnnotationMarkType `json:"type" yaml:"type" mapstructure:"type"`
}

type AnnotationMarkAttrs struct {
	// AnnotationType corresponds to the JSON schema field "annotationType".
	AnnotationType AnnotationMarkAttrsAnnotationType `json:"annotationType" yaml:"annotationType" mapstructure:"annotationType"`

	// Id corresponds to the JSON schema field "id".
	Id string `json:"id" yaml:"id" mapstructure:"id"`
}

type AnnotationMarkAttrsAnnotationType string

const AnnotationMarkAttrsAnnotationTypeInlineComment AnnotationMarkAttrsAnnotationType = "inlineComment"

var enumValues_AnnotationMarkAttrsAnnotationType = []interface{}{
	"inlineComment",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AnnotationMarkAttrsAnnotationType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_AnnotationMarkAttrsAnnotationType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_AnnotationMarkAttrsAnnotationType, v)
	}
	*j = AnnotationMarkAttrsAnnotationType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AnnotationMarkAttrs) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["annotationType"]; raw != nil && !ok {
		return fmt.Errorf("field annotationType in AnnotationMarkAttrs: required")
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in AnnotationMarkAttrs: required")
	}
	type Plain AnnotationMarkAttrs
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = AnnotationMarkAttrs(plain)
	return nil
}

type AnnotationMarkType string

const AnnotationMarkTypeAnnotation AnnotationMarkType = "annotation"

var enumValues_AnnotationMarkType = []interface{}{
	"annotation",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AnnotationMarkType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_AnnotationMarkType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_AnnotationMarkType, v)
	}
	*j = AnnotationMarkType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AnnotationMark) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["attrs"]; raw != nil && !ok {
		return fmt.Errorf("field attrs in AnnotationMark: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in AnnotationMark: required")
	}
	type Plain AnnotationMark
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = AnnotationMark(plain)
	return nil
}

type BackgroundColorMark struct {
	// Attrs corresponds to the JSON schema field "attrs".
	Attrs BackgroundColorMarkAttrs `json:"attrs" yaml:"attrs" mapstructure:"attrs"`

	// Type corresponds to the JSON schema field "type".
	Type BackgroundColorMarkType `json:"type" yaml:"type" mapstructure:"type"`
}

type BackgroundColorMarkAttrs struct {
	// Color corresponds to the JSON schema field "color".
	Color string `json:"color" yaml:"color" mapstructure:"color"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BackgroundColorMarkAttrs) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["color"]; raw != nil && !ok {
		return fmt.Errorf("field color in BackgroundColorMarkAttrs: required")
	}
	type Plain BackgroundColorMarkAttrs
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if matched, _ := regexp.MatchString("^#[0-9a-fA-F]{6}$", string(plain.Color)); !matched {
		return fmt.Errorf("field %s pattern match: must match %s", "^#[0-9a-fA-F]{6}$", "Color")
	}
	*j = BackgroundColorMarkAttrs(plain)
	return nil
}

type BackgroundColorMarkType string

const BackgroundColorMarkTypeBackgroundColor BackgroundColorMarkType = "backgroundColor"

var enumValues_BackgroundColorMarkType = []interface{}{
	"backgroundColor",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BackgroundColorMarkType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_BackgroundColorMarkType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_BackgroundColorMarkType, v)
	}
	*j = BackgroundColorMarkType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BackgroundColorMark) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["attrs"]; raw != nil && !ok {
		return fmt.Errorf("field attrs in BackgroundColorMark: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in BackgroundColorMark: required")
	}
	type Plain BackgroundColorMark
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = BackgroundColorMark(plain)
	return nil
}

type BlockCardNode struct {
	// Attrs corresponds to the JSON schema field "attrs".
	Attrs interface{} `json:"attrs" yaml:"attrs" mapstructure:"attrs"`

	// Type corresponds to the JSON schema field "type".
	Type BlockCardNodeType `json:"type" yaml:"type" mapstructure:"type"`
}

type BlockCardNodeType string

const BlockCardNodeTypeBlockCard BlockCardNodeType = "blockCard"

var enumValues_BlockCardNodeType = []interface{}{
	"blockCard",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BlockCardNodeType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_BlockCardNodeType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_BlockCardNodeType, v)
	}
	*j = BlockCardNodeType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BlockCardNode) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["attrs"]; raw != nil && !ok {
		return fmt.Errorf("field attrs in BlockCardNode: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in BlockCardNode: required")
	}
	type Plain BlockCardNode
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = BlockCardNode(plain)
	return nil
}

type BlockContent interface{}

type BlockquoteNode struct {
	// Content corresponds to the JSON schema field "content".
	Content []interface{} `json:"content" yaml:"content" mapstructure:"content"`

	// Type corresponds to the JSON schema field "type".
	Type BlockquoteNodeType `json:"type" yaml:"type" mapstructure:"type"`
}

type BlockquoteNodeType string

const BlockquoteNodeTypeBlockquote BlockquoteNodeType = "blockquote"

var enumValues_BlockquoteNodeType = []interface{}{
	"blockquote",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BlockquoteNodeType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_BlockquoteNodeType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_BlockquoteNodeType, v)
	}
	*j = BlockquoteNodeType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BlockquoteNode) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["content"]; raw != nil && !ok {
		return fmt.Errorf("field content in BlockquoteNode: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in BlockquoteNode: required")
	}
	type Plain BlockquoteNode
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.Content != nil && len(plain.Content) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "content", 1)
	}
	*j = BlockquoteNode(plain)
	return nil
}

type BodiedExtensionNode struct {
	// Attrs corresponds to the JSON schema field "attrs".
	Attrs BodiedExtensionNodeAttrs `json:"attrs" yaml:"attrs" mapstructure:"attrs"`

	// Content corresponds to the JSON schema field "content".
	Content []BodiedExtensionNodeContentElem `json:"content" yaml:"content" mapstructure:"content"`

	// Marks corresponds to the JSON schema field "marks".
	Marks []interface{} `json:"marks,omitempty" yaml:"marks,omitempty" mapstructure:"marks,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type BodiedExtensionNodeType `json:"type" yaml:"type" mapstructure:"type"`
}

type BodiedExtensionNodeAttrs struct {
	// ExtensionKey corresponds to the JSON schema field "extensionKey".
	ExtensionKey string `json:"extensionKey" yaml:"extensionKey" mapstructure:"extensionKey"`

	// ExtensionType corresponds to the JSON schema field "extensionType".
	ExtensionType string `json:"extensionType" yaml:"extensionType" mapstructure:"extensionType"`

	// Layout corresponds to the JSON schema field "layout".
	Layout *BodiedExtensionNodeAttrsLayout `json:"layout,omitempty" yaml:"layout,omitempty" mapstructure:"layout,omitempty"`

	// LocalId corresponds to the JSON schema field "localId".
	LocalId *string `json:"localId,omitempty" yaml:"localId,omitempty" mapstructure:"localId,omitempty"`

	// Parameters corresponds to the JSON schema field "parameters".
	Parameters interface{} `json:"parameters,omitempty" yaml:"parameters,omitempty" mapstructure:"parameters,omitempty"`

	// Text corresponds to the JSON schema field "text".
	Text *string `json:"text,omitempty" yaml:"text,omitempty" mapstructure:"text,omitempty"`
}

type BodiedExtensionNodeAttrsLayout string

const BodiedExtensionNodeAttrsLayoutDefault BodiedExtensionNodeAttrsLayout = "default"
const BodiedExtensionNodeAttrsLayoutFullWidth BodiedExtensionNodeAttrsLayout = "full-width"
const BodiedExtensionNodeAttrsLayoutWide BodiedExtensionNodeAttrsLayout = "wide"

var enumValues_BodiedExtensionNodeAttrsLayout = []interface{}{
	"wide",
	"full-width",
	"default",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BodiedExtensionNodeAttrsLayout) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_BodiedExtensionNodeAttrsLayout {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_BodiedExtensionNodeAttrsLayout, v)
	}
	*j = BodiedExtensionNodeAttrsLayout(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BodiedExtensionNodeAttrs) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["extensionKey"]; raw != nil && !ok {
		return fmt.Errorf("field extensionKey in BodiedExtensionNodeAttrs: required")
	}
	if _, ok := raw["extensionType"]; raw != nil && !ok {
		return fmt.Errorf("field extensionType in BodiedExtensionNodeAttrs: required")
	}
	type Plain BodiedExtensionNodeAttrs
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if len(plain.ExtensionKey) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "extensionKey", 1)
	}
	if len(plain.ExtensionType) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "extensionType", 1)
	}
	if plain.LocalId != nil && len(*plain.LocalId) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "localId", 1)
	}
	*j = BodiedExtensionNodeAttrs(plain)
	return nil
}

type BodiedExtensionNodeContentElem interface{}

type BodiedExtensionNodeType string

const BodiedExtensionNodeTypeBodiedExtension BodiedExtensionNodeType = "bodiedExtension"

var enumValues_BodiedExtensionNodeType = []interface{}{
	"bodiedExtension",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BodiedExtensionNodeType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_BodiedExtensionNodeType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_BodiedExtensionNodeType, v)
	}
	*j = BodiedExtensionNodeType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BodiedExtensionNode) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["attrs"]; raw != nil && !ok {
		return fmt.Errorf("field attrs in BodiedExtensionNode: required")
	}
	if _, ok := raw["content"]; raw != nil && !ok {
		return fmt.Errorf("field content in BodiedExtensionNode: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in BodiedExtensionNode: required")
	}
	type Plain BodiedExtensionNode
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.Content != nil && len(plain.Content) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "content", 1)
	}
	*j = BodiedExtensionNode(plain)
	return nil
}

type BodiedExtensionWithMarksNode interface{}

type BorderMark struct {
	// Attrs corresponds to the JSON schema field "attrs".
	Attrs BorderMarkAttrs `json:"attrs" yaml:"attrs" mapstructure:"attrs"`

	// Type corresponds to the JSON schema field "type".
	Type BorderMarkType `json:"type" yaml:"type" mapstructure:"type"`
}

type BorderMarkAttrs struct {
	// Color corresponds to the JSON schema field "color".
	Color string `json:"color" yaml:"color" mapstructure:"color"`

	// Size corresponds to the JSON schema field "size".
	Size float64 `json:"size" yaml:"size" mapstructure:"size"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BorderMarkAttrs) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["color"]; raw != nil && !ok {
		return fmt.Errorf("field color in BorderMarkAttrs: required")
	}
	if _, ok := raw["size"]; raw != nil && !ok {
		return fmt.Errorf("field size in BorderMarkAttrs: required")
	}
	type Plain BorderMarkAttrs
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if matched, _ := regexp.MatchString("^#[0-9a-fA-F]{8}$|^#[0-9a-fA-F]{6}$", string(plain.Color)); !matched {
		return fmt.Errorf("field %s pattern match: must match %s", "^#[0-9a-fA-F]{8}$|^#[0-9a-fA-F]{6}$", "Color")
	}
	if 3 < plain.Size {
		return fmt.Errorf("field %s: must be <= %v", "size", 3)
	}
	if 1 > plain.Size {
		return fmt.Errorf("field %s: must be >= %v", "size", 1)
	}
	*j = BorderMarkAttrs(plain)
	return nil
}

type BorderMarkType string

const BorderMarkTypeBorder BorderMarkType = "border"

var enumValues_BorderMarkType = []interface{}{
	"border",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BorderMarkType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_BorderMarkType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_BorderMarkType, v)
	}
	*j = BorderMarkType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BorderMark) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["attrs"]; raw != nil && !ok {
		return fmt.Errorf("field attrs in BorderMark: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in BorderMark: required")
	}
	type Plain BorderMark
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = BorderMark(plain)
	return nil
}

type BreakoutMark struct {
	// Attrs corresponds to the JSON schema field "attrs".
	Attrs BreakoutMarkAttrs `json:"attrs" yaml:"attrs" mapstructure:"attrs"`

	// Type corresponds to the JSON schema field "type".
	Type BreakoutMarkType `json:"type" yaml:"type" mapstructure:"type"`
}

type BreakoutMarkAttrs struct {
	// Mode corresponds to the JSON schema field "mode".
	Mode BreakoutMarkAttrsMode `json:"mode" yaml:"mode" mapstructure:"mode"`

	// Width corresponds to the JSON schema field "width".
	Width *float64 `json:"width,omitempty" yaml:"width,omitempty" mapstructure:"width,omitempty"`
}

type BreakoutMarkAttrsMode string

const BreakoutMarkAttrsModeFullWidth BreakoutMarkAttrsMode = "full-width"
const BreakoutMarkAttrsModeWide BreakoutMarkAttrsMode = "wide"

var enumValues_BreakoutMarkAttrsMode = []interface{}{
	"wide",
	"full-width",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BreakoutMarkAttrsMode) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_BreakoutMarkAttrsMode {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_BreakoutMarkAttrsMode, v)
	}
	*j = BreakoutMarkAttrsMode(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BreakoutMarkAttrs) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["mode"]; raw != nil && !ok {
		return fmt.Errorf("field mode in BreakoutMarkAttrs: required")
	}
	type Plain BreakoutMarkAttrs
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = BreakoutMarkAttrs(plain)
	return nil
}

type BreakoutMarkType string

const BreakoutMarkTypeBreakout BreakoutMarkType = "breakout"

var enumValues_BreakoutMarkType = []interface{}{
	"breakout",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BreakoutMarkType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_BreakoutMarkType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_BreakoutMarkType, v)
	}
	*j = BreakoutMarkType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BreakoutMark) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["attrs"]; raw != nil && !ok {
		return fmt.Errorf("field attrs in BreakoutMark: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in BreakoutMark: required")
	}
	type Plain BreakoutMark
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = BreakoutMark(plain)
	return nil
}

type CaptionNode struct {
	// Content corresponds to the JSON schema field "content".
	Content []interface{} `json:"content,omitempty" yaml:"content,omitempty" mapstructure:"content,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type CaptionNodeType `json:"type" yaml:"type" mapstructure:"type"`
}

type CaptionNodeType string

const CaptionNodeTypeCaption CaptionNodeType = "caption"

var enumValues_CaptionNodeType = []interface{}{
	"caption",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CaptionNodeType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_CaptionNodeType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_CaptionNodeType, v)
	}
	*j = CaptionNodeType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CaptionNode) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in CaptionNode: required")
	}
	type Plain CaptionNode
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CaptionNode(plain)
	return nil
}

type CodeBlockNode struct {
	// Attrs corresponds to the JSON schema field "attrs".
	Attrs *CodeBlockNodeAttrs `json:"attrs,omitempty" yaml:"attrs,omitempty" mapstructure:"attrs,omitempty"`

	// Content corresponds to the JSON schema field "content".
	Content []interface{} `json:"content,omitempty" yaml:"content,omitempty" mapstructure:"content,omitempty"`

	// Marks corresponds to the JSON schema field "marks".
	Marks []interface{} `json:"marks,omitempty" yaml:"marks,omitempty" mapstructure:"marks,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type CodeBlockNodeType `json:"type" yaml:"type" mapstructure:"type"`
}

type CodeBlockNodeAttrs struct {
	// Language corresponds to the JSON schema field "language".
	Language *string `json:"language,omitempty" yaml:"language,omitempty" mapstructure:"language,omitempty"`
}

type CodeBlockNodeType string

const CodeBlockNodeTypeCodeBlock CodeBlockNodeType = "codeBlock"

var enumValues_CodeBlockNodeType = []interface{}{
	"codeBlock",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CodeBlockNodeType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_CodeBlockNodeType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_CodeBlockNodeType, v)
	}
	*j = CodeBlockNodeType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CodeBlockNode) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in CodeBlockNode: required")
	}
	type Plain CodeBlockNode
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CodeBlockNode(plain)
	return nil
}

type CodeBlockWithMarksNode interface{}

type CodeBlockWithNoMarksNode interface{}

type CodeInlineNode interface{}

type CodeMark struct {
	// Type corresponds to the JSON schema field "type".
	Type CodeMarkType `json:"type" yaml:"type" mapstructure:"type"`
}

type CodeMarkType string

const CodeMarkTypeCode CodeMarkType = "code"

var enumValues_CodeMarkType = []interface{}{
	"code",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CodeMarkType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_CodeMarkType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_CodeMarkType, v)
	}
	*j = CodeMarkType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CodeMark) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in CodeMark: required")
	}
	type Plain CodeMark
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CodeMark(plain)
	return nil
}

type DataConsumerMark struct {
	// Attrs corresponds to the JSON schema field "attrs".
	Attrs DataConsumerMarkAttrs `json:"attrs" yaml:"attrs" mapstructure:"attrs"`

	// Type corresponds to the JSON schema field "type".
	Type DataConsumerMarkType `json:"type" yaml:"type" mapstructure:"type"`
}

type DataConsumerMarkAttrs struct {
	// Sources corresponds to the JSON schema field "sources".
	Sources []string `json:"sources" yaml:"sources" mapstructure:"sources"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DataConsumerMarkAttrs) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["sources"]; raw != nil && !ok {
		return fmt.Errorf("field sources in DataConsumerMarkAttrs: required")
	}
	type Plain DataConsumerMarkAttrs
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.Sources != nil && len(plain.Sources) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "sources", 1)
	}
	*j = DataConsumerMarkAttrs(plain)
	return nil
}

type DataConsumerMarkType string

const DataConsumerMarkTypeDataConsumer DataConsumerMarkType = "dataConsumer"

var enumValues_DataConsumerMarkType = []interface{}{
	"dataConsumer",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DataConsumerMarkType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_DataConsumerMarkType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_DataConsumerMarkType, v)
	}
	*j = DataConsumerMarkType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DataConsumerMark) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["attrs"]; raw != nil && !ok {
		return fmt.Errorf("field attrs in DataConsumerMark: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in DataConsumerMark: required")
	}
	type Plain DataConsumerMark
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = DataConsumerMark(plain)
	return nil
}

type DateNode struct {
	// Attrs corresponds to the JSON schema field "attrs".
	Attrs DateNodeAttrs `json:"attrs" yaml:"attrs" mapstructure:"attrs"`

	// Type corresponds to the JSON schema field "type".
	Type DateNodeType `json:"type" yaml:"type" mapstructure:"type"`
}

type DateNodeAttrs struct {
	// Timestamp corresponds to the JSON schema field "timestamp".
	Timestamp string `json:"timestamp" yaml:"timestamp" mapstructure:"timestamp"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DateNodeAttrs) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["timestamp"]; raw != nil && !ok {
		return fmt.Errorf("field timestamp in DateNodeAttrs: required")
	}
	type Plain DateNodeAttrs
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if len(plain.Timestamp) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "timestamp", 1)
	}
	*j = DateNodeAttrs(plain)
	return nil
}

type DateNodeType string

const DateNodeTypeDate DateNodeType = "date"

var enumValues_DateNodeType = []interface{}{
	"date",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DateNodeType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_DateNodeType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_DateNodeType, v)
	}
	*j = DateNodeType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DateNode) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["attrs"]; raw != nil && !ok {
		return fmt.Errorf("field attrs in DateNode: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in DateNode: required")
	}
	type Plain DateNode
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = DateNode(plain)
	return nil
}

type DecisionItemNode struct {
	// Attrs corresponds to the JSON schema field "attrs".
	Attrs DecisionItemNodeAttrs `json:"attrs" yaml:"attrs" mapstructure:"attrs"`

	// Content corresponds to the JSON schema field "content".
	Content []DecisionItemNodeContentElem `json:"content,omitempty" yaml:"content,omitempty" mapstructure:"content,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type DecisionItemNodeType `json:"type" yaml:"type" mapstructure:"type"`
}

type DecisionItemNodeAttrs struct {
	// LocalId corresponds to the JSON schema field "localId".
	LocalId string `json:"localId" yaml:"localId" mapstructure:"localId"`

	// State corresponds to the JSON schema field "state".
	State string `json:"state" yaml:"state" mapstructure:"state"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DecisionItemNodeAttrs) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["localId"]; raw != nil && !ok {
		return fmt.Errorf("field localId in DecisionItemNodeAttrs: required")
	}
	if _, ok := raw["state"]; raw != nil && !ok {
		return fmt.Errorf("field state in DecisionItemNodeAttrs: required")
	}
	type Plain DecisionItemNodeAttrs
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = DecisionItemNodeAttrs(plain)
	return nil
}

type DecisionItemNodeContentElem interface{}

type DecisionItemNodeType string

const DecisionItemNodeTypeDecisionItem DecisionItemNodeType = "decisionItem"

var enumValues_DecisionItemNodeType = []interface{}{
	"decisionItem",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DecisionItemNodeType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_DecisionItemNodeType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_DecisionItemNodeType, v)
	}
	*j = DecisionItemNodeType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DecisionItemNode) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["attrs"]; raw != nil && !ok {
		return fmt.Errorf("field attrs in DecisionItemNode: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in DecisionItemNode: required")
	}
	type Plain DecisionItemNode
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = DecisionItemNode(plain)
	return nil
}

type DecisionListNode struct {
	// Attrs corresponds to the JSON schema field "attrs".
	Attrs DecisionListNodeAttrs `json:"attrs" yaml:"attrs" mapstructure:"attrs"`

	// Content corresponds to the JSON schema field "content".
	Content []DecisionItemNode `json:"content" yaml:"content" mapstructure:"content"`

	// Type corresponds to the JSON schema field "type".
	Type DecisionListNodeType `json:"type" yaml:"type" mapstructure:"type"`
}

type DecisionListNodeAttrs struct {
	// LocalId corresponds to the JSON schema field "localId".
	LocalId string `json:"localId" yaml:"localId" mapstructure:"localId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DecisionListNodeAttrs) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["localId"]; raw != nil && !ok {
		return fmt.Errorf("field localId in DecisionListNodeAttrs: required")
	}
	type Plain DecisionListNodeAttrs
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = DecisionListNodeAttrs(plain)
	return nil
}

type DecisionListNodeType string

const DecisionListNodeTypeDecisionList DecisionListNodeType = "decisionList"

var enumValues_DecisionListNodeType = []interface{}{
	"decisionList",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DecisionListNodeType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_DecisionListNodeType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_DecisionListNodeType, v)
	}
	*j = DecisionListNodeType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DecisionListNode) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["attrs"]; raw != nil && !ok {
		return fmt.Errorf("field attrs in DecisionListNode: required")
	}
	if _, ok := raw["content"]; raw != nil && !ok {
		return fmt.Errorf("field content in DecisionListNode: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in DecisionListNode: required")
	}
	type Plain DecisionListNode
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.Content != nil && len(plain.Content) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "content", 1)
	}
	*j = DecisionListNode(plain)
	return nil
}

type DocNode struct {
	// Content corresponds to the JSON schema field "content".
	Content []interface{} `json:"content" yaml:"content" mapstructure:"content"`

	// Type corresponds to the JSON schema field "type".
	Type DocNodeType `json:"type" yaml:"type" mapstructure:"type"`

	// Version corresponds to the JSON schema field "version".
	Version DocNodeVersion `json:"version" yaml:"version" mapstructure:"version"`
}

type DocNodeType string

const DocNodeTypeDoc DocNodeType = "doc"

var enumValues_DocNodeType = []interface{}{
	"doc",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DocNodeType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_DocNodeType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_DocNodeType, v)
	}
	*j = DocNodeType(v)
	return nil
}

type DocNodeVersion float64

var enumValues_DocNodeVersion = []interface{}{
	1.0,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DocNodeVersion) UnmarshalJSON(b []byte) error {
	var v float64
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_DocNodeVersion {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_DocNodeVersion, v)
	}
	*j = DocNodeVersion(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DocNode) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["content"]; raw != nil && !ok {
		return fmt.Errorf("field content in DocNode: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in DocNode: required")
	}
	if _, ok := raw["version"]; raw != nil && !ok {
		return fmt.Errorf("field version in DocNode: required")
	}
	type Plain DocNode
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = DocNode(plain)
	return nil
}

type EmMark struct {
	// Type corresponds to the JSON schema field "type".
	Type EmMarkType `json:"type" yaml:"type" mapstructure:"type"`
}

type EmMarkType string

const EmMarkTypeEm EmMarkType = "em"

var enumValues_EmMarkType = []interface{}{
	"em",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EmMarkType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_EmMarkType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_EmMarkType, v)
	}
	*j = EmMarkType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EmMark) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in EmMark: required")
	}
	type Plain EmMark
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = EmMark(plain)
	return nil
}

type EmbedCardNode struct {
	// Attrs corresponds to the JSON schema field "attrs".
	Attrs EmbedCardNodeAttrs `json:"attrs" yaml:"attrs" mapstructure:"attrs"`

	// Type corresponds to the JSON schema field "type".
	Type EmbedCardNodeType `json:"type" yaml:"type" mapstructure:"type"`
}

type EmbedCardNodeAttrs struct {
	// Layout corresponds to the JSON schema field "layout".
	Layout EmbedCardNodeAttrsLayout `json:"layout" yaml:"layout" mapstructure:"layout"`

	// OriginalHeight corresponds to the JSON schema field "originalHeight".
	OriginalHeight *float64 `json:"originalHeight,omitempty" yaml:"originalHeight,omitempty" mapstructure:"originalHeight,omitempty"`

	// OriginalWidth corresponds to the JSON schema field "originalWidth".
	OriginalWidth *float64 `json:"originalWidth,omitempty" yaml:"originalWidth,omitempty" mapstructure:"originalWidth,omitempty"`

	// Url corresponds to the JSON schema field "url".
	Url string `json:"url" yaml:"url" mapstructure:"url"`

	// Width corresponds to the JSON schema field "width".
	Width *float64 `json:"width,omitempty" yaml:"width,omitempty" mapstructure:"width,omitempty"`
}

type EmbedCardNodeAttrsLayout string

const EmbedCardNodeAttrsLayoutAlignEnd EmbedCardNodeAttrsLayout = "align-end"
const EmbedCardNodeAttrsLayoutAlignStart EmbedCardNodeAttrsLayout = "align-start"
const EmbedCardNodeAttrsLayoutCenter EmbedCardNodeAttrsLayout = "center"
const EmbedCardNodeAttrsLayoutFullWidth EmbedCardNodeAttrsLayout = "full-width"
const EmbedCardNodeAttrsLayoutWide EmbedCardNodeAttrsLayout = "wide"
const EmbedCardNodeAttrsLayoutWrapLeft EmbedCardNodeAttrsLayout = "wrap-left"
const EmbedCardNodeAttrsLayoutWrapRight EmbedCardNodeAttrsLayout = "wrap-right"

var enumValues_EmbedCardNodeAttrsLayout = []interface{}{
	"wide",
	"full-width",
	"center",
	"wrap-right",
	"wrap-left",
	"align-end",
	"align-start",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EmbedCardNodeAttrsLayout) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_EmbedCardNodeAttrsLayout {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_EmbedCardNodeAttrsLayout, v)
	}
	*j = EmbedCardNodeAttrsLayout(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EmbedCardNodeAttrs) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["layout"]; raw != nil && !ok {
		return fmt.Errorf("field layout in EmbedCardNodeAttrs: required")
	}
	if _, ok := raw["url"]; raw != nil && !ok {
		return fmt.Errorf("field url in EmbedCardNodeAttrs: required")
	}
	type Plain EmbedCardNodeAttrs
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.Width != nil && 100 < *plain.Width {
		return fmt.Errorf("field %s: must be <= %v", "width", 100)
	}
	if plain.Width != nil && 0 > *plain.Width {
		return fmt.Errorf("field %s: must be >= %v", "width", 0)
	}
	*j = EmbedCardNodeAttrs(plain)
	return nil
}

type EmbedCardNodeType string

const EmbedCardNodeTypeEmbedCard EmbedCardNodeType = "embedCard"

var enumValues_EmbedCardNodeType = []interface{}{
	"embedCard",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EmbedCardNodeType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_EmbedCardNodeType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_EmbedCardNodeType, v)
	}
	*j = EmbedCardNodeType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EmbedCardNode) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["attrs"]; raw != nil && !ok {
		return fmt.Errorf("field attrs in EmbedCardNode: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in EmbedCardNode: required")
	}
	type Plain EmbedCardNode
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = EmbedCardNode(plain)
	return nil
}

type EmojiNode struct {
	// Attrs corresponds to the JSON schema field "attrs".
	Attrs EmojiNodeAttrs `json:"attrs" yaml:"attrs" mapstructure:"attrs"`

	// Type corresponds to the JSON schema field "type".
	Type EmojiNodeType `json:"type" yaml:"type" mapstructure:"type"`
}

type EmojiNodeAttrs struct {
	// Id corresponds to the JSON schema field "id".
	Id *string `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`

	// ShortName corresponds to the JSON schema field "shortName".
	ShortName string `json:"shortName" yaml:"shortName" mapstructure:"shortName"`

	// Text corresponds to the JSON schema field "text".
	Text *string `json:"text,omitempty" yaml:"text,omitempty" mapstructure:"text,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EmojiNodeAttrs) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["shortName"]; raw != nil && !ok {
		return fmt.Errorf("field shortName in EmojiNodeAttrs: required")
	}
	type Plain EmojiNodeAttrs
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = EmojiNodeAttrs(plain)
	return nil
}

type EmojiNodeType string

const EmojiNodeTypeEmoji EmojiNodeType = "emoji"

var enumValues_EmojiNodeType = []interface{}{
	"emoji",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EmojiNodeType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_EmojiNodeType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_EmojiNodeType, v)
	}
	*j = EmojiNodeType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EmojiNode) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["attrs"]; raw != nil && !ok {
		return fmt.Errorf("field attrs in EmojiNode: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in EmojiNode: required")
	}
	type Plain EmojiNode
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = EmojiNode(plain)
	return nil
}

type ExpandNode struct {
	// Attrs corresponds to the JSON schema field "attrs".
	Attrs ExpandNodeAttrs `json:"attrs" yaml:"attrs" mapstructure:"attrs"`

	// Content corresponds to the JSON schema field "content".
	Content []interface{} `json:"content" yaml:"content" mapstructure:"content"`

	// Marks corresponds to the JSON schema field "marks".
	Marks []interface{} `json:"marks,omitempty" yaml:"marks,omitempty" mapstructure:"marks,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type ExpandNodeType `json:"type" yaml:"type" mapstructure:"type"`
}

type ExpandNodeAttrs struct {
	// Title corresponds to the JSON schema field "title".
	Title *string `json:"title,omitempty" yaml:"title,omitempty" mapstructure:"title,omitempty"`
}

type ExpandNodeType string

const ExpandNodeTypeExpand ExpandNodeType = "expand"

var enumValues_ExpandNodeType = []interface{}{
	"expand",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ExpandNodeType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ExpandNodeType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ExpandNodeType, v)
	}
	*j = ExpandNodeType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ExpandNode) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["attrs"]; raw != nil && !ok {
		return fmt.Errorf("field attrs in ExpandNode: required")
	}
	if _, ok := raw["content"]; raw != nil && !ok {
		return fmt.Errorf("field content in ExpandNode: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in ExpandNode: required")
	}
	type Plain ExpandNode
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.Content != nil && len(plain.Content) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "content", 1)
	}
	*j = ExpandNode(plain)
	return nil
}

type ExpandWithBreakoutMarkNode interface{}

type ExpandWithNoMarkNode interface{}

type ExtensionNode struct {
	// Attrs corresponds to the JSON schema field "attrs".
	Attrs ExtensionNodeAttrs `json:"attrs" yaml:"attrs" mapstructure:"attrs"`

	// Marks corresponds to the JSON schema field "marks".
	Marks []interface{} `json:"marks,omitempty" yaml:"marks,omitempty" mapstructure:"marks,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type ExtensionNodeType `json:"type" yaml:"type" mapstructure:"type"`
}

type ExtensionNodeAttrs struct {
	// ExtensionKey corresponds to the JSON schema field "extensionKey".
	ExtensionKey string `json:"extensionKey" yaml:"extensionKey" mapstructure:"extensionKey"`

	// ExtensionType corresponds to the JSON schema field "extensionType".
	ExtensionType string `json:"extensionType" yaml:"extensionType" mapstructure:"extensionType"`

	// Layout corresponds to the JSON schema field "layout".
	Layout *ExtensionNodeAttrsLayout `json:"layout,omitempty" yaml:"layout,omitempty" mapstructure:"layout,omitempty"`

	// LocalId corresponds to the JSON schema field "localId".
	LocalId *string `json:"localId,omitempty" yaml:"localId,omitempty" mapstructure:"localId,omitempty"`

	// Parameters corresponds to the JSON schema field "parameters".
	Parameters interface{} `json:"parameters,omitempty" yaml:"parameters,omitempty" mapstructure:"parameters,omitempty"`

	// Text corresponds to the JSON schema field "text".
	Text *string `json:"text,omitempty" yaml:"text,omitempty" mapstructure:"text,omitempty"`
}

type ExtensionNodeAttrsLayout string

const ExtensionNodeAttrsLayoutDefault ExtensionNodeAttrsLayout = "default"
const ExtensionNodeAttrsLayoutFullWidth ExtensionNodeAttrsLayout = "full-width"
const ExtensionNodeAttrsLayoutWide ExtensionNodeAttrsLayout = "wide"

var enumValues_ExtensionNodeAttrsLayout = []interface{}{
	"wide",
	"full-width",
	"default",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ExtensionNodeAttrsLayout) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ExtensionNodeAttrsLayout {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ExtensionNodeAttrsLayout, v)
	}
	*j = ExtensionNodeAttrsLayout(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ExtensionNodeAttrs) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["extensionKey"]; raw != nil && !ok {
		return fmt.Errorf("field extensionKey in ExtensionNodeAttrs: required")
	}
	if _, ok := raw["extensionType"]; raw != nil && !ok {
		return fmt.Errorf("field extensionType in ExtensionNodeAttrs: required")
	}
	type Plain ExtensionNodeAttrs
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if len(plain.ExtensionKey) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "extensionKey", 1)
	}
	if len(plain.ExtensionType) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "extensionType", 1)
	}
	if plain.LocalId != nil && len(*plain.LocalId) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "localId", 1)
	}
	*j = ExtensionNodeAttrs(plain)
	return nil
}

type ExtensionNodeType string

const ExtensionNodeTypeExtension ExtensionNodeType = "extension"

var enumValues_ExtensionNodeType = []interface{}{
	"extension",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ExtensionNodeType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ExtensionNodeType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ExtensionNodeType, v)
	}
	*j = ExtensionNodeType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ExtensionNode) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["attrs"]; raw != nil && !ok {
		return fmt.Errorf("field attrs in ExtensionNode: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in ExtensionNode: required")
	}
	type Plain ExtensionNode
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ExtensionNode(plain)
	return nil
}

type ExtensionWithMarksNode interface{}

type FormattedTextInlineNode interface{}

type FragmentMark struct {
	// Attrs corresponds to the JSON schema field "attrs".
	Attrs FragmentMarkAttrs `json:"attrs" yaml:"attrs" mapstructure:"attrs"`

	// Type corresponds to the JSON schema field "type".
	Type FragmentMarkType `json:"type" yaml:"type" mapstructure:"type"`
}

type FragmentMarkAttrs struct {
	// LocalId corresponds to the JSON schema field "localId".
	LocalId string `json:"localId" yaml:"localId" mapstructure:"localId"`

	// Name corresponds to the JSON schema field "name".
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *FragmentMarkAttrs) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["localId"]; raw != nil && !ok {
		return fmt.Errorf("field localId in FragmentMarkAttrs: required")
	}
	type Plain FragmentMarkAttrs
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if len(plain.LocalId) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "localId", 1)
	}
	*j = FragmentMarkAttrs(plain)
	return nil
}

type FragmentMarkType string

const FragmentMarkTypeFragment FragmentMarkType = "fragment"

var enumValues_FragmentMarkType = []interface{}{
	"fragment",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *FragmentMarkType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_FragmentMarkType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_FragmentMarkType, v)
	}
	*j = FragmentMarkType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *FragmentMark) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["attrs"]; raw != nil && !ok {
		return fmt.Errorf("field attrs in FragmentMark: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in FragmentMark: required")
	}
	type Plain FragmentMark
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = FragmentMark(plain)
	return nil
}

type HardBreakNode struct {
	// Attrs corresponds to the JSON schema field "attrs".
	Attrs *HardBreakNodeAttrs `json:"attrs,omitempty" yaml:"attrs,omitempty" mapstructure:"attrs,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type HardBreakNodeType `json:"type" yaml:"type" mapstructure:"type"`
}

type HardBreakNodeAttrs struct {
	// Text corresponds to the JSON schema field "text".
	Text *HardBreakNodeAttrsTextType `json:"text,omitempty" yaml:"text,omitempty" mapstructure:"text,omitempty"`
}

type HardBreakNodeAttrsTextType string

const HardBreakNodeAttrsText HardBreakNodeAttrsTextType = "\n"

var enumValues_HardBreakNodeAttrsText = []interface{}{
	"\n",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *HardBreakNodeAttrsTextType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_HardBreakNodeAttrsText {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_HardBreakNodeAttrsText, v)
	}
	*j = HardBreakNodeAttrsTextType(v)
	return nil
}

type HardBreakNodeType string

const HardBreakNodeTypeHardBreak HardBreakNodeType = "hardBreak"

var enumValues_HardBreakNodeType = []interface{}{
	"hardBreak",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *HardBreakNodeType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_HardBreakNodeType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_HardBreakNodeType, v)
	}
	*j = HardBreakNodeType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *HardBreakNode) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in HardBreakNode: required")
	}
	type Plain HardBreakNode
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = HardBreakNode(plain)
	return nil
}

type HeadingNode struct {
	// Attrs corresponds to the JSON schema field "attrs".
	Attrs HeadingNodeAttrs `json:"attrs" yaml:"attrs" mapstructure:"attrs"`

	// Content corresponds to the JSON schema field "content".
	Content []HeadingNodeContentElem `json:"content,omitempty" yaml:"content,omitempty" mapstructure:"content,omitempty"`

	// Marks corresponds to the JSON schema field "marks".
	Marks []interface{} `json:"marks,omitempty" yaml:"marks,omitempty" mapstructure:"marks,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type HeadingNodeType `json:"type" yaml:"type" mapstructure:"type"`
}

type HeadingNodeAttrs struct {
	// Level corresponds to the JSON schema field "level".
	Level float64 `json:"level" yaml:"level" mapstructure:"level"`

	// LocalId corresponds to the JSON schema field "localId".
	LocalId *string `json:"localId,omitempty" yaml:"localId,omitempty" mapstructure:"localId,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *HeadingNodeAttrs) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["level"]; raw != nil && !ok {
		return fmt.Errorf("field level in HeadingNodeAttrs: required")
	}
	type Plain HeadingNodeAttrs
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if 6 < plain.Level {
		return fmt.Errorf("field %s: must be <= %v", "level", 6)
	}
	if 1 > plain.Level {
		return fmt.Errorf("field %s: must be >= %v", "level", 1)
	}
	*j = HeadingNodeAttrs(plain)
	return nil
}

type HeadingNodeContentElem interface{}

type HeadingNodeType string

const HeadingNodeTypeHeading HeadingNodeType = "heading"

var enumValues_HeadingNodeType = []interface{}{
	"heading",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *HeadingNodeType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_HeadingNodeType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_HeadingNodeType, v)
	}
	*j = HeadingNodeType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *HeadingNode) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["attrs"]; raw != nil && !ok {
		return fmt.Errorf("field attrs in HeadingNode: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in HeadingNode: required")
	}
	type Plain HeadingNode
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = HeadingNode(plain)
	return nil
}

type HeadingWithAlignmentNode interface{}

type HeadingWithIndentationNode interface{}

type HeadingWithNoMarksNode interface{}

type IndentationMark struct {
	// Attrs corresponds to the JSON schema field "attrs".
	Attrs IndentationMarkAttrs `json:"attrs" yaml:"attrs" mapstructure:"attrs"`

	// Type corresponds to the JSON schema field "type".
	Type IndentationMarkType `json:"type" yaml:"type" mapstructure:"type"`
}

type IndentationMarkAttrs struct {
	// Level corresponds to the JSON schema field "level".
	Level float64 `json:"level" yaml:"level" mapstructure:"level"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *IndentationMarkAttrs) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["level"]; raw != nil && !ok {
		return fmt.Errorf("field level in IndentationMarkAttrs: required")
	}
	type Plain IndentationMarkAttrs
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if 6 < plain.Level {
		return fmt.Errorf("field %s: must be <= %v", "level", 6)
	}
	if 1 > plain.Level {
		return fmt.Errorf("field %s: must be >= %v", "level", 1)
	}
	*j = IndentationMarkAttrs(plain)
	return nil
}

type IndentationMarkType string

const IndentationMarkTypeIndentation IndentationMarkType = "indentation"

var enumValues_IndentationMarkType = []interface{}{
	"indentation",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *IndentationMarkType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_IndentationMarkType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_IndentationMarkType, v)
	}
	*j = IndentationMarkType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *IndentationMark) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["attrs"]; raw != nil && !ok {
		return fmt.Errorf("field attrs in IndentationMark: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in IndentationMark: required")
	}
	type Plain IndentationMark
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = IndentationMark(plain)
	return nil
}

type InlineCardNode struct {
	// Attrs corresponds to the JSON schema field "attrs".
	Attrs interface{} `json:"attrs" yaml:"attrs" mapstructure:"attrs"`

	// Type corresponds to the JSON schema field "type".
	Type InlineCardNodeType `json:"type" yaml:"type" mapstructure:"type"`
}

type InlineCardNodeType string

const InlineCardNodeTypeInlineCard InlineCardNodeType = "inlineCard"

var enumValues_InlineCardNodeType = []interface{}{
	"inlineCard",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *InlineCardNodeType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_InlineCardNodeType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_InlineCardNodeType, v)
	}
	*j = InlineCardNodeType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *InlineCardNode) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["attrs"]; raw != nil && !ok {
		return fmt.Errorf("field attrs in InlineCardNode: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in InlineCardNode: required")
	}
	type Plain InlineCardNode
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = InlineCardNode(plain)
	return nil
}

type InlineExtensionNode struct {
	// Attrs corresponds to the JSON schema field "attrs".
	Attrs InlineExtensionNodeAttrs `json:"attrs" yaml:"attrs" mapstructure:"attrs"`

	// Marks corresponds to the JSON schema field "marks".
	Marks []interface{} `json:"marks,omitempty" yaml:"marks,omitempty" mapstructure:"marks,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type InlineExtensionNodeType `json:"type" yaml:"type" mapstructure:"type"`
}

type InlineExtensionNodeAttrs struct {
	// ExtensionKey corresponds to the JSON schema field "extensionKey".
	ExtensionKey string `json:"extensionKey" yaml:"extensionKey" mapstructure:"extensionKey"`

	// ExtensionType corresponds to the JSON schema field "extensionType".
	ExtensionType string `json:"extensionType" yaml:"extensionType" mapstructure:"extensionType"`

	// LocalId corresponds to the JSON schema field "localId".
	LocalId *string `json:"localId,omitempty" yaml:"localId,omitempty" mapstructure:"localId,omitempty"`

	// Parameters corresponds to the JSON schema field "parameters".
	Parameters interface{} `json:"parameters,omitempty" yaml:"parameters,omitempty" mapstructure:"parameters,omitempty"`

	// Text corresponds to the JSON schema field "text".
	Text *string `json:"text,omitempty" yaml:"text,omitempty" mapstructure:"text,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *InlineExtensionNodeAttrs) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["extensionKey"]; raw != nil && !ok {
		return fmt.Errorf("field extensionKey in InlineExtensionNodeAttrs: required")
	}
	if _, ok := raw["extensionType"]; raw != nil && !ok {
		return fmt.Errorf("field extensionType in InlineExtensionNodeAttrs: required")
	}
	type Plain InlineExtensionNodeAttrs
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if len(plain.ExtensionKey) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "extensionKey", 1)
	}
	if len(plain.ExtensionType) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "extensionType", 1)
	}
	if plain.LocalId != nil && len(*plain.LocalId) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "localId", 1)
	}
	*j = InlineExtensionNodeAttrs(plain)
	return nil
}

type InlineExtensionNodeType string

const InlineExtensionNodeTypeInlineExtension InlineExtensionNodeType = "inlineExtension"

var enumValues_InlineExtensionNodeType = []interface{}{
	"inlineExtension",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *InlineExtensionNodeType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_InlineExtensionNodeType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_InlineExtensionNodeType, v)
	}
	*j = InlineExtensionNodeType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *InlineExtensionNode) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["attrs"]; raw != nil && !ok {
		return fmt.Errorf("field attrs in InlineExtensionNode: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in InlineExtensionNode: required")
	}
	type Plain InlineExtensionNode
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = InlineExtensionNode(plain)
	return nil
}

type InlineExtensionWithMarksNode interface{}

type InlineNode interface{}

type LayoutColumnNode struct {
	// Attrs corresponds to the JSON schema field "attrs".
	Attrs LayoutColumnNodeAttrs `json:"attrs" yaml:"attrs" mapstructure:"attrs"`

	// Content corresponds to the JSON schema field "content".
	Content []LayoutColumnNodeContentElem `json:"content" yaml:"content" mapstructure:"content"`

	// Type corresponds to the JSON schema field "type".
	Type LayoutColumnNodeType `json:"type" yaml:"type" mapstructure:"type"`
}

type LayoutColumnNodeAttrs struct {
	// Width corresponds to the JSON schema field "width".
	Width float64 `json:"width" yaml:"width" mapstructure:"width"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LayoutColumnNodeAttrs) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["width"]; raw != nil && !ok {
		return fmt.Errorf("field width in LayoutColumnNodeAttrs: required")
	}
	type Plain LayoutColumnNodeAttrs
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if 100 < plain.Width {
		return fmt.Errorf("field %s: must be <= %v", "width", 100)
	}
	if 0 > plain.Width {
		return fmt.Errorf("field %s: must be >= %v", "width", 0)
	}
	*j = LayoutColumnNodeAttrs(plain)
	return nil
}

type LayoutColumnNodeContentElem interface{}

type LayoutColumnNodeType string

const LayoutColumnNodeTypeLayoutColumn LayoutColumnNodeType = "layoutColumn"

var enumValues_LayoutColumnNodeType = []interface{}{
	"layoutColumn",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LayoutColumnNodeType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_LayoutColumnNodeType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_LayoutColumnNodeType, v)
	}
	*j = LayoutColumnNodeType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LayoutColumnNode) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["attrs"]; raw != nil && !ok {
		return fmt.Errorf("field attrs in LayoutColumnNode: required")
	}
	if _, ok := raw["content"]; raw != nil && !ok {
		return fmt.Errorf("field content in LayoutColumnNode: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in LayoutColumnNode: required")
	}
	type Plain LayoutColumnNode
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.Content != nil && len(plain.Content) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "content", 1)
	}
	*j = LayoutColumnNode(plain)
	return nil
}

type LayoutSectionFullNode interface{}

type LayoutSectionNode struct {
	// Content corresponds to the JSON schema field "content".
	Content []LayoutColumnNode `json:"content" yaml:"content" mapstructure:"content"`

	// Marks corresponds to the JSON schema field "marks".
	Marks []BreakoutMark `json:"marks,omitempty" yaml:"marks,omitempty" mapstructure:"marks,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type LayoutSectionNodeType `json:"type" yaml:"type" mapstructure:"type"`
}

type LayoutSectionNodeType string

const LayoutSectionNodeTypeLayoutSection LayoutSectionNodeType = "layoutSection"

var enumValues_LayoutSectionNodeType = []interface{}{
	"layoutSection",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LayoutSectionNodeType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_LayoutSectionNodeType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_LayoutSectionNodeType, v)
	}
	*j = LayoutSectionNodeType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LayoutSectionNode) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["content"]; raw != nil && !ok {
		return fmt.Errorf("field content in LayoutSectionNode: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in LayoutSectionNode: required")
	}
	type Plain LayoutSectionNode
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = LayoutSectionNode(plain)
	return nil
}

type LinkMark struct {
	// Attrs corresponds to the JSON schema field "attrs".
	Attrs LinkMarkAttrs `json:"attrs" yaml:"attrs" mapstructure:"attrs"`

	// Type corresponds to the JSON schema field "type".
	Type LinkMarkType `json:"type" yaml:"type" mapstructure:"type"`
}

type LinkMarkAttrs struct {
	// Collection corresponds to the JSON schema field "collection".
	Collection *string `json:"collection,omitempty" yaml:"collection,omitempty" mapstructure:"collection,omitempty"`

	// Href corresponds to the JSON schema field "href".
	Href string `json:"href" yaml:"href" mapstructure:"href"`

	// Id corresponds to the JSON schema field "id".
	Id *string `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`

	// OccurrenceKey corresponds to the JSON schema field "occurrenceKey".
	OccurrenceKey *string `json:"occurrenceKey,omitempty" yaml:"occurrenceKey,omitempty" mapstructure:"occurrenceKey,omitempty"`

	// Title corresponds to the JSON schema field "title".
	Title *string `json:"title,omitempty" yaml:"title,omitempty" mapstructure:"title,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LinkMarkAttrs) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["href"]; raw != nil && !ok {
		return fmt.Errorf("field href in LinkMarkAttrs: required")
	}
	type Plain LinkMarkAttrs
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = LinkMarkAttrs(plain)
	return nil
}

type LinkMarkType string

const LinkMarkTypeLink LinkMarkType = "link"

var enumValues_LinkMarkType = []interface{}{
	"link",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LinkMarkType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_LinkMarkType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_LinkMarkType, v)
	}
	*j = LinkMarkType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LinkMark) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["attrs"]; raw != nil && !ok {
		return fmt.Errorf("field attrs in LinkMark: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in LinkMark: required")
	}
	type Plain LinkMark
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = LinkMark(plain)
	return nil
}

type MediaGroupNode struct {
	// Content corresponds to the JSON schema field "content".
	Content []MediaNode `json:"content" yaml:"content" mapstructure:"content"`

	// Type corresponds to the JSON schema field "type".
	Type MediaGroupNodeType `json:"type" yaml:"type" mapstructure:"type"`
}

type MediaGroupNodeType string

const MediaGroupNodeTypeMediaGroup MediaGroupNodeType = "mediaGroup"

var enumValues_MediaGroupNodeType = []interface{}{
	"mediaGroup",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MediaGroupNodeType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_MediaGroupNodeType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_MediaGroupNodeType, v)
	}
	*j = MediaGroupNodeType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MediaGroupNode) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["content"]; raw != nil && !ok {
		return fmt.Errorf("field content in MediaGroupNode: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in MediaGroupNode: required")
	}
	type Plain MediaGroupNode
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.Content != nil && len(plain.Content) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "content", 1)
	}
	*j = MediaGroupNode(plain)
	return nil
}

type MediaInlineNode struct {
	// Attrs corresponds to the JSON schema field "attrs".
	Attrs MediaInlineNodeAttrs `json:"attrs" yaml:"attrs" mapstructure:"attrs"`

	// Marks corresponds to the JSON schema field "marks".
	Marks []interface{} `json:"marks,omitempty" yaml:"marks,omitempty" mapstructure:"marks,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type MediaInlineNodeType `json:"type" yaml:"type" mapstructure:"type"`
}

type MediaInlineNodeAttrs struct {
	// Alt corresponds to the JSON schema field "alt".
	Alt *string `json:"alt,omitempty" yaml:"alt,omitempty" mapstructure:"alt,omitempty"`

	// Collection corresponds to the JSON schema field "collection".
	Collection string `json:"collection" yaml:"collection" mapstructure:"collection"`

	// Data corresponds to the JSON schema field "data".
	Data interface{} `json:"data,omitempty" yaml:"data,omitempty" mapstructure:"data,omitempty"`

	// Height corresponds to the JSON schema field "height".
	Height *float64 `json:"height,omitempty" yaml:"height,omitempty" mapstructure:"height,omitempty"`

	// Id corresponds to the JSON schema field "id".
	Id string `json:"id" yaml:"id" mapstructure:"id"`

	// OccurrenceKey corresponds to the JSON schema field "occurrenceKey".
	OccurrenceKey *string `json:"occurrenceKey,omitempty" yaml:"occurrenceKey,omitempty" mapstructure:"occurrenceKey,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type *MediaInlineNodeAttrsType `json:"type,omitempty" yaml:"type,omitempty" mapstructure:"type,omitempty"`

	// Width corresponds to the JSON schema field "width".
	Width *float64 `json:"width,omitempty" yaml:"width,omitempty" mapstructure:"width,omitempty"`
}

type MediaInlineNodeAttrsType string

const MediaInlineNodeAttrsTypeFile MediaInlineNodeAttrsType = "file"
const MediaInlineNodeAttrsTypeImage MediaInlineNodeAttrsType = "image"
const MediaInlineNodeAttrsTypeLink MediaInlineNodeAttrsType = "link"

var enumValues_MediaInlineNodeAttrsType = []interface{}{
	"link",
	"file",
	"image",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MediaInlineNodeAttrsType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_MediaInlineNodeAttrsType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_MediaInlineNodeAttrsType, v)
	}
	*j = MediaInlineNodeAttrsType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MediaInlineNodeAttrs) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["collection"]; raw != nil && !ok {
		return fmt.Errorf("field collection in MediaInlineNodeAttrs: required")
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in MediaInlineNodeAttrs: required")
	}
	type Plain MediaInlineNodeAttrs
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if len(plain.Id) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "id", 1)
	}
	if plain.OccurrenceKey != nil && len(*plain.OccurrenceKey) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "occurrenceKey", 1)
	}
	*j = MediaInlineNodeAttrs(plain)
	return nil
}

type MediaInlineNodeType string

const MediaInlineNodeTypeMediaInline MediaInlineNodeType = "mediaInline"

var enumValues_MediaInlineNodeType = []interface{}{
	"mediaInline",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MediaInlineNodeType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_MediaInlineNodeType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_MediaInlineNodeType, v)
	}
	*j = MediaInlineNodeType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MediaInlineNode) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["attrs"]; raw != nil && !ok {
		return fmt.Errorf("field attrs in MediaInlineNode: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in MediaInlineNode: required")
	}
	type Plain MediaInlineNode
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MediaInlineNode(plain)
	return nil
}

type MediaNode struct {
	// Attrs corresponds to the JSON schema field "attrs".
	Attrs interface{} `json:"attrs" yaml:"attrs" mapstructure:"attrs"`

	// Marks corresponds to the JSON schema field "marks".
	Marks []interface{} `json:"marks,omitempty" yaml:"marks,omitempty" mapstructure:"marks,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type MediaNodeType `json:"type" yaml:"type" mapstructure:"type"`
}

type MediaNodeType string

const MediaNodeTypeMedia MediaNodeType = "media"

var enumValues_MediaNodeType = []interface{}{
	"media",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MediaNodeType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_MediaNodeType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_MediaNodeType, v)
	}
	*j = MediaNodeType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MediaNode) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["attrs"]; raw != nil && !ok {
		return fmt.Errorf("field attrs in MediaNode: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in MediaNode: required")
	}
	type Plain MediaNode
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MediaNode(plain)
	return nil
}

type MediaSingleFullNode interface{}

type MediaSingleNode struct {
	// Attrs corresponds to the JSON schema field "attrs".
	Attrs interface{} `json:"attrs,omitempty" yaml:"attrs,omitempty" mapstructure:"attrs,omitempty"`

	// Marks corresponds to the JSON schema field "marks".
	Marks []LinkMark `json:"marks,omitempty" yaml:"marks,omitempty" mapstructure:"marks,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type MediaSingleNodeType `json:"type" yaml:"type" mapstructure:"type"`

	AdditionalProperties interface{} `mapstructure:",remain"`
}

type MediaSingleNodeType string

const MediaSingleNodeTypeMediaSingle MediaSingleNodeType = "mediaSingle"

var enumValues_MediaSingleNodeType = []interface{}{
	"mediaSingle",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MediaSingleNodeType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_MediaSingleNodeType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_MediaSingleNodeType, v)
	}
	*j = MediaSingleNodeType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MediaSingleNode) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in MediaSingleNode: required")
	}
	type Plain MediaSingleNode
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	st := reflect.TypeOf(Plain{})
	for i := range st.NumField() {
		delete(raw, st.Field(i).Name)
		delete(raw, strings.Split(st.Field(i).Tag.Get("json"), ",")[0])
	}
	if err := mapstructure.Decode(raw, &plain.AdditionalProperties); err != nil {
		return err
	}
	*j = MediaSingleNode(plain)
	return nil
}

type MentionNode struct {
	// Attrs corresponds to the JSON schema field "attrs".
	Attrs MentionNodeAttrs `json:"attrs" yaml:"attrs" mapstructure:"attrs"`

	// Type corresponds to the JSON schema field "type".
	Type MentionNodeType `json:"type" yaml:"type" mapstructure:"type"`
}

type MentionNodeAttrs struct {
	// AccessLevel corresponds to the JSON schema field "accessLevel".
	AccessLevel *string `json:"accessLevel,omitempty" yaml:"accessLevel,omitempty" mapstructure:"accessLevel,omitempty"`

	// Id corresponds to the JSON schema field "id".
	Id string `json:"id" yaml:"id" mapstructure:"id"`

	// LocalId corresponds to the JSON schema field "localId".
	LocalId *string `json:"localId,omitempty" yaml:"localId,omitempty" mapstructure:"localId,omitempty"`

	// Text corresponds to the JSON schema field "text".
	Text *string `json:"text,omitempty" yaml:"text,omitempty" mapstructure:"text,omitempty"`

	// UserType corresponds to the JSON schema field "userType".
	UserType *MentionNodeAttrsUserType `json:"userType,omitempty" yaml:"userType,omitempty" mapstructure:"userType,omitempty"`
}

type MentionNodeAttrsUserType string

const MentionNodeAttrsUserTypeAPP MentionNodeAttrsUserType = "APP"
const MentionNodeAttrsUserTypeDEFAULT MentionNodeAttrsUserType = "DEFAULT"
const MentionNodeAttrsUserTypeSPECIAL MentionNodeAttrsUserType = "SPECIAL"

var enumValues_MentionNodeAttrsUserType = []interface{}{
	"DEFAULT",
	"SPECIAL",
	"APP",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MentionNodeAttrsUserType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_MentionNodeAttrsUserType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_MentionNodeAttrsUserType, v)
	}
	*j = MentionNodeAttrsUserType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MentionNodeAttrs) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in MentionNodeAttrs: required")
	}
	type Plain MentionNodeAttrs
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MentionNodeAttrs(plain)
	return nil
}

type MentionNodeType string

const MentionNodeTypeMention MentionNodeType = "mention"

var enumValues_MentionNodeType = []interface{}{
	"mention",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MentionNodeType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_MentionNodeType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_MentionNodeType, v)
	}
	*j = MentionNodeType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MentionNode) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["attrs"]; raw != nil && !ok {
		return fmt.Errorf("field attrs in MentionNode: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in MentionNode: required")
	}
	type Plain MentionNode
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MentionNode(plain)
	return nil
}

type NestedExpandContent []interface{}

type NestedExpandNode struct {
	// Attrs corresponds to the JSON schema field "attrs".
	Attrs NestedExpandNodeAttrs `json:"attrs" yaml:"attrs" mapstructure:"attrs"`

	// Content corresponds to the JSON schema field "content".
	Content NestedExpandContent `json:"content" yaml:"content" mapstructure:"content"`

	// Type corresponds to the JSON schema field "type".
	Type NestedExpandNodeType `json:"type" yaml:"type" mapstructure:"type"`
}

type NestedExpandNodeAttrs struct {
	// Title corresponds to the JSON schema field "title".
	Title *string `json:"title,omitempty" yaml:"title,omitempty" mapstructure:"title,omitempty"`
}

type NestedExpandNodeType string

const NestedExpandNodeTypeNestedExpand NestedExpandNodeType = "nestedExpand"

var enumValues_NestedExpandNodeType = []interface{}{
	"nestedExpand",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NestedExpandNodeType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NestedExpandNodeType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NestedExpandNodeType, v)
	}
	*j = NestedExpandNodeType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NestedExpandNode) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["attrs"]; raw != nil && !ok {
		return fmt.Errorf("field attrs in NestedExpandNode: required")
	}
	if _, ok := raw["content"]; raw != nil && !ok {
		return fmt.Errorf("field content in NestedExpandNode: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in NestedExpandNode: required")
	}
	type Plain NestedExpandNode
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = NestedExpandNode(plain)
	return nil
}

type NestedExpandWithNoMarksNode interface{}

type NonNestableBlockContent interface{}

type PanelNode struct {
	// Attrs corresponds to the JSON schema field "attrs".
	Attrs PanelNodeAttrs `json:"attrs" yaml:"attrs" mapstructure:"attrs"`

	// Content corresponds to the JSON schema field "content".
	Content []interface{} `json:"content" yaml:"content" mapstructure:"content"`

	// Type corresponds to the JSON schema field "type".
	Type PanelNodeType `json:"type" yaml:"type" mapstructure:"type"`
}

type PanelNodeAttrs struct {
	// PanelColor corresponds to the JSON schema field "panelColor".
	PanelColor *string `json:"panelColor,omitempty" yaml:"panelColor,omitempty" mapstructure:"panelColor,omitempty"`

	// PanelIcon corresponds to the JSON schema field "panelIcon".
	PanelIcon *string `json:"panelIcon,omitempty" yaml:"panelIcon,omitempty" mapstructure:"panelIcon,omitempty"`

	// PanelIconId corresponds to the JSON schema field "panelIconId".
	PanelIconId *string `json:"panelIconId,omitempty" yaml:"panelIconId,omitempty" mapstructure:"panelIconId,omitempty"`

	// PanelIconText corresponds to the JSON schema field "panelIconText".
	PanelIconText *string `json:"panelIconText,omitempty" yaml:"panelIconText,omitempty" mapstructure:"panelIconText,omitempty"`

	// PanelType corresponds to the JSON schema field "panelType".
	PanelType PanelNodeAttrsPanelType `json:"panelType" yaml:"panelType" mapstructure:"panelType"`
}

type PanelNodeAttrsPanelType string

const PanelNodeAttrsPanelTypeCustom PanelNodeAttrsPanelType = "custom"
const PanelNodeAttrsPanelTypeError PanelNodeAttrsPanelType = "error"
const PanelNodeAttrsPanelTypeInfo PanelNodeAttrsPanelType = "info"
const PanelNodeAttrsPanelTypeNote PanelNodeAttrsPanelType = "note"
const PanelNodeAttrsPanelTypeSuccess PanelNodeAttrsPanelType = "success"
const PanelNodeAttrsPanelTypeTip PanelNodeAttrsPanelType = "tip"
const PanelNodeAttrsPanelTypeWarning PanelNodeAttrsPanelType = "warning"

var enumValues_PanelNodeAttrsPanelType = []interface{}{
	"info",
	"note",
	"tip",
	"warning",
	"error",
	"success",
	"custom",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PanelNodeAttrsPanelType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PanelNodeAttrsPanelType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PanelNodeAttrsPanelType, v)
	}
	*j = PanelNodeAttrsPanelType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PanelNodeAttrs) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["panelType"]; raw != nil && !ok {
		return fmt.Errorf("field panelType in PanelNodeAttrs: required")
	}
	type Plain PanelNodeAttrs
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PanelNodeAttrs(plain)
	return nil
}

type PanelNodeType string

const PanelNodeTypePanel PanelNodeType = "panel"

var enumValues_PanelNodeType = []interface{}{
	"panel",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PanelNodeType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PanelNodeType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PanelNodeType, v)
	}
	*j = PanelNodeType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PanelNode) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["attrs"]; raw != nil && !ok {
		return fmt.Errorf("field attrs in PanelNode: required")
	}
	if _, ok := raw["content"]; raw != nil && !ok {
		return fmt.Errorf("field content in PanelNode: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in PanelNode: required")
	}
	type Plain PanelNode
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.Content != nil && len(plain.Content) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "content", 1)
	}
	*j = PanelNode(plain)
	return nil
}

type ParagraphNode struct {
	// Attrs corresponds to the JSON schema field "attrs".
	Attrs *ParagraphNodeAttrs `json:"attrs,omitempty" yaml:"attrs,omitempty" mapstructure:"attrs,omitempty"`

	// Content corresponds to the JSON schema field "content".
	Content []ParagraphNodeContentElem `json:"content,omitempty" yaml:"content,omitempty" mapstructure:"content,omitempty"`

	// Marks corresponds to the JSON schema field "marks".
	Marks []interface{} `json:"marks,omitempty" yaml:"marks,omitempty" mapstructure:"marks,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type ParagraphNodeType `json:"type" yaml:"type" mapstructure:"type"`
}

type ParagraphNodeAttrs struct {
	// LocalId corresponds to the JSON schema field "localId".
	LocalId *string `json:"localId,omitempty" yaml:"localId,omitempty" mapstructure:"localId,omitempty"`
}

type ParagraphNodeContentElem interface{}

type ParagraphNodeType string

const ParagraphNodeTypeParagraph ParagraphNodeType = "paragraph"

var enumValues_ParagraphNodeType = []interface{}{
	"paragraph",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ParagraphNodeType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ParagraphNodeType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ParagraphNodeType, v)
	}
	*j = ParagraphNodeType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ParagraphNode) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in ParagraphNode: required")
	}
	type Plain ParagraphNode
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ParagraphNode(plain)
	return nil
}

type ParagraphWithAlignmentNode interface{}

type ParagraphWithIndentationNode interface{}

type ParagraphWithNoMarksNode interface{}

type PlaceholderNode struct {
	// Attrs corresponds to the JSON schema field "attrs".
	Attrs PlaceholderNodeAttrs `json:"attrs" yaml:"attrs" mapstructure:"attrs"`

	// Type corresponds to the JSON schema field "type".
	Type PlaceholderNodeType `json:"type" yaml:"type" mapstructure:"type"`
}

type PlaceholderNodeAttrs struct {
	// Text corresponds to the JSON schema field "text".
	Text string `json:"text" yaml:"text" mapstructure:"text"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PlaceholderNodeAttrs) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["text"]; raw != nil && !ok {
		return fmt.Errorf("field text in PlaceholderNodeAttrs: required")
	}
	type Plain PlaceholderNodeAttrs
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PlaceholderNodeAttrs(plain)
	return nil
}

type PlaceholderNodeType string

const PlaceholderNodeTypePlaceholder PlaceholderNodeType = "placeholder"

var enumValues_PlaceholderNodeType = []interface{}{
	"placeholder",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PlaceholderNodeType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PlaceholderNodeType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PlaceholderNodeType, v)
	}
	*j = PlaceholderNodeType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PlaceholderNode) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["attrs"]; raw != nil && !ok {
		return fmt.Errorf("field attrs in PlaceholderNode: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in PlaceholderNode: required")
	}
	type Plain PlaceholderNode
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PlaceholderNode(plain)
	return nil
}

type RuleNode struct {
	// Type corresponds to the JSON schema field "type".
	Type RuleNodeType `json:"type" yaml:"type" mapstructure:"type"`
}

type RuleNodeType string

const RuleNodeTypeRule RuleNodeType = "rule"

var enumValues_RuleNodeType = []interface{}{
	"rule",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RuleNodeType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_RuleNodeType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_RuleNodeType, v)
	}
	*j = RuleNodeType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RuleNode) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in RuleNode: required")
	}
	type Plain RuleNode
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = RuleNode(plain)
	return nil
}

type StatusNode struct {
	// Attrs corresponds to the JSON schema field "attrs".
	Attrs StatusNodeAttrs `json:"attrs" yaml:"attrs" mapstructure:"attrs"`

	// Type corresponds to the JSON schema field "type".
	Type StatusNodeType `json:"type" yaml:"type" mapstructure:"type"`
}

type StatusNodeAttrs struct {
	// Color corresponds to the JSON schema field "color".
	Color StatusNodeAttrsColor `json:"color" yaml:"color" mapstructure:"color"`

	// LocalId corresponds to the JSON schema field "localId".
	LocalId *string `json:"localId,omitempty" yaml:"localId,omitempty" mapstructure:"localId,omitempty"`

	// Style corresponds to the JSON schema field "style".
	Style *string `json:"style,omitempty" yaml:"style,omitempty" mapstructure:"style,omitempty"`

	// Text corresponds to the JSON schema field "text".
	Text string `json:"text" yaml:"text" mapstructure:"text"`
}

type StatusNodeAttrsColor string

const StatusNodeAttrsColorBlue StatusNodeAttrsColor = "blue"
const StatusNodeAttrsColorGreen StatusNodeAttrsColor = "green"
const StatusNodeAttrsColorNeutral StatusNodeAttrsColor = "neutral"
const StatusNodeAttrsColorPurple StatusNodeAttrsColor = "purple"
const StatusNodeAttrsColorRed StatusNodeAttrsColor = "red"
const StatusNodeAttrsColorYellow StatusNodeAttrsColor = "yellow"

var enumValues_StatusNodeAttrsColor = []interface{}{
	"neutral",
	"purple",
	"blue",
	"red",
	"yellow",
	"green",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *StatusNodeAttrsColor) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_StatusNodeAttrsColor {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_StatusNodeAttrsColor, v)
	}
	*j = StatusNodeAttrsColor(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *StatusNodeAttrs) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["color"]; raw != nil && !ok {
		return fmt.Errorf("field color in StatusNodeAttrs: required")
	}
	if _, ok := raw["text"]; raw != nil && !ok {
		return fmt.Errorf("field text in StatusNodeAttrs: required")
	}
	type Plain StatusNodeAttrs
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if len(plain.Text) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "text", 1)
	}
	*j = StatusNodeAttrs(plain)
	return nil
}

type StatusNodeType string

const StatusNodeTypeStatus StatusNodeType = "status"

var enumValues_StatusNodeType = []interface{}{
	"status",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *StatusNodeType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_StatusNodeType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_StatusNodeType, v)
	}
	*j = StatusNodeType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *StatusNode) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["attrs"]; raw != nil && !ok {
		return fmt.Errorf("field attrs in StatusNode: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in StatusNode: required")
	}
	type Plain StatusNode
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = StatusNode(plain)
	return nil
}

type StrikeMark struct {
	// Type corresponds to the JSON schema field "type".
	Type StrikeMarkType `json:"type" yaml:"type" mapstructure:"type"`
}

type StrikeMarkType string

const StrikeMarkTypeStrike StrikeMarkType = "strike"

var enumValues_StrikeMarkType = []interface{}{
	"strike",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *StrikeMarkType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_StrikeMarkType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_StrikeMarkType, v)
	}
	*j = StrikeMarkType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *StrikeMark) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in StrikeMark: required")
	}
	type Plain StrikeMark
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = StrikeMark(plain)
	return nil
}

type StrongMark struct {
	// Type corresponds to the JSON schema field "type".
	Type StrongMarkType `json:"type" yaml:"type" mapstructure:"type"`
}

type StrongMarkType string

const StrongMarkTypeStrong StrongMarkType = "strong"

var enumValues_StrongMarkType = []interface{}{
	"strong",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *StrongMarkType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_StrongMarkType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_StrongMarkType, v)
	}
	*j = StrongMarkType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *StrongMark) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in StrongMark: required")
	}
	type Plain StrongMark
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = StrongMark(plain)
	return nil
}

type SubsupMark struct {
	// Attrs corresponds to the JSON schema field "attrs".
	Attrs SubsupMarkAttrs `json:"attrs" yaml:"attrs" mapstructure:"attrs"`

	// Type corresponds to the JSON schema field "type".
	Type SubsupMarkType `json:"type" yaml:"type" mapstructure:"type"`
}

type SubsupMarkAttrs struct {
	// Type corresponds to the JSON schema field "type".
	Type SubsupMarkAttrsType `json:"type" yaml:"type" mapstructure:"type"`
}

type SubsupMarkAttrsType string

const SubsupMarkAttrsTypeSub SubsupMarkAttrsType = "sub"
const SubsupMarkAttrsTypeSup SubsupMarkAttrsType = "sup"

var enumValues_SubsupMarkAttrsType = []interface{}{
	"sub",
	"sup",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SubsupMarkAttrsType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SubsupMarkAttrsType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SubsupMarkAttrsType, v)
	}
	*j = SubsupMarkAttrsType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SubsupMarkAttrs) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in SubsupMarkAttrs: required")
	}
	type Plain SubsupMarkAttrs
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SubsupMarkAttrs(plain)
	return nil
}

type SubsupMarkType string

const SubsupMarkTypeSubsup SubsupMarkType = "subsup"

var enumValues_SubsupMarkType = []interface{}{
	"subsup",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SubsupMarkType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SubsupMarkType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SubsupMarkType, v)
	}
	*j = SubsupMarkType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SubsupMark) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["attrs"]; raw != nil && !ok {
		return fmt.Errorf("field attrs in SubsupMark: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in SubsupMark: required")
	}
	type Plain SubsupMark
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SubsupMark(plain)
	return nil
}

type TableCellContent []interface{}

type TableCellNode struct {
	// Attrs corresponds to the JSON schema field "attrs".
	Attrs *TableCellNodeAttrs `json:"attrs,omitempty" yaml:"attrs,omitempty" mapstructure:"attrs,omitempty"`

	// Content corresponds to the JSON schema field "content".
	Content TableCellContent `json:"content" yaml:"content" mapstructure:"content"`

	// Type corresponds to the JSON schema field "type".
	Type TableCellNodeType `json:"type" yaml:"type" mapstructure:"type"`
}

type TableCellNodeAttrs struct {
	// Background corresponds to the JSON schema field "background".
	Background *string `json:"background,omitempty" yaml:"background,omitempty" mapstructure:"background,omitempty"`

	// Colspan corresponds to the JSON schema field "colspan".
	Colspan *float64 `json:"colspan,omitempty" yaml:"colspan,omitempty" mapstructure:"colspan,omitempty"`

	// Colwidth corresponds to the JSON schema field "colwidth".
	Colwidth []float64 `json:"colwidth,omitempty" yaml:"colwidth,omitempty" mapstructure:"colwidth,omitempty"`

	// Rowspan corresponds to the JSON schema field "rowspan".
	Rowspan *float64 `json:"rowspan,omitempty" yaml:"rowspan,omitempty" mapstructure:"rowspan,omitempty"`
}

type TableCellNodeType string

const TableCellNodeTypeTableCell TableCellNodeType = "tableCell"

var enumValues_TableCellNodeType = []interface{}{
	"tableCell",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TableCellNodeType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TableCellNodeType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TableCellNodeType, v)
	}
	*j = TableCellNodeType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TableCellNode) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["content"]; raw != nil && !ok {
		return fmt.Errorf("field content in TableCellNode: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in TableCellNode: required")
	}
	type Plain TableCellNode
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = TableCellNode(plain)
	return nil
}

type TableHeaderNode struct {
	// Attrs corresponds to the JSON schema field "attrs".
	Attrs *TableHeaderNodeAttrs `json:"attrs,omitempty" yaml:"attrs,omitempty" mapstructure:"attrs,omitempty"`

	// Content corresponds to the JSON schema field "content".
	Content TableCellContent `json:"content" yaml:"content" mapstructure:"content"`

	// Type corresponds to the JSON schema field "type".
	Type TableHeaderNodeType `json:"type" yaml:"type" mapstructure:"type"`
}

type TableHeaderNodeAttrs struct {
	// Background corresponds to the JSON schema field "background".
	Background *string `json:"background,omitempty" yaml:"background,omitempty" mapstructure:"background,omitempty"`

	// Colspan corresponds to the JSON schema field "colspan".
	Colspan *float64 `json:"colspan,omitempty" yaml:"colspan,omitempty" mapstructure:"colspan,omitempty"`

	// Colwidth corresponds to the JSON schema field "colwidth".
	Colwidth []float64 `json:"colwidth,omitempty" yaml:"colwidth,omitempty" mapstructure:"colwidth,omitempty"`

	// Rowspan corresponds to the JSON schema field "rowspan".
	Rowspan *float64 `json:"rowspan,omitempty" yaml:"rowspan,omitempty" mapstructure:"rowspan,omitempty"`
}

type TableHeaderNodeType string

const TableHeaderNodeTypeTableHeader TableHeaderNodeType = "tableHeader"

var enumValues_TableHeaderNodeType = []interface{}{
	"tableHeader",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TableHeaderNodeType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TableHeaderNodeType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TableHeaderNodeType, v)
	}
	*j = TableHeaderNodeType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TableHeaderNode) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["content"]; raw != nil && !ok {
		return fmt.Errorf("field content in TableHeaderNode: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in TableHeaderNode: required")
	}
	type Plain TableHeaderNode
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = TableHeaderNode(plain)
	return nil
}

type TableNode struct {
	// Attrs corresponds to the JSON schema field "attrs".
	Attrs *TableNodeAttrs `json:"attrs,omitempty" yaml:"attrs,omitempty" mapstructure:"attrs,omitempty"`

	// Content corresponds to the JSON schema field "content".
	Content []*TableRowNode `json:"content" yaml:"content" mapstructure:"content"`

	// Marks corresponds to the JSON schema field "marks".
	Marks []FragmentMark `json:"marks,omitempty" yaml:"marks,omitempty" mapstructure:"marks,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type TableNodeType `json:"type" yaml:"type" mapstructure:"type"`
}

type TableNodeAttrs struct {
	// DisplayMode corresponds to the JSON schema field "displayMode".
	DisplayMode *TableNodeAttrsDisplayMode `json:"displayMode,omitempty" yaml:"displayMode,omitempty" mapstructure:"displayMode,omitempty"`

	// IsNumberColumnEnabled corresponds to the JSON schema field
	// "isNumberColumnEnabled".
	IsNumberColumnEnabled *bool `json:"isNumberColumnEnabled,omitempty" yaml:"isNumberColumnEnabled,omitempty" mapstructure:"isNumberColumnEnabled,omitempty"`

	// Layout corresponds to the JSON schema field "layout".
	Layout *TableNodeAttrsLayout `json:"layout,omitempty" yaml:"layout,omitempty" mapstructure:"layout,omitempty"`

	// LocalId corresponds to the JSON schema field "localId".
	LocalId *string `json:"localId,omitempty" yaml:"localId,omitempty" mapstructure:"localId,omitempty"`

	// Width corresponds to the JSON schema field "width".
	Width *float64 `json:"width,omitempty" yaml:"width,omitempty" mapstructure:"width,omitempty"`
}

type TableNodeAttrsDisplayMode string

const TableNodeAttrsDisplayModeDefault TableNodeAttrsDisplayMode = "default"
const TableNodeAttrsDisplayModeFixed TableNodeAttrsDisplayMode = "fixed"

var enumValues_TableNodeAttrsDisplayMode = []interface{}{
	"default",
	"fixed",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TableNodeAttrsDisplayMode) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TableNodeAttrsDisplayMode {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TableNodeAttrsDisplayMode, v)
	}
	*j = TableNodeAttrsDisplayMode(v)
	return nil
}

type TableNodeAttrsLayout string

const TableNodeAttrsLayoutAlignEnd TableNodeAttrsLayout = "align-end"
const TableNodeAttrsLayoutAlignStart TableNodeAttrsLayout = "align-start"
const TableNodeAttrsLayoutCenter TableNodeAttrsLayout = "center"
const TableNodeAttrsLayoutDefault TableNodeAttrsLayout = "default"
const TableNodeAttrsLayoutFullWidth TableNodeAttrsLayout = "full-width"
const TableNodeAttrsLayoutWide TableNodeAttrsLayout = "wide"

var enumValues_TableNodeAttrsLayout = []interface{}{
	"wide",
	"full-width",
	"center",
	"align-end",
	"align-start",
	"default",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TableNodeAttrsLayout) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TableNodeAttrsLayout {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TableNodeAttrsLayout, v)
	}
	*j = TableNodeAttrsLayout(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TableNodeAttrs) UnmarshalJSON(b []byte) error {
	type Plain TableNodeAttrs
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.LocalId != nil && len(*plain.LocalId) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "localId", 1)
	}
	*j = TableNodeAttrs(plain)
	return nil
}

type TableNodeType string

const TableNodeTypeTable TableNodeType = "table"

var enumValues_TableNodeType = []interface{}{
	"table",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TableNodeType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TableNodeType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TableNodeType, v)
	}
	*j = TableNodeType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TableNode) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["content"]; raw != nil && !ok {
		return fmt.Errorf("field content in TableNode: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in TableNode: required")
	}
	type Plain TableNode
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.Content != nil && len(plain.Content) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "content", 1)
	}
	*j = TableNode(plain)
	return nil
}

type TableRowNode struct {
	// Content corresponds to the JSON schema field "content".
	Content []interface{} `json:"content" yaml:"content" mapstructure:"content"`

	// Type corresponds to the JSON schema field "type".
	Type TableRowNodeType `json:"type" yaml:"type" mapstructure:"type"`
}

type TableRowNodeType string

const TableRowNodeTypeTableRow TableRowNodeType = "tableRow"

var enumValues_TableRowNodeType = []interface{}{
	"tableRow",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TableRowNodeType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TableRowNodeType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TableRowNodeType, v)
	}
	*j = TableRowNodeType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TableRowNode) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["content"]; raw != nil && !ok {
		return fmt.Errorf("field content in TableRowNode: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in TableRowNode: required")
	}
	type Plain TableRowNode
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = TableRowNode(plain)
	return nil
}

type TaskItemNode struct {
	// Attrs corresponds to the JSON schema field "attrs".
	Attrs TaskItemNodeAttrs `json:"attrs" yaml:"attrs" mapstructure:"attrs"`

	// Content corresponds to the JSON schema field "content".
	Content []TaskItemNodeContentElem `json:"content,omitempty" yaml:"content,omitempty" mapstructure:"content,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type TaskItemNodeType `json:"type" yaml:"type" mapstructure:"type"`
}

type TaskItemNodeAttrs struct {
	// LocalId corresponds to the JSON schema field "localId".
	LocalId string `json:"localId" yaml:"localId" mapstructure:"localId"`

	// State corresponds to the JSON schema field "state".
	State TaskItemNodeAttrsState `json:"state" yaml:"state" mapstructure:"state"`
}

type TaskItemNodeAttrsState string

const TaskItemNodeAttrsStateDONE TaskItemNodeAttrsState = "DONE"
const TaskItemNodeAttrsStateTODO TaskItemNodeAttrsState = "TODO"

var enumValues_TaskItemNodeAttrsState = []interface{}{
	"TODO",
	"DONE",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TaskItemNodeAttrsState) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TaskItemNodeAttrsState {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TaskItemNodeAttrsState, v)
	}
	*j = TaskItemNodeAttrsState(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TaskItemNodeAttrs) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["localId"]; raw != nil && !ok {
		return fmt.Errorf("field localId in TaskItemNodeAttrs: required")
	}
	if _, ok := raw["state"]; raw != nil && !ok {
		return fmt.Errorf("field state in TaskItemNodeAttrs: required")
	}
	type Plain TaskItemNodeAttrs
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = TaskItemNodeAttrs(plain)
	return nil
}

type TaskItemNodeContentElem interface{}

type TaskItemNodeType string

const TaskItemNodeTypeTaskItem TaskItemNodeType = "taskItem"

var enumValues_TaskItemNodeType = []interface{}{
	"taskItem",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TaskItemNodeType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TaskItemNodeType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TaskItemNodeType, v)
	}
	*j = TaskItemNodeType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TaskItemNode) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["attrs"]; raw != nil && !ok {
		return fmt.Errorf("field attrs in TaskItemNode: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in TaskItemNode: required")
	}
	type Plain TaskItemNode
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = TaskItemNode(plain)
	return nil
}

type TextColorMark struct {
	// Attrs corresponds to the JSON schema field "attrs".
	Attrs TextColorMarkAttrs `json:"attrs" yaml:"attrs" mapstructure:"attrs"`

	// Type corresponds to the JSON schema field "type".
	Type TextColorMarkType `json:"type" yaml:"type" mapstructure:"type"`
}

type TextColorMarkAttrs struct {
	// Color corresponds to the JSON schema field "color".
	Color string `json:"color" yaml:"color" mapstructure:"color"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TextColorMarkAttrs) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["color"]; raw != nil && !ok {
		return fmt.Errorf("field color in TextColorMarkAttrs: required")
	}
	type Plain TextColorMarkAttrs
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if matched, _ := regexp.MatchString("^#[0-9a-fA-F]{6}$", string(plain.Color)); !matched {
		return fmt.Errorf("field %s pattern match: must match %s", "^#[0-9a-fA-F]{6}$", "Color")
	}
	*j = TextColorMarkAttrs(plain)
	return nil
}

type TextColorMarkType string

const TextColorMarkTypeTextColor TextColorMarkType = "textColor"

var enumValues_TextColorMarkType = []interface{}{
	"textColor",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TextColorMarkType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TextColorMarkType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TextColorMarkType, v)
	}
	*j = TextColorMarkType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TextColorMark) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["attrs"]; raw != nil && !ok {
		return fmt.Errorf("field attrs in TextColorMark: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in TextColorMark: required")
	}
	type Plain TextColorMark
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = TextColorMark(plain)
	return nil
}

type TextNode struct {
	// Marks corresponds to the JSON schema field "marks".
	Marks []interface{} `json:"marks,omitempty" yaml:"marks,omitempty" mapstructure:"marks,omitempty"`

	// Text corresponds to the JSON schema field "text".
	Text string `json:"text" yaml:"text" mapstructure:"text"`

	// Type corresponds to the JSON schema field "type".
	Type TextNodeType `json:"type" yaml:"type" mapstructure:"type"`
}

type TextNodeType string

const TextNodeTypeText TextNodeType = "text"

var enumValues_TextNodeType = []interface{}{
	"text",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TextNodeType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TextNodeType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TextNodeType, v)
	}
	*j = TextNodeType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TextNode) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["text"]; raw != nil && !ok {
		return fmt.Errorf("field text in TextNode: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in TextNode: required")
	}
	type Plain TextNode
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if len(plain.Text) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "text", 1)
	}
	*j = TextNode(plain)
	return nil
}

type UnderlineMark struct {
	// Type corresponds to the JSON schema field "type".
	Type UnderlineMarkType `json:"type" yaml:"type" mapstructure:"type"`
}

type UnderlineMarkType string

const UnderlineMarkTypeUnderline UnderlineMarkType = "underline"

var enumValues_UnderlineMarkType = []interface{}{
	"underline",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *UnderlineMarkType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_UnderlineMarkType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_UnderlineMarkType, v)
	}
	*j = UnderlineMarkType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *UnderlineMark) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in UnderlineMark: required")
	}
	type Plain UnderlineMark
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = UnderlineMark(plain)
	return nil
}
